{
    "https://api.github.com/repos/koush/AndroidAsync": {
        "forks": 1560,
        "watchers": 7531,
        "stars": 7531,
        "languages": {
            "Java": 667974,
            "Kotlin": 1493,
            "Makefile": 801
        },
        "commits": [
            "2022-11-23T15:20:07Z",
            "2022-11-23T14:30:25Z",
            "2020-12-20T20:01:46Z",
            "2020-12-06T07:43:43Z",
            "2020-11-29T18:03:58Z",
            "2020-11-25T09:14:47Z",
            "2020-11-24T10:35:28Z",
            "2020-11-24T10:34:45Z",
            "2020-11-13T00:15:15Z",
            "2020-11-08T08:24:11Z",
            "2020-05-18T02:29:00Z",
            "2020-05-16T19:49:19Z",
            "2020-02-11T07:22:07Z",
            "2020-01-21T04:34:01Z",
            "2020-01-19T00:07:02Z",
            "2020-01-19T00:06:49Z",
            "2019-12-02T19:40:35Z",
            "2019-12-02T19:40:09Z",
            "2019-12-02T19:39:54Z",
            "2019-12-02T19:39:10Z",
            "2019-12-02T19:39:02Z",
            "2019-12-01T06:13:20Z",
            "2019-11-16T19:08:21Z",
            "2019-11-14T17:41:30Z",
            "2019-10-25T00:29:15Z",
            "2019-10-03T01:09:04Z",
            "2019-10-03T01:09:00Z",
            "2019-10-03T00:47:14Z",
            "2019-10-02T20:29:46Z",
            "2019-10-02T20:28:52Z"
        ],
        "creation_date": "2012-08-24T07:27:04Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 407,
        "readme": "# AndroidAsync\r\n\r\nAndroidAsync is a low level network protocol library. If you are looking for an easy to use, higher level, Android aware,\r\nhttp request library, check out [Ion](https://github.com/koush/ion) (it is built on top of AndroidAsync). The typical Android\r\napp developer would probably be more interested in Ion.\r\n\r\nBut if you're looking for a raw Socket, HTTP(s) client/server, and WebSocket library for Android, AndroidAsync\r\nis it.\r\n\r\n#### Features\r\n * Based on NIO. Single threaded and callback driven.\r\n * All operations return a Future that can be cancelled\r\n * Socket client + socket server\r\n * HTTP client + server\r\n * WebSocket client + server\r\n\r\n### Download\r\n\r\nDownload [the latest JAR](https://search.maven.org/remote_content?g=com.koushikdutta.async&a=androidasync&v=LATEST\r\n) or grab via Maven:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.koushikdutta.async</groupId>\r\n    <artifactId>androidasync</artifactId>\r\n    <version>(insert latest version)</version>\r\n</dependency>\r\n```\r\n\r\nGradle: \r\n```groovy\r\ndependencies {\r\n    compile 'com.koushikdutta.async:androidasync:2.+'\r\n}\r\n```\r\n\r\n### Download a url to a String\r\n\r\n```java\r\n// url is the URL to download.\r\nAsyncHttpClient.getDefaultInstance().getString(url, new AsyncHttpClient.StringCallback() {\r\n    // Callback is invoked with any exceptions/errors, and the result, if available.\r\n    @Override\r\n    public void onCompleted(Exception e, AsyncHttpResponse response, String result) {\r\n        if (e != null) {\r\n            e.printStackTrace();\r\n            return;\r\n        }\r\n        System.out.println(\"I got a string: \" + result);\r\n    }\r\n});\r\n```\r\n\r\n\r\n### Download JSON from a url\r\n\r\n```java\r\n// url is the URL to download.\r\nAsyncHttpClient.getDefaultInstance().getJSONObject(url, new AsyncHttpClient.JSONObjectCallback() {\r\n    // Callback is invoked with any exceptions/errors, and the result, if available.\r\n    @Override\r\n    public void onCompleted(Exception e, AsyncHttpResponse response, JSONObject result) {\r\n        if (e != null) {\r\n            e.printStackTrace();\r\n            return;\r\n        }\r\n        System.out.println(\"I got a JSONObject: \" + result);\r\n    }\r\n});\r\n```\r\n\r\nOr for JSONArrays...\r\n\r\n```java\r\n// url is the URL to download.\r\nAsyncHttpClient.getDefaultInstance().getJSONArray(url, new AsyncHttpClient.JSONArrayCallback() {\r\n    // Callback is invoked with any exceptions/errors, and the result, if available.\r\n    @Override\r\n    public void onCompleted(Exception e, AsyncHttpResponse response, JSONArray result) {\r\n        if (e != null) {\r\n            e.printStackTrace();\r\n            return;\r\n        }\r\n        System.out.println(\"I got a JSONArray: \" + result);\r\n    }\r\n});\r\n```\r\n\r\n\r\n### Download a url to a file\r\n\r\n```java\r\nAsyncHttpClient.getDefaultInstance().getFile(url, filename, new AsyncHttpClient.FileCallback() {\r\n    @Override\r\n    public void onCompleted(Exception e, AsyncHttpResponse response, File result) {\r\n        if (e != null) {\r\n            e.printStackTrace();\r\n            return;\r\n        }\r\n        System.out.println(\"my file is available at: \" + result.getAbsolutePath());\r\n    }\r\n});\r\n```\r\n\r\n\r\n### Caching is supported too\r\n\r\n```java\r\n// arguments are the http client, the directory to store cache files,\r\n// and the size of the cache in bytes\r\nResponseCacheMiddleware.addCache(AsyncHttpClient.getDefaultInstance(),\r\n                                  getFileStreamPath(\"asynccache\"),\r\n                                  1024 * 1024 * 10);\r\n```\r\n\r\n\r\n### Need to do multipart/form-data uploads? That works too.\r\n\r\n```java\r\nAsyncHttpPost post = new AsyncHttpPost(\"http://myservercom/postform.html\");\r\nMultipartFormDataBody body = new MultipartFormDataBody();\r\nbody.addFilePart(\"my-file\", new File(\"/path/to/file.txt\");\r\nbody.addStringPart(\"foo\", \"bar\");\r\npost.setBody(body);\r\nAsyncHttpClient.getDefaultInstance().executeString(post, new AsyncHttpClient.StringCallback(){\r\n        @Override\r\n        public void onCompleted(Exception ex, AsyncHttpResponse source, String result) {\r\n            if (ex != null) {\r\n                ex.printStackTrace();\r\n                return;\r\n            }\r\n            System.out.println(\"Server says: \" + result);\r\n        }\r\n    });\r\n```\r\n\r\n\r\n### Can also create web sockets:\r\n\r\n```java\r\nAsyncHttpClient.getDefaultInstance().websocket(get, \"my-protocol\", new WebSocketConnectCallback() {\r\n    @Override\r\n    public void onCompleted(Exception ex, WebSocket webSocket) {\r\n        if (ex != null) {\r\n            ex.printStackTrace();\r\n            return;\r\n        }\r\n        webSocket.send(\"a string\");\r\n        webSocket.send(new byte[10]);\r\n        webSocket.setStringCallback(new StringCallback() {\r\n            public void onStringAvailable(String s) {\r\n                System.out.println(\"I got a string: \" + s);\r\n            }\r\n        });\r\n        webSocket.setDataCallback(new DataCallback() {\r\n            public void onDataAvailable(DataEmitter emitter, ByteBufferList byteBufferList) {\r\n                System.out.println(\"I got some bytes!\");\r\n                // note that this data has been read\r\n                byteBufferList.recycle();\r\n            }\r\n        });\r\n    }\r\n});\r\n```\r\n\r\n\r\n### AndroidAsync also let's you create simple HTTP servers:\r\n\r\n```java\r\nAsyncHttpServer server = new AsyncHttpServer();\r\n\r\nList<WebSocket> _sockets = new ArrayList<WebSocket>();\r\n\r\nserver.get(\"/\", new HttpServerRequestCallback() {\r\n    @Override\r\n    public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse response) {\r\n        response.send(\"Hello!!!\");\r\n    }\r\n});\r\n\r\n// listen on port 5000\r\nserver.listen(5000);\r\n// browsing http://localhost:5000 will return Hello!!!\r\n\r\n```\r\n\r\n### And WebSocket Servers:\r\n\r\n```java\r\nAsyncHttpServer httpServer = new AsyncHttpServer();\r\n\r\nhttpServer.listen(AsyncServer.getDefault(), port);\r\n\r\nhttpServer.websocket(\"/live\", new AsyncHttpServer.WebSocketRequestCallback() {\r\n    @Override\r\n    public void onConnected(final WebSocket webSocket, AsyncHttpServerRequest request) {\r\n        _sockets.add(webSocket);\r\n        \r\n        //Use this to clean up any references to your websocket\r\n        webSocket.setClosedCallback(new CompletedCallback() {\r\n            @Override\r\n            public void onCompleted(Exception ex) {\r\n                try {\r\n                    if (ex != null)\r\n                        Log.e(\"WebSocket\", \"An error occurred\", ex);\r\n                } finally {\r\n                    _sockets.remove(webSocket);\r\n                }\r\n            }\r\n        });\r\n        \r\n        webSocket.setStringCallback(new StringCallback() {\r\n            @Override\r\n            public void onStringAvailable(String s) {\r\n                if (\"Hello Server\".equals(s))\r\n                    webSocket.send(\"Welcome Client!\");\r\n            }\r\n        });\r\n    \r\n    }\r\n});\r\n\r\n//..Sometime later, broadcast!\r\nfor (WebSocket socket : _sockets)\r\n    socket.send(\"Fireball!\");\r\n```\r\n\r\n### Futures\r\n\r\nAll the API calls return [Futures](http://en.wikipedia.org/wiki/Futures_and_promises).\r\n\r\n```java\r\nFuture<String> string = client.getString(\"http://foo.com/hello.txt\");\r\n// this will block, and may also throw if there was an error!\r\nString value = string.get();\r\n```\r\n\r\nFutures can also have callbacks...\r\n\r\n```java\r\nFuture<String> string = client.getString(\"http://foo.com/hello.txt\");\r\nstring.setCallback(new FutureCallback<String>() {\r\n    @Override\r\n    public void onCompleted(Exception e, String result) {\r\n        System.out.println(result);\r\n    }\r\n});\r\n```\r\n\r\nFor brevity...\r\n\r\n```java\r\nclient.getString(\"http://foo.com/hello.txt\")\r\n.setCallback(new FutureCallback<String>() {\r\n    @Override\r\n    public void onCompleted(Exception e, String result) {\r\n        System.out.println(result);\r\n    }\r\n});\r\n```\r\n",
        "releases": []
    }
}
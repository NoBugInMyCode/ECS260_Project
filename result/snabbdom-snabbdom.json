{
    "https://api.github.com/repos/snabbdom/snabbdom": {
        "forks": 1107,
        "watchers": 12058,
        "stars": 12058,
        "languages": {
            "TypeScript": 154831,
            "JavaScript": 3393,
            "HTML": 296,
            "Shell": 282
        },
        "commits": [
            "2024-10-24T19:34:38Z",
            "2024-07-10T09:05:05Z",
            "2024-06-16T12:46:36Z",
            "2024-03-20T18:22:35Z",
            "2024-03-19T19:03:18Z",
            "2024-03-02T20:08:28Z",
            "2024-02-26T20:14:33Z",
            "2024-02-20T20:40:13Z",
            "2024-02-13T12:46:52Z",
            "2024-02-07T09:18:21Z",
            "2024-01-31T09:10:33Z",
            "2024-01-31T09:05:40Z",
            "2024-01-30T09:33:42Z",
            "2024-01-30T09:25:03Z",
            "2024-01-26T10:58:25Z",
            "2024-01-23T07:59:47Z",
            "2024-01-20T08:01:44Z",
            "2024-01-18T17:47:53Z",
            "2024-01-18T17:44:40Z",
            "2024-01-16T14:57:05Z",
            "2024-01-16T14:53:28Z",
            "2024-01-16T14:32:00Z",
            "2024-01-16T14:23:27Z",
            "2024-01-15T13:38:35Z",
            "2024-01-15T13:04:06Z",
            "2024-01-07T09:17:51Z",
            "2023-12-03T10:03:33Z",
            "2023-12-03T08:32:48Z",
            "2023-11-29T13:05:10Z",
            "2023-11-29T13:03:07Z"
        ],
        "creation_date": "2015-05-09T20:25:10Z",
        "contributors": 30,
        "topics": [
            "hacktoberfest",
            "snabbdom",
            "virtual-dom-library"
        ],
        "subscribers": 157,
        "readme": "<img alt=\"Snabbdom\" src=\"https://raw.githubusercontent.com/snabbdom/snabbdom/master/readme-title.svg\" width=\"356px\">\n\nA virtual DOM library with a focus on simplicity, modularity, powerful features\nand performance.\n\n---\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-brightgreen.svg)](https://opensource.org/licenses/MIT)\n[![Build Status](https://github.com/snabbdom/snabbdom/actions/workflows/test.yml/badge.svg)](https://github.com/snabbdom/snabbdom/actions/workflows/test.yml)\n[![npm version](https://badge.fury.io/js/snabbdom.svg)](https://badge.fury.io/js/snabbdom)\n[![npm downloads](https://img.shields.io/npm/dm/snabbdom.svg)](https://www.npmjs.com/package/snabbdom)\n[![Join the chat at https://gitter.im/snabbdom/snabbdom](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/snabbdom/snabbdom?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![Donate to our collective](https://opencollective.com/snabbdom/donate/button@2x.png?color=blue)](https://opencollective.com/snabbdom#section-contribute)\n\nThanks to [Browserstack](https://www.browserstack.com/) for providing access to\ntheir great cross-browser testing tools.\n\n---\n\nEnglish | [\u7b80\u4f53\u4e2d\u6587](./README-zh_CN.md) | [Hindi](./README-in_HN.md)\n\n## Introduction\n\nVirtual DOM is awesome. It allows us to express our application's view\nas a function of its state. But existing solutions were way too\nbloated, too slow, lacked features, had an API biased towards OOP\n, and/or lacked features I needed.\n\nSnabbdom consists of an extremely simple, performant, and extensible\ncore that is only \u2248 200 SLOC. It offers a modular architecture with\nrich functionality for extensions through custom modules. To keep the\ncore simple, all non-essential functionality is delegated to modules.\n\nYou can mold Snabbdom into whatever you desire! Pick, choose, and\ncustomize the functionality you want. Alternatively you can just use\nthe default extensions and get a virtual DOM library with high\nperformance, small size, and all the features listed below.\n\n## Features\n\n- Core features\n  - About 200 SLOC \u2013 you could easily read through the entire core and fully\n    understand how it works.\n  - Extendable through modules.\n  - A rich set of hooks available, both per vnode and globally for modules,\n    to hook into any part of the diff and patch process.\n  - Splendid performance. Snabbdom is among the fastest virtual DOM libraries.\n  - Patch function with a function signature equivalent to a reduce/scan\n    function. Allows for easier integration with a FRP library.\n- Features in modules\n  - `h` function for easily creating virtual DOM nodes.\n  - [SVG _just works_ with the `h` helper](#svg).\n  - Features for doing complex CSS animations.\n  - Powerful event listener functionality.\n  - [Thunks](#thunks) to optimize the diff and patch process even further.\n  - [JSX support, including TypeScript types](#jsx)\n- Third party features\n  - Server-side HTML output provided by [snabbdom-to-html](https://github.com/acstll/snabbdom-to-html).\n  - Compact virtual DOM creation with [snabbdom-helpers](https://github.com/krainboltgreene/snabbdom-helpers).\n  - Template string support using [snabby](https://github.com/jamen/snabby).\n  - Virtual DOM assertion with [snabbdom-looks-like](https://github.com/jvanbruegge/snabbdom-looks-like)\n\n## Example\n\n```mjs\nimport {\n  init,\n  classModule,\n  propsModule,\n  styleModule,\n  eventListenersModule,\n  h\n} from \"snabbdom\";\n\nconst patch = init([\n  // Init patch function with chosen modules\n  classModule, // makes it easy to toggle classes\n  propsModule, // for setting properties on DOM elements\n  styleModule, // handles styling on elements with support for animations\n  eventListenersModule // attaches event listeners\n]);\n\nconst container = document.getElementById(\"container\");\n\nconst vnode = h(\n  \"div#container.two.classes\",\n  { on: { click: () => console.log(\"div clicked\") } },\n  [\n    h(\"span\", { style: { fontWeight: \"bold\" } }, \"This is bold\"),\n    \" and this is just normal text\",\n    h(\"a\", { props: { href: \"/foo\" } }, \"I'll take you places!\")\n  ]\n);\n// Patch into empty DOM element \u2013 this modifies the DOM as a side effect\npatch(container, vnode);\n\nconst newVnode = h(\n  \"div#container.two.classes\",\n  { on: { click: () => console.log(\"updated div clicked\") } },\n  [\n    h(\n      \"span\",\n      { style: { fontWeight: \"normal\", fontStyle: \"italic\" } },\n      \"This is now italic type\"\n    ),\n    \" and this is still just normal text\",\n    h(\"a\", { props: { href: \"/bar\" } }, \"I'll take you places!\")\n  ]\n);\n// Second `patch` invocation\npatch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state\n```\n\n## More examples\n\n- [Animated reordering of elements](http://snabbdom.github.io/snabbdom/examples/reorder-animation/)\n- [Hero transitions](http://snabbdom.github.io/snabbdom/examples/hero/)\n- [SVG Carousel](http://snabbdom.github.io/snabbdom/examples/carousel-svg/)\n\n---\n\n## Table of contents\n\n- [Core documentation](#core-documentation)\n  - [`init`](#init)\n  - [`patch`](#patch)\n    - [Unmounting](#unmounting)\n  - [`h`](#h)\n  - [`fragment`](#fragment-experimental) (experimental)\n  - [`toVNode`](#tovnode)\n  - [Hooks](#hooks)\n    - [Overview](#overview)\n    - [Usage](#usage)\n    - [The `init` hook](#the-init-hook)\n    - [The `insert` hook](#the-insert-hook)\n    - [The `remove` hook](#the-remove-hook)\n    - [The `destroy` hook](#the-destroy-hook)\n  - [Creating modules](#creating-modules)\n- [Modules documentation](#modules-documentation)\n  - [The class module](#the-class-module)\n  - [The props module](#the-props-module)\n  - [The attributes module](#the-attributes-module)\n  - [The dataset module](#the-dataset-module)\n  - [The style module](#the-style-module)\n    - [Custom properties (CSS variables)](#custom-properties-css-variables)\n    - [Delayed properties](#delayed-properties)\n    - [Set properties on `remove`](#set-properties-on-remove)\n    - [Set properties on `destroy`](#set-properties-on-destroy)\n  - [The eventlisteners module](#the-eventlisteners-module)\n- [SVG](#svg)\n  - [Classes in SVG Elements](#classes-in-svg-elements)\n- [Thunks](#thunks)\n- [JSX](#jsx)\n  - [TypeScript](#typescript)\n  - [Babel](#babel)\n- [Virtual Node](#virtual-node)\n  - [sel : String](#sel--string)\n  - [data : Object](#data--object)\n  - [children : Array\\<vnode\\>](#children--arrayvnode)\n  - [text : string](#text--string)\n  - [elm : Element](#elm--element)\n  - [key : string | number](#key--string--number)\n- [Structuring applications](#structuring-applications)\n\n* [Related packages](#related-packages)\n\n- [Common errors](#common-errors)\n- [Opportunity for community feedback](#opportunity-for-community-feedback)\n\n## Core documentation\n\nThe core of Snabbdom provides only the most essential functionality.\nIt is designed to be as simple as possible while still being fast and\nextendable.\n\n### `init`\n\nThe core exposes only one single function `init`. This `init`\ntakes a list of modules and returns a `patch` function that uses the\nspecified set of modules.\n\n```mjs\nimport { classModule, styleModule } from \"snabbdom\";\n\nconst patch = init([classModule, styleModule]);\n```\n\n### `patch`\n\nThe `patch` function returned by `init` takes two arguments. The first\nis a DOM element or a vnode representing the current view. The second\nis a vnode representing the new, updated view.\n\nIf a DOM element with a parent is passed, `newVnode` will be turned\ninto a DOM node, and the passed element will be replaced by the\ncreated DOM node. If an old vnode is passed, Snabbdom will efficiently\nmodify it to match the description in the new vnode.\n\nAny old vnode passed must be the resulting vnode from a previous call\nto `patch`. This is necessary since Snabbdom stores information in the\nvnode. This makes it possible to implement a simpler and more\nperformant architecture. This also avoids the creation of a new old\nvnode tree.\n\n```mjs\npatch(oldVnode, newVnode);\n```\n\n#### Unmounting\n\nWhile there is no API specifically for removing a VNode tree from its mount point element, one way of almost achieving this is providing a comment VNode as the second argument to `patch`, such as:\n\n```mjs\npatch(\n  oldVnode,\n  h(\"!\", {\n    hooks: {\n      post: () => {\n        /* patch complete */\n      }\n    }\n  })\n);\n```\n\nOf course, then there is still a single comment node at the mount point.\n\n### `h`\n\nIt is recommended that you use `h` to create vnodes. It accepts a\n[tag/selector](#sel--string) as a string, an optional data object, and an\noptional string or an array of children.\n\n```mjs\nimport { h } from \"snabbdom\";\n\nconst vnode = h(\"div#container\", { style: { color: \"#000\" } }, [\n  h(\"h1.primary-title\", \"Headline\"),\n  h(\"p\", \"A paragraph\")\n]);\n```\n\n### `fragment` (experimental)\n\nCaution: This feature is currently experimental and must be opted in.\nIts API may be changed without a major version bump.\n\n```mjs\nconst patch = init(modules, undefined, {\n  experimental: {\n    fragments: true\n  }\n});\n```\n\nCreates a virtual node that will be converted to a document fragment containing the given children.\n\n```mjs\nimport { fragment, h } from \"snabbdom\";\n\nconst vnode = fragment([\"I am\", h(\"span\", [\" a\", \" fragment\"])]);\n```\n\n### `toVNode`\n\nConverts a DOM node into a virtual node. Especially good for patching over pre-existing,\nserver-side generated HTML content.\n\n```mjs\nimport {\n  init,\n  styleModule,\n  attributesModule,\n  h,\n  toVNode\n} from \"snabbdom\";\n\nconst patch = init([\n  // Initialize a `patch` function with the modules used by `toVNode`\n  attributesModule // handles attributes from the DOM node\n  datasetModule, // handles `data-*` attributes from the DOM node\n]);\n\nconst newVNode = h(\"div\", { style: { color: \"#000\" } }, [\n  h(\"h1\", \"Headline\"),\n  h(\"p\", \"A paragraph\"),\n  h(\"img\", { attrs: { src: \"sunrise.png\", alt: \"morning sunrise\" } })\n]);\n\npatch(toVNode(document.querySelector(\".container\")), newVNode);\n```\n\n### Hooks\n\nHooks are a way to hook into the lifecycle of DOM nodes. Snabbdom\noffers a rich selection of hooks. Hooks are used both by modules to\nextend Snabbdom, and in normal code for executing arbitrary code at\ndesired points in the life of a virtual node.\n\n#### Overview\n\n| Name        | Triggered when                                     | Arguments to callback   |\n| ----------- | -------------------------------------------------- | ----------------------- |\n| `pre`       | the patch process begins                           | none                    |\n| `init`      | a vnode has been added                             | `vnode`                 |\n| `create`    | a DOM element has been created based on a vnode    | `emptyVnode, vnode`     |\n| `insert`    | an element has been inserted into the DOM          | `vnode`                 |\n| `prepatch`  | an element is about to be patched                  | `oldVnode, vnode`       |\n| `update`    | an element is being updated                        | `oldVnode, vnode`       |\n| `postpatch` | an element has been patched                        | `oldVnode, vnode`       |\n| `destroy`   | an element is directly or indirectly being removed | `vnode`                 |\n| `remove`    | an element is directly being removed from the DOM  | `vnode, removeCallback` |\n| `post`      | the patch process is done                          | none                    |\n\nThe following hooks are available for modules: `pre`, `create`,\n`update`, `destroy`, `remove`, `post`.\n\nThe following hooks are available in the `hook` property of individual\nelements: `init`, `create`, `insert`, `prepatch`, `update`,\n`postpatch`, `destroy`, `remove`.\n\n#### Usage\n\nTo use hooks, pass them as an object to `hook` field of the data\nobject argument.\n\n```mjs\nh(\"div.row\", {\n  key: movie.rank,\n  hook: {\n    insert: (vnode) => {\n      movie.elmHeight = vnode.elm.offsetHeight;\n    }\n  }\n});\n```\n\n#### The `init` hook\n\nThis hook is invoked during the patch process when a new virtual node\nhas been found. The hook is called before Snabbdom has processed the\nnode in any way. I.e., before it has created a DOM node based on the\nvnode.\n\n#### The `insert` hook\n\nThis hook is invoked once the DOM element for a vnode has been\ninserted into the document _and_ the rest of the patch cycle is done.\nThis means that you can do DOM measurements (like using\n[getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)\nin this hook safely, knowing that no elements will be changed\nafterwards that could affect the position of the inserted elements.\n\n#### The `remove` hook\n\nAllows you to hook into the removal of an element. The hook is called\nonce a vnode is to be removed from the DOM. The handling function\nreceives both the vnode and a callback. You can control and delay the\nremoval with the callback. The callback should be invoked once the\nhook is done doing its business, and the element will only be removed\nonce all `remove` hooks have invoked their callback.\n\nThe hook is only triggered when an element is to be removed from its\nparent \u2013 not if it is the child of an element that is removed. For\nthat, see the `destroy` hook.\n\n#### The `destroy` hook\n\nThis hook is invoked on a virtual node when its DOM element is removed\nfrom the DOM or if its parent is being removed from the DOM.\n\nTo see the difference between this hook and the `remove` hook,\nconsider an example.\n\n```mjs\nconst vnode1 = h(\"div\", [h(\"div\", [h(\"span\", \"Hello\")])]);\nconst vnode2 = h(\"div\", []);\npatch(container, vnode1);\npatch(vnode1, vnode2);\n```\n\nHere `destroy` is triggered for both the inner `div` element _and_ the\n`span` element it contains. `remove`, on the other hand, is only\ntriggered on the `div` element because it is the only element being\ndetached from its parent.\n\nYou can, for instance, use `remove` to trigger an animation when an\nelement is being removed and use the `destroy` hook to additionally\nanimate the disappearance of the removed element's children.\n\n### Creating modules\n\nModules work by registering global listeners for [hooks](#hooks). A module is simply a dictionary mapping hook names to functions.\n\n```mjs\nconst myModule = {\n  create: (oldVnode, vnode) => {\n    // invoked whenever a new virtual node is created\n  },\n  update: (oldVnode, vnode) => {\n    // invoked whenever a virtual node is updated\n  }\n};\n```\n\nWith this mechanism you can easily augment the behaviour of Snabbdom.\nFor demonstration, take a look at the implementations of the default\nmodules.\n\n## Modules documentation\n\nThis describes the core modules. All modules are optional. JSX examples assume you're using the [`jsx` pragma](#jsx) provided by this library.\n\n### The class module\n\nThe class module provides an easy way to dynamically toggle classes on\nelements. It expects an object in the `class` data property. The\nobject should map class names to booleans that indicate whether or\nnot the class should stay or go on the vnode.\n\n```mjs\nh(\"a\", { class: { active: true, selected: false } }, \"Toggle\");\n```\n\nIn JSX, you can use `class` like this:\n\n```jsx\n<div class={{ foo: true, bar: true }} />\n// Renders as: <div class=\"foo bar\"></div>\n```\n\n### The props module\n\nAllows you to set properties on DOM elements.\n\n```mjs\nh(\"a\", { props: { href: \"/foo\" } }, \"Go to Foo\");\n```\n\nIn JSX, you can use `props` like this:\n\n```jsx\n<input props={{ name: \"foo\" }} />\n// Renders as: <input name=\"foo\" /> with input.name === \"foo\"\n```\n\nProperties can only be set. Not removed. Even though browsers allow addition and\ndeletion of custom properties, deletion will not be attempted by this module.\nThis makes sense, because native DOM properties cannot be removed. And\nif you are using custom properties for storing values or referencing\nobjects on the DOM, then please consider using\n[data-\\* attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)\ninstead. Perhaps via [the dataset module](#the-dataset-module).\n\n### The attributes module\n\nSame as props, but set attributes instead of properties on DOM elements.\n\n```mjs\nh(\"a\", { attrs: { href: \"/foo\" } }, \"Go to Foo\");\n```\n\nIn JSX, you can use `attrs` like this:\n\n```jsx\n<div attrs={{ \"aria-label\": \"I'm a div\" }} />\n// Renders as: <div aria-label=\"I'm a div\"></div>\n```\n\nAttributes are added and updated using `setAttribute`. In case of an\nattribute that had been previously added/set and is no longer present\nin the `attrs` object, it is removed from the DOM element's attribute\nlist using `removeAttribute`.\n\nIn the case of boolean attributes (e.g. `disabled`, `hidden`,\n`selected` ...), the meaning doesn't depend on the attribute value\n(`true` or `false`) but depends instead on the presence/absence of the\nattribute itself in the DOM element. Those attributes are handled\ndifferently by the module: if a boolean attribute is set to a\n[falsy value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)\n(`0`, `-0`, `null`, `false`,`NaN`, `undefined`, or the empty string\n(`\"\"`)), then the attribute will be removed from the attribute list of\nthe DOM element.\n\n### The dataset module\n\nAllows you to set custom data attributes (`data-*`) on DOM elements. These can then be accessed with the [HTMLElement.dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) property.\n\n```mjs\nh(\"button\", { dataset: { action: \"reset\" } }, \"Reset\");\n```\n\nIn JSX, you can use `dataset` like this:\n\n```jsx\n<div dataset={{ foo: \"bar\" }} />\n// Renders as: <div data-foo=\"bar\"></div>\n```\n\n### The style module\n\nThe style module is for making your HTML look slick and animate smoothly. At\nits core it allows you to set CSS properties on elements.\n\n```mjs\nh(\n  \"span\",\n  {\n    style: {\n      border: \"1px solid #bada55\",\n      color: \"#c0ffee\",\n      fontWeight: \"bold\"\n    }\n  },\n  \"Say my name, and every colour illuminates\"\n);\n```\n\nIn JSX, you can use `style` like this:\n\n```jsx\n<div\n  style={{\n    border: \"1px solid #bada55\",\n    color: \"#c0ffee\",\n    fontWeight: \"bold\"\n  }}\n/>\n// Renders as: <div style=\"border: 1px solid #bada55; color: #c0ffee; font-weight: bold\"></div>\n```\n\n#### Custom properties (CSS variables)\n\nCSS custom properties (aka CSS variables) are supported, they must be prefixed\nwith `--`\n\n```mjs\nh(\n  \"div\",\n  {\n    style: { \"--warnColor\": \"yellow\" }\n  },\n  \"Warning\"\n);\n```\n\n#### Delayed properties\n\nYou can specify properties as being delayed. Whenever these properties\nchange, the change is not applied until after the next frame.\n\n```mjs\nh(\n  \"span\",\n  {\n    style: {\n      opacity: \"0\",\n      transition: \"opacity 1s\",\n      delayed: { opacity: \"1\" }\n    }\n  },\n  \"Imma fade right in!\"\n);\n```\n\nThis makes it easy to declaratively animate the entry of elements.\n\nThe `all` value of `transition-property` is not supported.\n\n#### Set properties on `remove`\n\nStyles set in the `remove` property will take effect once the element\nis about to be removed from the DOM. The applied styles should be\nanimated with CSS transitions. Only once all the styles are done\nanimating will the element be removed from the DOM.\n\n```mjs\nh(\n  \"span\",\n  {\n    style: {\n      opacity: \"1\",\n      transition: \"opacity 1s\",\n      remove: { opacity: \"0\" }\n    }\n  },\n  \"It's better to fade out than to burn away\"\n);\n```\n\nThis makes it easy to declaratively animate the removal of elements.\n\nThe `all` value of `transition-property` is not supported.\n\n#### Set properties on `destroy`\n\n```mjs\nh(\n  \"span\",\n  {\n    style: {\n      opacity: \"1\",\n      transition: \"opacity 1s\",\n      destroy: { opacity: \"0\" }\n    }\n  },\n  \"It's better to fade out than to burn away\"\n);\n```\n\nThe `all` value of `transition-property` is not supported.\n\n### The eventlisteners module\n\nThe event listeners module gives powerful capabilities for attaching\nevent listeners.\n\nYou can attach a function to an event on a vnode by supplying an\nobject at `on` with a property corresponding to the name of the event\nyou want to listen to. The function will be called when the event\nhappens and will be passed to the event object that belongs to it.\n\n```mjs\nfunction clickHandler(ev) {\n  console.log(\"got clicked\");\n}\nh(\"div\", { on: { click: clickHandler } });\n```\n\nIn JSX, you can use `on` like this:\n\n```js\n<div on={{ click: clickHandler }} />\n```\n\nSnabbdom allows swapping event handlers between renders. This happens without\nactually touching the event handlers attached to the DOM.\n\nNote, however, that **you should be careful when sharing event\nhandlers between vnodes**, because of the technique this module uses\nto avoid re-binding event handlers to the DOM. (And in general,\nsharing data between vnodes is not guaranteed to work, because modules\nare allowed to mutate the given data).\n\nIn particular, you should **not** do something like this:\n\n```mjs\n// Does not work\nconst sharedHandler = {\n  change: (e) => {\n    console.log(\"you chose: \" + e.target.value);\n  }\n};\nh(\"div\", [\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"0\" },\n    on: sharedHandler\n  }),\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"1\" },\n    on: sharedHandler\n  }),\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"2\" },\n    on: sharedHandler\n  })\n]);\n```\n\nFor many such cases, you can use array-based handlers instead (described above).\nAlternatively, simply make sure each node is passed unique `on` values:\n\n```mjs\n// Works\nconst sharedHandler = (e) => {\n  console.log(\"you chose: \" + e.target.value);\n};\nh(\"div\", [\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"0\" },\n    on: { change: sharedHandler }\n  }),\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"1\" },\n    on: { change: sharedHandler }\n  }),\n  h(\"input\", {\n    props: { type: \"radio\", name: \"test\", value: \"2\" },\n    on: { change: sharedHandler }\n  })\n]);\n```\n\n## SVG\n\nSVG just works when using the `h` function for creating virtual\nnodes. SVG elements are automatically created with the appropriate\nnamespaces.\n\n```mjs\nconst vnode = h(\"div\", [\n  h(\"svg\", { attrs: { width: 100, height: 100 } }, [\n    h(\"circle\", {\n      attrs: {\n        cx: 50,\n        cy: 50,\n        r: 40,\n        stroke: \"green\",\n        \"stroke-width\": 4,\n        fill: \"yellow\"\n      }\n    })\n  ])\n]);\n```\n\nSee also the [SVG example](./examples/svg) and the [SVG Carousel example](./examples/carousel-svg/).\n\n### Classes in SVG Elements\n\nCertain browsers (like IE &lt;=11) [do not support `classList` property in SVG elements](http://caniuse.com/#feat=classlist).\nBecause the _class_ module internally uses `classList`, it will not work in this case unless you use a [classList polyfill](https://www.npmjs.com/package/classlist-polyfill).\n(If you don't want to use a polyfill, you can use the `class` attribute with the _attributes_ module).\n\n## Thunks\n\nThe `thunk` function takes a selector, a key for identifying a thunk,\na function that returns a vnode and a variable amount of state\nparameters. If invoked, the render function will receive the state\narguments.\n\n`thunk(selector, key, renderFn, [stateArguments])`\n\nThe `renderFn` is invoked only if the `renderFn` is changed or `[stateArguments]` array length or its elements are changed.\n\nThe `key` is optional. It should be supplied when the `selector` is\nnot unique among the thunks siblings. This ensures that the thunk is\nalways matched correctly when diffing.\n\nThunks are an optimization strategy that can be used when one is\ndealing with immutable data.\n\nConsider a simple function for creating a virtual node based on a number.\n\n```mjs\nfunction numberView(n) {\n  return h(\"div\", \"Number is: \" + n);\n}\n```\n\nThe view depends only on `n`. This means that if `n` is unchanged,\nthen creating the virtual DOM node and patching it against the old\nvnode is wasteful. To avoid the overhead we can use the `thunk` helper\nfunction.\n\n```mjs\nfunction render(state) {\n  return thunk(\"num\", numberView, [state.number]);\n}\n```\n\nInstead of actually invoking the `numberView` function this will only\nplace a dummy vnode in the virtual tree. When Snabbdom patches this\ndummy vnode against a previous vnode, it will compare the value of\n`n`. If `n` is unchanged it will simply reuse the old vnode. This\navoids recreating the number view and the diff process altogether.\n\nThe view function here is only an example. In practice thunks are only\nrelevant if you are rendering a complicated view that takes\nsignificant computational time to generate.\n\n## JSX\n\nNote that JSX fragments are still experimental and must be opted in.\nSee [`fragment`](#fragment-experimental) section for details.\n\n### TypeScript\n\nAdd the following options to your `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"jsx\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n```\n\nThen make sure that you use the `.tsx` file extension and import the `jsx` function and the `Fragment` function at the top of the file:\n\n```tsx\nimport { Fragment, jsx, VNode } from \"snabbdom\";\n\nconst node: VNode = (\n  <div>\n    <span>I was created with JSX</span>\n  </div>\n);\n\nconst fragment: VNode = (\n  <>\n    <span>JSX fragments</span>\n    are experimentally supported\n  </>\n);\n```\n\n### Babel\n\nAdd the following options to your babel configuration:\n\n```json\n{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-react-jsx\",\n      {\n        \"pragma\": \"jsx\",\n        \"pragmaFrag\": \"Fragment\"\n      }\n    ]\n  ]\n}\n```\n\nThen import the `jsx` function and the `Fragment` function at the top of the file:\n\n```jsx\nimport { Fragment, jsx } from \"snabbdom\";\n\nconst node = (\n  <div>\n    <span>I was created with JSX</span>\n  </div>\n);\n\nconst fragment = (\n  <>\n    <span>JSX fragments</span>\n    are experimentally supported\n  </>\n);\n```\n\n## Virtual Node\n\n**Properties**\n\n- [sel](#sel--string)\n- [data](#data--object)\n- [children](#children--array)\n- [text](#text--string)\n- [elm](#elm--element)\n- [key](#key--string--number)\n\n### sel : string\n\nThe `sel` property specifies the HTML element of the vnode, optionally its `id`\nprefixed by a `#`, and zero or more classes each prefixed by a `.`. The syntax\nis inspired by CSS selectors. Here are a few examples:\n\n- `div#container.bar.baz` \u2013 A `div` element with the id `container` and the\n  classes `bar` and `baz`.\n- `li` \u2013 A `li` element with no `id` nor classes.\n- `button.alert.primary` \u2013 `button` element with the two classes `alert` and\n  `primary`.\n\nThe selector is meant to be _static_, that is, it should not change over the\nlifetime of the element. To set a dynamic `id` use [the props\nmodule](#the-props-module) and to set dynamic classes use [the class\nmodule](#the-class-module).\n\nSince the selector is static, Snabbdom uses it as part of a vnodes identity. For\ninstance, if the two child vnodes\n\n```mjs\n[h(\"div#container.padding\", children1), h(\"div.padding\", children2)];\n```\n\nare patched against\n\n```ts\n[h(\"div#container.padding\", children2), h(\"div.padding\", children1)];\n```\n\nthen Snabbdom uses the selector to identify the vnodes and reorder them in the\nDOM tree instead of creating new DOM element. This use of selectors avoids the\nneed to specify keys in many cases.\n\n### data : Object\n\nThe `.data` property of a virtual node is the place to add information\nfor [modules](#modules-documentation) to access and manipulate the\nreal DOM element when it is created; Add styles, CSS classes,\nattributes, etc.\n\nThe data object is the (optional) second parameter to [`h()`](#snabbdomh)\n\nFor example `h('div', {props: {className: 'container'}}, [...])` will produce a virtual node with\n\n```mjs\n({\n  props: {\n    className: \"container\"\n  }\n});\n```\n\nas its `.data` object.\n\n### children : Array\\<vnode\\>\n\nThe `.children` property of a virtual node is the third (optional)\nparameter to [`h()`](#snabbdomh) during creation. `.children` is\nsimply an Array of virtual nodes that should be added as children of\nthe parent DOM node upon creation.\n\nFor example `h('div', {}, [ h('h1', {}, 'Hello, World') ])` will\ncreate a virtual node with\n\n```mjs\n[\n  {\n    sel: \"h1\",\n    data: {},\n    children: undefined,\n    text: \"Hello, World\",\n    elm: Element,\n    key: undefined\n  }\n];\n```\n\nas its `.children` property.\n\n### text : string\n\nThe `.text` property is created when a virtual node is created with\nonly a single child that possesses text and only requires\n`document.createTextNode()` to be used.\n\nFor example: `h('h1', {}, 'Hello')` will create a virtual node with\n`Hello` as its `.text` property.\n\n### elm : Element\n\nThe `.elm` property of a virtual node is a pointer to the real DOM\nnode created by snabbdom. This property is very useful to do\ncalculations in [hooks](#hooks) as well as\n[modules](#modules-documentation).\n\n### key : string | number\n\nThe `.key` property is created when a key is provided inside of your\n[`.data`](#data--object) object. The `.key` property is used to keep\npointers to DOM nodes that existed previously to avoid recreating them\nif it is unnecessary. This is very useful for things like list\nreordering. A key must be either a string or a number to allow for\nproper lookup as it is stored internally as a key/value pair inside of\nan object, where `.key` is the key and the value is the\n[`.elm`](#elm--element) property created.\n\nIf provided, the `.key` property must be unique among sibling elements.\n\nFor example: `h('div', {key: 1}, [])` will create a virtual node\nobject with a `.key` property with the value of `1`.\n\n## Structuring applications\n\nSnabbdom is a low-level virtual DOM library. It is unopinionated with\nregards to how you should structure your application.\n\nHere are some approaches to building applications with Snabbdom.\n\n- [functional-frontend-architecture](https://github.com/paldepind/functional-frontend-architecture) \u2013\n  a repository containing several example applications that\n  demonstrate an architecture that uses Snabbdom.\n- [Cycle.js](https://cycle.js.org/) \u2013\n  \"A functional and reactive JavaScript framework for cleaner code\"\n  uses Snabbdom\n- [Vue.js](http://vuejs.org/) use a fork of snabbdom.\n- [scheme-todomvc](https://github.com/amirouche/scheme-todomvc/) build\n  redux-like architecture on top of snabbdom bindings.\n- [kaiju](https://github.com/AlexGalays/kaiju) -\n  Stateful components and observables on top of snabbdom\n- [Tweed](https://tweedjs.github.io) \u2013\n  An Object Oriented approach to reactive interfaces.\n- [Cyclow](http://cyclow.js.org) -\n  \"A reactive frontend framework for JavaScript\"\n  uses Snabbdom\n- [Tung](https://github.com/Reon90/tung) \u2013\n  A JavaScript library for rendering HTML. Tung helps to divide HTML and JavaScript development.\n- [sprotty](https://github.com/theia-ide/sprotty) - \"A web-based diagramming framework\" uses Snabbdom.\n- [Mark Text](https://github.com/marktext/marktext) - \"Realtime preview Markdown Editor\" build on Snabbdom.\n- [puddles](https://github.com/flintinatux/puddles) -\n  \"Tiny vdom app framework. Pure Redux. No boilerplate.\" - Built with :heart: on Snabbdom.\n- [Backbone.VDOMView](https://github.com/jcbrand/backbone.vdomview) - A [Backbone](http://backbonejs.org/) View with VirtualDOM capability via Snabbdom.\n- [Rosmaro Snabbdom starter](https://github.com/lukaszmakuch/rosmaro-snabbdom-starter) - Building user interfaces with state machines and Snabbdom.\n- [Pureact](https://github.com/irony/pureact) - \"65 lines implementation of React incl Redux and hooks with only one dependency - Snabbdom\"\n- [Snabberb](https://github.com/tobymao/snabberb) - A minimalistic Ruby framework using [Opal](https://github.com/opal/opal) and Snabbdom for building reactive views.\n- [WebCell](https://github.com/EasyWebApp/WebCell) - Web Components engine based on JSX & TypeScript\n\nBe sure to share it if you're building an application in another way\nusing Snabbdom.\n\n## Related packages\n\nPackages related to snabbdom should be tagged with the `snabbdom` keyword and published on npm.\nThey can be found [using the query string `keywords:snabbdom`](https://www.npmjs.com/search?q=keywords:snabbdom).\n\n## Common errors\n\n```text\nUncaught NotFoundError: Failed to execute 'insertBefore' on 'Node':\n    The node before which the new node is to be inserted is not a child of this node.\n```\n\nThe reason for this error is the reusing of vnodes between patches (see code example), snabbdom stores actual dom nodes inside the virtual dom nodes passed to it as performance improvement, so reusing nodes between patches is not supported.\n\n```mjs\nconst sharedNode = h(\"div\", {}, \"Selected\");\nconst vnode1 = h(\"div\", [\n  h(\"div\", {}, [\"One\"]),\n  h(\"div\", {}, [\"Two\"]),\n  h(\"div\", {}, [sharedNode])\n]);\nconst vnode2 = h(\"div\", [\n  h(\"div\", {}, [\"One\"]),\n  h(\"div\", {}, [sharedNode]),\n  h(\"div\", {}, [\"Three\"])\n]);\npatch(container, vnode1);\npatch(vnode1, vnode2);\n```\n\nYou can fix this issue by creating a shallow copy of the object (here with object spread syntax):\n\n```mjs\nconst vnode2 = h(\"div\", [\n  h(\"div\", {}, [\"One\"]),\n  h(\"div\", {}, [{ ...sharedNode }]),\n  h(\"div\", {}, [\"Three\"])\n]);\n```\n\nAnother solution would be to wrap shared vnodes in a factory function:\n\n```mjs\nconst sharedNode = () => h(\"div\", {}, \"Selected\");\nconst vnode1 = h(\"div\", [\n  h(\"div\", {}, [\"One\"]),\n  h(\"div\", {}, [\"Two\"]),\n  h(\"div\", {}, [sharedNode()])\n]);\n```\n\n## Opportunity for community feedback\n\nPull requests that the community may care to provide feedback on should be\nmerged after such an opportunity of a few days was provided.\n",
        "releases": [
            {
                "name": "Release 3.6.2",
                "date": "2024-01-31T09:10:47Z"
            },
            {
                "name": "Release 3.6.1",
                "date": "2024-01-30T09:33:52Z"
            },
            {
                "name": "Release 3.6.0",
                "date": "2024-01-20T08:02:08Z"
            },
            {
                "name": "Release 3.5.1",
                "date": "2022-06-22T09:14:52Z"
            },
            {
                "name": "Release 3.5.0",
                "date": "2022-04-26T20:10:13Z"
            },
            {
                "name": "Release 3.4.0",
                "date": "2022-03-20T18:42:52Z"
            },
            {
                "name": "Release 3.3.1",
                "date": "2022-01-18T09:22:51Z"
            },
            {
                "name": "Release 3.3.0",
                "date": "2022-01-17T19:17:01Z"
            },
            {
                "name": "Release 3.2.0",
                "date": "2021-12-13T21:47:19Z"
            },
            {
                "name": "Release 3.1.0",
                "date": "2021-09-03T13:35:49Z"
            },
            {
                "name": "Release 3.0.3",
                "date": "2021-06-04T15:45:15Z"
            },
            {
                "name": "Release 3.0.2",
                "date": "2021-06-01T13:16:05Z"
            },
            {
                "name": "Release 3.0.1",
                "date": "2021-03-28T23:53:51Z"
            },
            {
                "name": "Release 3.0.0",
                "date": "2021-03-28T18:58:58Z"
            }
        ]
    }
}
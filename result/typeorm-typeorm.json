{
    "https://api.github.com/repos/typeorm/typeorm": {
        "forks": 6374,
        "watchers": 34764,
        "stars": 34764,
        "languages": {
            "TypeScript": 9160220,
            "JavaScript": 17610,
            "Dockerfile": 187
        },
        "commits": [
            "2025-01-21T21:46:54Z",
            "2025-01-21T07:25:50Z",
            "2025-01-20T21:03:13Z",
            "2025-01-20T20:42:08Z",
            "2025-01-20T20:20:49Z",
            "2025-01-20T20:19:34Z",
            "2025-01-20T20:11:52Z",
            "2025-01-20T20:04:21Z",
            "2025-01-19T16:57:45Z",
            "2025-01-09T10:03:32Z",
            "2025-01-05T21:16:25Z",
            "2025-01-05T21:12:27Z",
            "2025-01-05T21:09:07Z",
            "2025-01-05T21:07:18Z",
            "2025-01-05T20:58:00Z",
            "2025-01-05T20:57:02Z",
            "2025-01-05T20:53:05Z",
            "2025-01-05T20:46:31Z",
            "2025-01-05T20:45:28Z",
            "2025-01-05T20:44:10Z",
            "2025-01-05T20:42:55Z",
            "2025-01-05T20:37:53Z",
            "2025-01-05T20:36:37Z",
            "2025-01-05T20:34:40Z",
            "2025-01-05T20:28:26Z",
            "2025-01-05T20:26:05Z",
            "2025-01-05T20:24:10Z",
            "2025-01-05T20:13:03Z",
            "2025-01-05T20:03:01Z",
            "2024-12-30T08:33:51Z"
        ],
        "creation_date": "2016-02-29T07:41:14Z",
        "contributors": 30,
        "topics": [
            "active-record",
            "cockroachdb",
            "data-mapper",
            "database",
            "electron",
            "hacktoberfest",
            "javascript",
            "mariadb",
            "mysql",
            "oracle",
            "orm",
            "postgresql",
            "react-native",
            "sap",
            "sap-hana",
            "sqlite",
            "sqlserver",
            "typeorm",
            "typescript",
            "websql"
        ],
        "subscribers": 353,
        "readme": "<div align=\"center\">\n  <a href=\"http://typeorm.io/\">\n    <img src=\"https://github.com/typeorm/typeorm/raw/master/resources/logo_big.png\" width=\"492\" height=\"228\">\n  </a>\n  <br>\n  <br>\n\t<a href=\"https://github.com/typeorm/typeorm/actions/workflows/test.yml\">\n\t\t<img src=\"https://github.com/typeorm/typeorm/actions/workflows/test.yml/badge.svg?branch=master\">\n\t</a>\n\t<a href=\"https://badge.fury.io/js/typeorm\">\n\t\t<img src=\"https://badge.fury.io/js/typeorm.svg\">\n\t</a>\n    <a href='https://coveralls.io/github/typeorm/typeorm?branch=master'>\n        <img src='https://coveralls.io/repos/github/typeorm/typeorm/badge.svg?branch=master' alt='Coverage Status' />\n    </a>\n  <br>\n  <br>\n</div>\n\nTypeORM is an [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping)\nthat can run in NodeJS, Browser, Cordova, PhoneGap, Ionic, React Native, NativeScript, Expo, and Electron platforms\nand can be used with TypeScript and JavaScript (ES2021).\nIts goal is to always support the latest JavaScript features and provide additional features\nthat help you to develop any kind of application that uses databases - from\nsmall applications with a few tables to large-scale enterprise applications\nwith multiple databases.\n\nTypeORM supports both [Active Record](./docs/active-record-data-mapper.md#what-is-the-active-record-pattern) and [Data Mapper](./docs/active-record-data-mapper.md#what-is-the-data-mapper-pattern) patterns,\nunlike all other JavaScript ORMs currently in existence,\nwhich means you can write high-quality, loosely coupled, scalable,\nmaintainable applications in the most productive way.\n\nTypeORM is highly influenced by other ORMs, such as [Hibernate](http://hibernate.org/orm/),\n[Doctrine](http://www.doctrine-project.org/) and [Entity Framework](https://www.asp.net/entity-framework).\n\n> **\ud83d\udce3 Announcement: The Future of TypeORM**\n>\n> We\u2019re excited to share our vision for a revitalized TypeORM\u2014a strategy focused on building a stable, robust, and sustainable foundation for the long term. Learn how we\u2019re structuring maintenance\n> and bringing together dedicated resources to ensure TypeORM thrives for years to come.\n>\n> [Read the full announcement](./docs/future-of-typeorm.md)\n\n## Features\n\n-   Supports both [DataMapper](./docs/active-record-data-mapper.md#what-is-the-data-mapper-pattern) and [ActiveRecord](./docs/active-record-data-mapper.md#what-is-the-active-record-pattern) (your choice).\n-   Entities and columns.\n-   Database-specific column types.\n-   Entity manager.\n-   Repositories and custom repositories.\n-   Clean object-relational model.\n-   Associations (relations).\n-   Eager and lazy relations.\n-   Uni-directional, bi-directional, and self-referenced relations.\n-   Supports multiple inheritance patterns.\n-   Cascades.\n-   Indices.\n-   Transactions.\n-   Migrations and automatic migrations generation.\n-   Connection pooling.\n-   Replication.\n-   Using multiple database instances.\n-   Working with multiple database types.\n-   Cross-database and cross-schema queries.\n-   Elegant-syntax, flexible and powerful QueryBuilder.\n-   Left and inner joins.\n-   Proper pagination for queries using joins.\n-   Query caching.\n-   Streaming raw results.\n-   Logging.\n-   Listeners and subscribers (hooks).\n-   Supports closure table pattern.\n-   Schema declaration in models or separate configuration files.\n-   Supports MySQL / MariaDB / Postgres / CockroachDB / SQLite / Microsoft SQL Server / Oracle / SAP Hana / sql.js.\n-   Supports MongoDB NoSQL database.\n-   Works in NodeJS / Browser / Ionic / Cordova / React Native / NativeScript / Expo / Electron platforms.\n-   TypeScript and JavaScript support.\n-   ESM and CommonJS support.\n-   Produced code is performant, flexible, clean, and maintainable.\n-   Follows all possible best practices.\n-   CLI.\n\nAnd more...\n\nWith TypeORM your models look like this:\n\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column } from \"typeorm\"\n\n@Entity()\nexport class User {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    firstName: string\n\n    @Column()\n    lastName: string\n\n    @Column()\n    age: number\n}\n```\n\nAnd your domain logic looks like this:\n\n```typescript\nconst userRepository = MyDataSource.getRepository(User)\n\nconst user = new User()\nuser.firstName = \"Timber\"\nuser.lastName = \"Saw\"\nuser.age = 25\nawait userRepository.save(user)\n\nconst allUsers = await userRepository.find()\nconst firstUser = await userRepository.findOneBy({\n    id: 1,\n}) // find by id\nconst timber = await userRepository.findOneBy({\n    firstName: \"Timber\",\n    lastName: \"Saw\",\n}) // find by firstName and lastName\n\nawait userRepository.remove(timber)\n```\n\nAlternatively, if you prefer to use the `ActiveRecord` implementation, you can use it as well:\n\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, BaseEntity } from \"typeorm\"\n\n@Entity()\nexport class User extends BaseEntity {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    firstName: string\n\n    @Column()\n    lastName: string\n\n    @Column()\n    age: number\n}\n```\n\nAnd your domain logic will look this way:\n\n```typescript\nconst user = new User()\nuser.firstName = \"Timber\"\nuser.lastName = \"Saw\"\nuser.age = 25\nawait user.save()\n\nconst allUsers = await User.find()\nconst firstUser = await User.findOneBy({\n    id: 1,\n})\nconst timber = await User.findOneBy({\n    firstName: \"Timber\",\n    lastName: \"Saw\"\n})\n\nawait timber.remove()\n```\n\n## Installation\n\n1. Install the npm package:\n\n    `npm install typeorm --save`\n\n2. You need to install `reflect-metadata` shim:\n\n    `npm install reflect-metadata --save`\n\n    and import it somewhere in the global place of your app (for example in `app.ts`):\n\n    `import \"reflect-metadata\"`\n\n3. You may need to install node typings:\n\n    `npm install @types/node --save-dev`\n\n4. Install a database driver:\n\n    - for **MySQL** or **MariaDB**\n\n        `npm install mysql --save` (you can install `mysql2` instead as well)\n\n    - for **PostgreSQL** or **CockroachDB**\n\n        `npm install pg --save`\n\n    - for **SQLite**\n\n        `npm install sqlite3 --save`\n\n    - for **Microsoft SQL Server**\n\n        `npm install mssql --save`\n\n    - for **sql.js**\n\n        `npm install sql.js --save`\n\n    - for **Oracle**\n\n        `npm install oracledb --save`\n\n        To make the Oracle driver work, you need to follow the installation instructions from\n        [their](https://github.com/oracle/node-oracledb) site.\n\n    - for **SAP Hana**\n\n        ```\n        npm install @sap/hana-client\n        npm install hdb-pool\n        ```\n\n        _SAP Hana support made possible by the sponsorship of [Neptune Software](https://www.neptune-software.com/)._\n\n    - for **Google Cloud Spanner**\n\n        ```\n        npm install @google-cloud/spanner --save\n        ```\n\n        Provide authentication credentials to your application code\n        by setting the environment variable `GOOGLE_APPLICATION_CREDENTIALS`:\n\n        ```shell\n        # Linux/macOS\n        export GOOGLE_APPLICATION_CREDENTIALS=\"KEY_PATH\"\n\n        # Windows\n        set GOOGLE_APPLICATION_CREDENTIALS=KEY_PATH\n\n        # Replace KEY_PATH with the path of the JSON file that contains your service account key.\n        ```\n\n        To use Spanner with the emulator you should set `SPANNER_EMULATOR_HOST` environment variable:\n\n        ```shell\n        # Linux/macOS\n        export SPANNER_EMULATOR_HOST=localhost:9010\n\n        # Windows\n        set SPANNER_EMULATOR_HOST=localhost:9010\n        ```\n\n    - for **MongoDB** (experimental)\n\n        `npm install mongodb@^5.2.0 --save`\n\n    - for **NativeScript**, **react-native** and **Cordova**\n\n        Check [documentation of supported platforms](./docs/supported-platforms.md)\n\n    Install only _one_ of them, depending on which database you use.\n\n##### TypeScript configuration\n\nAlso, make sure you are using TypeScript version **4.5** or higher,\nand you have enabled the following settings in `tsconfig.json`:\n\n```json\n\"emitDecoratorMetadata\": true,\n\"experimentalDecorators\": true,\n```\n\nYou may also need to enable `es6` in the `lib` section of compiler options, or install `es6-shim` from `@types`.\n\n## Quick Start\n\nThe quickest way to get started with TypeORM is to use its CLI commands to generate a starter project.\nQuick start works only if you are using TypeORM in a NodeJS application.\nIf you are using other platforms, proceed to the [step-by-step guide](#step-by-step-guide).\n\nTo create a new project using CLI, run the following command:\n\n```shell\nnpx typeorm init --name MyProject --database postgres\n```\n\nWhere `name` is the name of your project and `database` is the database you'll use.\nDatabase can be one of the following values: `mysql`, `mariadb`, `postgres`, `cockroachdb`, `sqlite`, `mssql`, `sap`, `spanner`, `oracle`, `mongodb`,\n`cordova`, `react-native`, `expo`, `nativescript`.\n\nThis command will generate a new project in the `MyProject` directory with the following files:\n\n```\nMyProject\n\u251c\u2500\u2500 src                   // place of your TypeScript code\n\u2502   \u251c\u2500\u2500 entity            // place where your entities (database models) are stored\n\u2502   \u2502   \u2514\u2500\u2500 User.ts       // sample entity\n\u2502   \u251c\u2500\u2500 migration         // place where your migrations are stored\n\u2502   \u251c\u2500\u2500 data-source.ts    // data source and all connection configuration\n\u2502   \u2514\u2500\u2500 index.ts          // start point of your application\n\u251c\u2500\u2500 .gitignore            // standard gitignore file\n\u251c\u2500\u2500 package.json          // node module dependencies\n\u251c\u2500\u2500 README.md             // simple readme file\n\u2514\u2500\u2500 tsconfig.json         // TypeScript compiler options\n```\n\n> You can also run `typeorm init` on an existing node project, but be careful - it may override some files you already have.\n\nThe next step is to install new project dependencies:\n\n```shell\ncd MyProject\nnpm install\n```\n\nAfter you have all dependencies installed, edit the `data-source.ts` file and put your own database connection configuration options in there:\n\n```ts\nexport const AppDataSource = new DataSource({\n    type: \"postgres\",\n    host: \"localhost\",\n    port: 5432,\n    username: \"test\",\n    password: \"test\",\n    database: \"test\",\n    synchronize: true,\n    logging: true,\n    entities: [Post, Category],\n    subscribers: [],\n    migrations: [],\n})\n```\n\nParticularly, most of the time you'll only need to configure\n`host`, `username`, `password`, `database` and maybe `port` options.\n\nOnce you finish with configuration and all node modules are installed, you can run your application:\n\n```shell\nnpm start\n```\n\nThat's it, your application should successfully run and insert a new user into the database.\nYou can continue to work with this project and integrate other modules you need and start\ncreating more entities.\n\n> You can generate an ESM project by running\n> `npx typeorm init --name MyProject --database postgres --module esm` command.\n\n> You can generate an even more advanced project with express installed by running\n> `npx typeorm init --name MyProject --database mysql --express` command.\n\n> You can generate a docker-compose file by running\n> `npx typeorm init --name MyProject --database postgres --docker` command.\n\n## Step-by-Step Guide\n\nWhat are you expecting from ORM?\nFirst of all, you are expecting it will create database tables for you\nand find / insert / update / delete your data without the pain of\nhaving to write lots of hardly maintainable SQL queries.\nThis guide will show you how to set up TypeORM from scratch and make it do what you are expecting from an ORM.\n\n### Create a model\n\nWorking with a database starts with creating tables.\nHow do you tell TypeORM to create a database table?\nThe answer is - through the models.\nYour models in your app are your database tables.\n\nFor example, you have a `Photo` model:\n\n```typescript\nexport class Photo {\n    id: number\n    name: string\n    description: string\n    filename: string\n    views: number\n    isPublished: boolean\n}\n```\n\nAnd you want to store photos in your database.\nTo store things in the database, first, you need a database table,\nand database tables are created from your models.\nNot all models, but only those you define as _entities_.\n\n### Create an entity\n\n_Entity_ is your model decorated by an `@Entity` decorator.\nA database table will be created for such models.\nYou work with entities everywhere in TypeORM.\nYou can load/insert/update/remove and perform other operations with them.\n\nLet's make our `Photo` model an entity:\n\n```typescript\nimport { Entity } from \"typeorm\"\n\n@Entity()\nexport class Photo {\n    id: number\n    name: string\n    description: string\n    filename: string\n    views: number\n    isPublished: boolean\n}\n```\n\nNow, a database table will be created for the `Photo` entity and we'll be able to work with it anywhere in our app.\nWe have created a database table, however, what table can exist without columns?\nLet's create a few columns in our database table.\n\n### Adding table columns\n\nTo add database columns, you simply need to decorate an entity's properties you want to make into a column\nwith a `@Column` decorator.\n\n```typescript\nimport { Entity, Column } from \"typeorm\"\n\n@Entity()\nexport class Photo {\n    @Column()\n    id: number\n\n    @Column()\n    name: string\n\n    @Column()\n    description: string\n\n    @Column()\n    filename: string\n\n    @Column()\n    views: number\n\n    @Column()\n    isPublished: boolean\n}\n```\n\nNow `id`, `name`, `description`, `filename`, `views`, and `isPublished` columns will be added to the `photo` table.\nColumn types in the database are inferred from the property types you used, e.g.\n`number` will be converted into `integer`, `string` into `varchar`, `boolean` into `bool`, etc.\nBut you can use any column type your database supports by explicitly specifying a column type into the `@Column` decorator.\n\nWe generated a database table with columns, but there is one thing left.\nEach database table must have a column with a primary key.\n\n### Creating a primary column\n\nEach entity **must** have at least one primary key column.\nThis is a requirement and you can't avoid it.\nTo make a column a primary key, you need to use the `@PrimaryColumn` decorator.\n\n```typescript\nimport { Entity, Column, PrimaryColumn } from \"typeorm\"\n\n@Entity()\nexport class Photo {\n    @PrimaryColumn()\n    id: number\n\n    @Column()\n    name: string\n\n    @Column()\n    description: string\n\n    @Column()\n    filename: string\n\n    @Column()\n    views: number\n\n    @Column()\n    isPublished: boolean\n}\n```\n\n### Creating an auto-generated column\n\nNow, let's say you want your id column to be auto-generated (this is known as auto-increment / sequence / serial / generated identity column).\nTo do that, you need to change the `@PrimaryColumn` decorator to a `@PrimaryGeneratedColumn` decorator:\n\n```typescript\nimport { Entity, Column, PrimaryGeneratedColumn } from \"typeorm\"\n\n@Entity()\nexport class Photo {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    name: string\n\n    @Column()\n    description: string\n\n    @Column()\n    filename: string\n\n    @Column()\n    views: number\n\n    @Column()\n    isPublished: boolean\n}\n```\n\n### Column data types\n\nNext, let's fix our data types. By default, the string is mapped to a varchar(255)-like type (depending on the database type).\nThe number is mapped to an integer-like type (depending on the database type).\nWe don't want all our columns to be limited varchars or integers.\nLet's setup the correct data types:\n\n```typescript\nimport { Entity, Column, PrimaryGeneratedColumn } from \"typeorm\"\n\n@Entity()\nexport class Photo {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column({\n        length: 100,\n    })\n    name: string\n\n    @Column(\"text\")\n    description: string\n\n    @Column()\n    filename: string\n\n    @Column(\"double\")\n    views: number\n\n    @Column()\n    isPublished: boolean\n}\n```\n\nColumn types are database-specific.\nYou can set any column type your database supports.\nMore information on supported column types can be found [here](./docs/entities.md#column-types).\n\n### Creating a new `DataSource`\n\nNow, when our entity is created, let's create `index.ts` file and set up our `DataSource` there:\n\n```typescript\nimport \"reflect-metadata\"\nimport { DataSource } from \"typeorm\"\nimport { Photo } from \"./entity/Photo\"\n\nconst AppDataSource = new DataSource({\n    type: \"postgres\",\n    host: \"localhost\",\n    port: 5432,\n    username: \"root\",\n    password: \"admin\",\n    database: \"test\",\n    entities: [Photo],\n    synchronize: true,\n    logging: false,\n})\n\n// to initialize the initial connection with the database, register all entities\n// and \"synchronize\" database schema, call \"initialize()\" method of a newly created database\n// once in your application bootstrap\nAppDataSource.initialize()\n    .then(() => {\n        // here you can start to work with your database\n    })\n    .catch((error) => console.log(error))\n```\n\nWe are using Postgres in this example, but you can use any other supported database.\nTo use another database, simply change the `type` in the options to the database type you are using:\n`mysql`, `mariadb`, `postgres`, `cockroachdb`, `sqlite`, `mssql`, `oracle`, `sap`, `spanner`, `cordova`, `nativescript`, `react-native`,\n`expo`, or `mongodb`.\nAlso make sure to use your own host, port, username, password, and database settings.\n\nWe added our Photo entity to the list of entities for this data source.\nEach entity you are using in your connection must be listed there.\n\nSetting `synchronize` makes sure your entities will be synced with the database, every time you run the application.\n\n### Running the application\n\nNow if you run your `index.ts`, a connection with the database will be initialized and a database table for your photos will be created.\n\n```shell\n+-------------+--------------+----------------------------+\n|                         photo                           |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(100) |                            |\n| description | text         |                            |\n| filename    | varchar(255) |                            |\n| views       | int(11)      |                            |\n| isPublished | boolean      |                            |\n+-------------+--------------+----------------------------+\n```\n\n### Creating and inserting a photo into the database\n\nNow let's create a new photo to save it in the database:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst photo = new Photo()\nphoto.name = \"Me and Bears\"\nphoto.description = \"I am near polar bears\"\nphoto.filename = \"photo-with-bears.jpg\"\nphoto.views = 1\nphoto.isPublished = true\n\nawait AppDataSource.manager.save(photo)\nconsole.log(\"Photo has been saved. Photo id is\", photo.id)\n```\n\nOnce your entity is saved it will get a newly generated id.\n`save` method returns an instance of the same object you pass to it.\nIt's not a new copy of the object, it modifies its \"id\" and returns it.\n\n### Using Entity Manager\n\nWe just created a new photo and saved it in the database.\nWe used `EntityManager` to save it.\nUsing entity manager you can manipulate any entity in your app.\nFor example, let's load our saved entity:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst savedPhotos = await AppDataSource.manager.find(Photo)\nconsole.log(\"All photos from the db: \", savedPhotos)\n```\n\n`savedPhotos` will be an array of Photo objects with the data loaded from the database.\n\nLearn more about EntityManager [here](./docs/working-with-entity-manager.md).\n\n### Using Repositories\n\nNow let's refactor our code and use `Repository` instead of `EntityManager`.\nEach entity has its own repository which handles all operations with its entity.\nWhen you deal with entities a lot, Repositories are more convenient to use than EntityManagers:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst photo = new Photo()\nphoto.name = \"Me and Bears\"\nphoto.description = \"I am near polar bears\"\nphoto.filename = \"photo-with-bears.jpg\"\nphoto.views = 1\nphoto.isPublished = true\n\nconst photoRepository = AppDataSource.getRepository(Photo)\n\nawait photoRepository.save(photo)\nconsole.log(\"Photo has been saved\")\n\nconst savedPhotos = await photoRepository.find()\nconsole.log(\"All photos from the db: \", savedPhotos)\n```\n\nLearn more about Repository [here](./docs/working-with-repository.md).\n\n### Loading from the database\n\nLet's try more load operations using the Repository:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst photoRepository = AppDataSource.getRepository(Photo)\nconst allPhotos = await photoRepository.find()\nconsole.log(\"All photos from the db: \", allPhotos)\n\nconst firstPhoto = await photoRepository.findOneBy({\n    id: 1,\n})\nconsole.log(\"First photo from the db: \", firstPhoto)\n\nconst meAndBearsPhoto = await photoRepository.findOneBy({\n    name: \"Me and Bears\",\n})\nconsole.log(\"Me and Bears photo from the db: \", meAndBearsPhoto)\n\nconst allViewedPhotos = await photoRepository.findBy({ views: 1 })\nconsole.log(\"All viewed photos: \", allViewedPhotos)\n\nconst allPublishedPhotos = await photoRepository.findBy({ isPublished: true })\nconsole.log(\"All published photos: \", allPublishedPhotos)\n\nconst [photos, photosCount] = await photoRepository.findAndCount()\nconsole.log(\"All photos: \", photos)\nconsole.log(\"Photos count: \", photosCount)\n```\n\n### Updating in the database\n\nNow let's load a single photo from the database, update it and save it:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst photoRepository = AppDataSource.getRepository(Photo)\nconst photoToUpdate = await photoRepository.findOneBy({\n    id: 1,\n})\nphotoToUpdate.name = \"Me, my friends and polar bears\"\nawait photoRepository.save(photoToUpdate)\n```\n\nNow photo with `id = 1` will be updated in the database.\n\n### Removing from the database\n\nNow let's remove our photo from the database:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { AppDataSource } from \"./index\"\n\nconst photoRepository = AppDataSource.getRepository(Photo)\nconst photoToRemove = await photoRepository.findOneBy({\n    id: 1,\n})\nawait photoRepository.remove(photoToRemove)\n```\n\nNow photo with `id = 1` will be removed from the database.\n\n### Creating a one-to-one relation\n\nLet's create a one-to-one relationship with another class.\nLet's create a new class in `PhotoMetadata.ts`. This PhotoMetadata class is supposed to contain our photo's additional meta-information:\n\n```typescript\nimport {\n    Entity,\n    Column,\n    PrimaryGeneratedColumn,\n    OneToOne,\n    JoinColumn,\n} from \"typeorm\"\nimport { Photo } from \"./Photo\"\n\n@Entity()\nexport class PhotoMetadata {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column(\"int\")\n    height: number\n\n    @Column(\"int\")\n    width: number\n\n    @Column()\n    orientation: string\n\n    @Column()\n    compressed: boolean\n\n    @Column()\n    comment: string\n\n    @OneToOne(() => Photo)\n    @JoinColumn()\n    photo: Photo\n}\n```\n\nHere, we are using a new decorator called `@OneToOne`. It allows us to create a one-to-one relationship between two entities. We also add a `@JoinColumn` decorator, which indicates that this side of the relationship will own the relationship.\nRelations can be unidirectional or bidirectional.\nOnly one side of relational can be owning.\nUsing `@JoinColumn` decorator is required on the owner side of the relationship.\n\nIf you run the app, you'll see a newly generated table, and it will contain a column with a foreign key for the photo relation:\n\n```shell\n+-------------+--------------+----------------------------+\n|                     photo_metadata                      |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| height      | int(11)      |                            |\n| width       | int(11)      |                            |\n| comment     | varchar(255) |                            |\n| compressed  | boolean      |                            |\n| orientation | varchar(255) |                            |\n| photoId     | int(11)      | FOREIGN KEY                |\n+-------------+--------------+----------------------------+\n```\n\n### Save a one-to-one relation\n\nNow let's save a photo, and its metadata and attach them to each other.\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { PhotoMetadata } from \"./entity/PhotoMetadata\"\n\n// create a photo\nconst photo = new Photo()\nphoto.name = \"Me and Bears\"\nphoto.description = \"I am near polar bears\"\nphoto.filename = \"photo-with-bears.jpg\"\nphoto.views = 1\nphoto.isPublished = true\n\n// create a photo metadata\nconst metadata = new PhotoMetadata()\nmetadata.height = 640\nmetadata.width = 480\nmetadata.compressed = true\nmetadata.comment = \"cybershoot\"\nmetadata.orientation = \"portrait\"\nmetadata.photo = photo // this way we connect them\n\n// get entity repositories\nconst photoRepository = AppDataSource.getRepository(Photo)\nconst metadataRepository = AppDataSource.getRepository(PhotoMetadata)\n\n// first we should save a photo\nawait photoRepository.save(photo)\n\n// photo is saved. Now we need to save a photo metadata\nawait metadataRepository.save(metadata)\n\n// done\nconsole.log(\n    \"Metadata is saved, and the relation between metadata and photo is created in the database too\",\n)\n```\n\n### Inverse side of the relationship\n\nRelations can be unidirectional or bidirectional.\nCurrently, our relation between PhotoMetadata and Photo is unidirectional.\nThe owner of the relation is PhotoMetadata, and Photo doesn't know anything about PhotoMetadata.\nThis makes it complicated to access PhotoMetadata from the Photo side.\nTo fix this issue we should add an inverse relation, and make relations between PhotoMetadata and Photo bidirectional.\nLet's modify our entities:\n\n```typescript\nimport {\n    Entity,\n    Column,\n    PrimaryGeneratedColumn,\n    OneToOne,\n    JoinColumn,\n} from \"typeorm\"\nimport { Photo } from \"./Photo\"\n\n@Entity()\nexport class PhotoMetadata {\n    /* ... other columns */\n\n    @OneToOne(() => Photo, (photo) => photo.metadata)\n    @JoinColumn()\n    photo: Photo\n}\n```\n\n```typescript\nimport { Entity, Column, PrimaryGeneratedColumn, OneToOne } from \"typeorm\"\nimport { PhotoMetadata } from \"./PhotoMetadata\"\n\n@Entity()\nexport class Photo {\n    /* ... other columns */\n\n    @OneToOne(() => PhotoMetadata, (photoMetadata) => photoMetadata.photo)\n    metadata: PhotoMetadata\n}\n```\n\n`photo => photo.metadata` is a function that returns the name of the inverse side of the relation.\nHere we show that the metadata property of the Photo class is where we store PhotoMetadata in the Photo class.\nInstead of passing a function that returns a property of the photo, you could alternatively simply pass a string to `@OneToOne` decorator, like `\"metadata\"`.\nBut we used this function-typed approach to make our refactoring easier.\n\nNote that we should use the `@JoinColumn` decorator only on one side of a relation.\nWhichever side you put this decorator on will be the owning side of the relationship.\nThe owning side of a relationship contains a column with a foreign key in the database.\n\n### Relations in ESM projects\n\nIf you use ESM in your TypeScript project, you should use the `Relation` wrapper type in relation properties to avoid circular dependency issues.\nLet's modify our entities:\n\n```typescript\nimport {\n    Entity,\n    Column,\n    PrimaryGeneratedColumn,\n    OneToOne,\n    JoinColumn,\n    Relation,\n} from \"typeorm\"\nimport { Photo } from \"./Photo\"\n\n@Entity()\nexport class PhotoMetadata {\n    /* ... other columns */\n\n    @OneToOne(() => Photo, (photo) => photo.metadata)\n    @JoinColumn()\n    photo: Relation<Photo>\n}\n```\n\n```typescript\nimport {\n    Entity,\n    Column,\n    PrimaryGeneratedColumn,\n    OneToOne,\n    Relation,\n} from \"typeorm\"\nimport { PhotoMetadata } from \"./PhotoMetadata\"\n\n@Entity()\nexport class Photo {\n    /* ... other columns */\n\n    @OneToOne(() => PhotoMetadata, (photoMetadata) => photoMetadata.photo)\n    metadata: Relation<PhotoMetadata>\n}\n```\n\n### Loading objects with their relations\n\nNow let's load our photo and its photo metadata in a single query.\nThere are two ways to do it - using `find*` methods or using `QueryBuilder` functionality.\nLet's use `find*` method first.\n`find*` methods allow you to specify an object with the `FindOneOptions` / `FindManyOptions` interface.\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { PhotoMetadata } from \"./entity/PhotoMetadata\"\nimport { AppDataSource } from \"./index\"\n\nconst photoRepository = AppDataSource.getRepository(Photo)\nconst photos = await photoRepository.find({\n    relations: {\n        metadata: true,\n    },\n})\n```\n\nHere, photos will contain an array of photos from the database, and each photo will contain its photo metadata.\nLearn more about Find Options in [this documentation](./docs/find-options.md).\n\nUsing find options is good and dead simple, but if you need a more complex query, you should use `QueryBuilder` instead.\n`QueryBuilder` allows more complex queries to be used in an elegant way:\n\n```typescript\nimport { Photo } from \"./entity/Photo\"\nimport { PhotoMetadata } from \"./entity/PhotoMetadata\"\nimport { AppDataSource } from \"./index\"\n\nconst photos = await AppDataSource.getRepository(Photo)\n    .createQueryBuilder(\"photo\")\n    .innerJoinAndSelect(\"photo.metadata\", \"metadata\")\n    .getMany()\n```\n\n`QueryBuilder` allows the creation and execution of SQL queries of almost any complexity.\nWhen you work with `QueryBuilder`, think like you are creating an SQL query.\nIn this example, \"photo\" and \"metadata\" are aliases applied to selected photos.\nYou use aliases to access columns and properties of the selected data.\n\n### Using cascades to automatically save related objects\n\nWe can set up cascade options in our relations, in the cases when we want our related object to be saved whenever the other object is saved.\nLet's change our photo's `@OneToOne` decorator a bit:\n\n```typescript\nexport class Photo {\n    // ... other columns\n\n    @OneToOne(() => PhotoMetadata, (metadata) => metadata.photo, {\n        cascade: true,\n    })\n    metadata: PhotoMetadata\n}\n```\n\nUsing `cascade` allows us not to separately save photos and separately save metadata objects now.\nNow we can simply save a photo object, and the metadata object will be saved automatically because of cascade options.\n\n```typescript\nimport { AppDataSource } from \"./index\"\n\n// create photo object\nconst photo = new Photo()\nphoto.name = \"Me and Bears\"\nphoto.description = \"I am near polar bears\"\nphoto.filename = \"photo-with-bears.jpg\"\nphoto.isPublished = true\n\n// create photo metadata object\nconst metadata = new PhotoMetadata()\nmetadata.height = 640\nmetadata.width = 480\nmetadata.compressed = true\nmetadata.comment = \"cybershoot\"\nmetadata.orientation = \"portrait\"\n\nphoto.metadata = metadata // this way we connect them\n\n// get repository\nconst photoRepository = AppDataSource.getRepository(Photo)\n\n// saving a photo also save the metadata\nawait photoRepository.save(photo)\n\nconsole.log(\"Photo is saved, photo metadata is saved too.\")\n```\n\nNotice that we now set the photo's `metadata` property, instead of the metadata's `photo` property as before. The `cascade` feature only works if you connect the photo to its metadata from the photo's side. If you set the metadata side, the metadata would not be saved automatically.\n\n### Creating a many-to-one / one-to-many relation\n\nLet's create a many-to-one/one-to-many relation.\nLet's say a photo has one author, and each author can have many photos.\nFirst, let's create an `Author` class:\n\n```typescript\nimport {\n    Entity,\n    Column,\n    PrimaryGeneratedColumn,\n    OneToMany,\n    JoinColumn,\n} from \"typeorm\"\nimport { Photo } from \"./Photo\"\n\n@Entity()\nexport class Author {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    name: string\n\n    @OneToMany(() => Photo, (photo) => photo.author) // note: we will create author property in the Photo class below\n    photos: Photo[]\n}\n```\n\n`Author` contains an inverse side of a relation.\n`OneToMany` is always an inverse side of the relation, and it can't exist without `ManyToOne` on the other side of the relation.\n\nNow let's add the owner side of the relation into the Photo entity:\n\n```typescript\nimport { Entity, Column, PrimaryGeneratedColumn, ManyToOne } from \"typeorm\"\nimport { PhotoMetadata } from \"./PhotoMetadata\"\nimport { Author } from \"./Author\"\n\n@Entity()\nexport class Photo {\n    /* ... other columns */\n\n    @ManyToOne(() => Author, (author) => author.photos)\n    author: Author\n}\n```\n\nIn many-to-one / one-to-many relations, the owner side is always many-to-one.\nIt means that the class that uses `@ManyToOne` will store the id of the related object.\n\nAfter you run the application, the ORM will create the `author` table:\n\n```shell\n+-------------+--------------+----------------------------+\n|                          author                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n```\n\nIt will also modify the `photo` table, adding a new `author` column and creating a foreign key for it:\n\n```shell\n+-------------+--------------+----------------------------+\n|                         photo                           |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(255) |                            |\n| description | varchar(255) |                            |\n| filename    | varchar(255) |                            |\n| isPublished | boolean      |                            |\n| authorId    | int(11)      | FOREIGN KEY                |\n+-------------+--------------+----------------------------+\n```\n\n### Creating a many-to-many relation\n\nLet's create a many-to-many relation.\nLet's say a photo can be in many albums, and each album can contain many photos.\nLet's create an `Album` class:\n\n```typescript\nimport {\n    Entity,\n    PrimaryGeneratedColumn,\n    Column,\n    ManyToMany,\n    JoinTable,\n} from \"typeorm\"\n\n@Entity()\nexport class Album {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    name: string\n\n    @ManyToMany(() => Photo, (photo) => photo.albums)\n    @JoinTable()\n    photos: Photo[]\n}\n```\n\n`@JoinTable` is required to specify that this is the owner side of the relationship.\n\nNow let's add the inverse side of our relation to the `Photo` class:\n\n```typescript\nexport class Photo {\n    // ... other columns\n\n    @ManyToMany(() => Album, (album) => album.photos)\n    albums: Album[]\n}\n```\n\nAfter you run the application, the ORM will create a **album_photos_photo_albums** _junction table_:\n\n```shell\n+-------------+--------------+----------------------------+\n|                album_photos_photo_albums                |\n+-------------+--------------+----------------------------+\n| album_id    | int(11)      | PRIMARY KEY FOREIGN KEY    |\n| photo_id    | int(11)      | PRIMARY KEY FOREIGN KEY    |\n+-------------+--------------+----------------------------+\n```\n\nDon't forget to register the `Album` class with your connection in the ORM:\n\n```typescript\nconst options: DataSourceOptions = {\n    // ... other options\n    entities: [Photo, PhotoMetadata, Author, Album],\n}\n```\n\nNow let's insert albums and photos into our database:\n\n```typescript\nimport { AppDataSource } from \"./index\"\n\n// create a few albums\nconst album1 = new Album()\nalbum1.name = \"Bears\"\nawait AppDataSource.manager.save(album1)\n\nconst album2 = new Album()\nalbum2.name = \"Me\"\nawait AppDataSource.manager.save(album2)\n\n// create a few photos\nconst photo = new Photo()\nphoto.name = \"Me and Bears\"\nphoto.description = \"I am near polar bears\"\nphoto.filename = \"photo-with-bears.jpg\"\nphoto.views = 1\nphoto.isPublished = true\nphoto.albums = [album1, album2]\nawait AppDataSource.manager.save(photo)\n\n// now our photo is saved and albums are attached to it\n// now lets load them:\nconst loadedPhoto = await AppDataSource.getRepository(Photo).findOne({\n    where: {\n        id: 1,\n    },\n    relations: {\n        albums: true,\n    },\n})\n```\n\n`loadedPhoto` will be equal to:\n\n```typescript\n{\n    id: 1,\n    name: \"Me and Bears\",\n    description: \"I am near polar bears\",\n    filename: \"photo-with-bears.jpg\",\n    albums: [{\n        id: 1,\n        name: \"Bears\"\n    }, {\n        id: 2,\n        name: \"Me\"\n    }]\n}\n```\n\n### Using QueryBuilder\n\nYou can use QueryBuilder to build SQL queries of almost any complexity. For example, you can do this:\n\n```typescript\nconst photos = await AppDataSource.getRepository(Photo)\n    .createQueryBuilder(\"photo\") // first argument is an alias. Alias is what you are selecting - photos. You must specify it.\n    .innerJoinAndSelect(\"photo.metadata\", \"metadata\")\n    .leftJoinAndSelect(\"photo.albums\", \"album\")\n    .where(\"photo.isPublished = true\")\n    .andWhere(\"(photo.name = :photoName OR photo.name = :bearName)\")\n    .orderBy(\"photo.id\", \"DESC\")\n    .skip(5)\n    .take(10)\n    .setParameters({ photoName: \"My\", bearName: \"Mishka\" })\n    .getMany()\n```\n\nThis query selects all published photos with \"My\" or \"Mishka\" names.\nIt will select results from position 5 (pagination offset)\nand will select only 10 results (pagination limit).\nThe selection result will be ordered by id in descending order.\nThe photo albums will be left joined and their metadata will be inner joined.\n\nYou'll use the query builder in your application a lot.\nLearn more about QueryBuilder [here](./docs/select-query-builder.md).\n\n## Samples\n\nTake a look at the samples in [sample](https://github.com/typeorm/typeorm/tree/master/sample) for examples of usage.\n\nThere are a few repositories that you can clone and start with:\n\n-   [Example how to use TypeORM with TypeScript](https://github.com/typeorm/typescript-example)\n-   [Example how to use TypeORM with JavaScript](https://github.com/typeorm/javascript-example)\n-   [Example how to use TypeORM with JavaScript and Babel](https://github.com/typeorm/babel-example)\n-   [Example how to use TypeORM with TypeScript and SystemJS in Browser](https://github.com/typeorm/browser-example)\n-   [Example how to use TypeORM with TypeScript and React in Browser](https://github.com/ItayGarin/typeorm-react-swc)\n-   [Example how to use Express and TypeORM](https://github.com/typeorm/typescript-express-example)\n-   [Example how to use Koa and TypeORM](https://github.com/typeorm/typescript-koa-example)\n-   [Example how to use TypeORM with MongoDB](https://github.com/typeorm/mongo-typescript-example)\n-   [Example how to use TypeORM in a Cordova/PhoneGap app](https://github.com/typeorm/cordova-example)\n-   [Example how to use TypeORM with an Ionic app](https://github.com/typeorm/ionic-example)\n-   [Example how to use TypeORM with React Native](https://github.com/typeorm/react-native-example)\n-   [Example how to use TypeORM with Nativescript-Vue](https://github.com/typeorm/nativescript-vue-typeorm-sample)\n-   [Example how to use TypeORM with Nativescript-Angular](https://github.com/betov18x/nativescript-angular-typeorm-example)\n-   [Example how to use TypeORM with Electron using JavaScript](https://github.com/typeorm/electron-javascript-example)\n-   [Example how to use TypeORM with Electron using TypeScript](https://github.com/typeorm/electron-typescript-example)\n\n## Extensions\n\nThere are several extensions that simplify working with TypeORM and integrating it with other modules:\n\n-   [TypeORM integration](https://github.com/typeorm/typeorm-typedi-extensions) with [TypeDI](https://github.com/pleerock/typedi)\n-   [TypeORM integration](https://github.com/typeorm/typeorm-routing-controllers-extensions) with [routing-controllers](https://github.com/pleerock/routing-controllers)\n-   Models generation from the existing database - [typeorm-model-generator](https://github.com/Kononnable/typeorm-model-generator)\n-   Fixtures loader - [typeorm-fixtures-cli](https://github.com/RobinCK/typeorm-fixtures)\n-   ER Diagram generator - [typeorm-uml](https://github.com/eugene-manuilov/typeorm-uml/)\n-   another ER Diagram generator - [erdia](https://www.npmjs.com/package/erdia/)\n-   Create, drop & seed database - [typeorm-extension](https://github.com/tada5hi/typeorm-extension)\n-   Automatically update `data-source.ts` after generating migrations/entities - [typeorm-codebase-sync](https://www.npmjs.com/package/typeorm-codebase-sync)\n-   Easy manipulation of `relations` objects - [typeorm-relations](https://npmjs.com/package/typeorm-relations)\n-   Automatically generate `relations` based on a GraphQL query - [typeorm-relations-graphql](https://npmjs.com/package/typeorm-relations-graphql)\n\n## Contributing\n\nLearn about contribution [here](https://github.com/typeorm/typeorm/blob/master/CONTRIBUTING.md) and how to set up your development environment [here](https://github.com/typeorm/typeorm/blob/master/DEVELOPER.md).\n\nThis project exists thanks to all the people who contribute:\n\n<a href=\"https://github.com/typeorm/typeorm/graphs/contributors\"><img src=\"https://opencollective.com/typeorm/contributors.svg?width=890&showBtn=false\" /></a>\n\n## Sponsors\n\nOpen source is hard and time-consuming. If you want to invest in TypeORM's future you can become a sponsor and allow our core team to spend more time on TypeORM's improvements and new features. [Become a sponsor](https://opencollective.com/typeorm)\n\n<a href=\"https://opencollective.com/typeorm\" target=\"_blank\"><img src=\"https://opencollective.com/typeorm/tiers/sponsor.svg?width=890\"></a>\n\n## Gold Sponsors\n\nBecome a gold sponsor and get premium technical support from our core contributors. [Become a gold sponsor](https://opencollective.com/typeorm)\n\n<a href=\"https://opencollective.com/typeorm\" target=\"_blank\"><img src=\"https://opencollective.com/typeorm/tiers/gold-sponsor.svg?width=890\"></a>\n",
        "releases": [
            {
                "name": "0.3.20",
                "date": "2024-01-26T11:22:33Z"
            },
            {
                "name": "0.3.19",
                "date": "2024-01-03T14:44:45Z"
            },
            {
                "name": "0.3.18",
                "date": "2024-01-03T12:43:14Z"
            },
            {
                "name": "0.3.17",
                "date": "2023-06-20T19:48:38Z"
            },
            {
                "name": "0.3.16",
                "date": "2023-05-09T18:59:14Z"
            },
            {
                "name": "0.3.15",
                "date": "2023-04-15T13:30:15Z"
            },
            {
                "name": "0.3.14",
                "date": "2023-04-09T06:40:29Z"
            },
            {
                "name": "0.3.13",
                "date": "2023-04-06T09:26:43Z"
            },
            {
                "name": "0.3.12",
                "date": "2023-02-07T14:56:09Z"
            },
            {
                "name": "0.3.11",
                "date": "2022-12-03T18:25:57Z"
            },
            {
                "name": "0.3.10",
                "date": "2022-09-19T16:30:19Z"
            },
            {
                "name": "0.3.9",
                "date": "2022-08-28T18:33:15Z"
            },
            {
                "name": "0.3.8",
                "date": "2022-08-26T16:05:16Z"
            },
            {
                "name": "0.3.7",
                "date": "2022-06-29T18:38:53Z"
            },
            {
                "name": "0.3.6",
                "date": "2022-04-12T12:35:26Z"
            },
            {
                "name": "0.3.5",
                "date": "2022-04-05T17:00:14Z"
            },
            {
                "name": "0.3.4",
                "date": "2022-03-26T16:20:47Z"
            },
            {
                "name": "0.3.3",
                "date": "2022-03-23T16:20:49Z"
            },
            {
                "name": "0.3.2",
                "date": "2022-03-22T20:34:24Z"
            },
            {
                "name": "0.3.1",
                "date": "2022-03-21T13:38:11Z"
            },
            {
                "name": "0.3.0",
                "date": "2022-03-17T16:06:26Z"
            },
            {
                "name": "0.2.45",
                "date": "2022-03-04T14:45:48Z"
            },
            {
                "name": "0.2.44",
                "date": "2022-02-23T17:55:31Z"
            },
            {
                "name": "0.2.43",
                "date": "2022-02-17T18:19:41Z"
            },
            {
                "name": "0.2.42",
                "date": "2022-02-16T16:59:06Z"
            },
            {
                "name": "0.2.41",
                "date": "2021-11-18T14:05:38Z"
            },
            {
                "name": "0.2.40",
                "date": "2021-11-11T14:59:52Z"
            },
            {
                "name": "0.2.39",
                "date": "2021-11-09T15:00:51Z"
            },
            {
                "name": "0.2.38",
                "date": "2021-10-02T17:33:49Z"
            },
            {
                "name": "",
                "date": "2021-08-13T06:30:07Z"
            },
            {
                "name": "0.2.36",
                "date": "2021-07-31T01:12:25Z"
            },
            {
                "name": "0.2.35",
                "date": "2021-07-29T02:58:54Z"
            }
        ]
    }
}
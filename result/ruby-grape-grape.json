{
    "https://api.github.com/repos/ruby-grape/grape": {
        "forks": 1223,
        "watchers": 9895,
        "stars": 9895,
        "languages": {
            "Ruby": 1048551,
            "Dockerfile": 560,
            "Shell": 393
        },
        "commits": [
            "2025-01-20T13:28:38Z",
            "2025-01-20T01:37:23Z",
            "2025-01-09T15:48:50Z",
            "2024-12-29T13:03:19Z",
            "2024-12-27T12:02:59Z",
            "2024-11-30T20:42:21Z",
            "2024-11-30T14:52:38Z",
            "2024-11-12T19:49:30Z",
            "2024-10-28T17:57:54Z",
            "2024-10-23T16:58:18Z",
            "2024-10-23T11:58:19Z",
            "2024-10-20T14:10:47Z",
            "2024-10-06T18:37:48Z",
            "2024-10-01T20:21:11Z",
            "2024-09-27T18:41:44Z",
            "2024-09-26T15:35:48Z",
            "2024-09-15T10:34:52Z",
            "2024-09-14T10:04:41Z",
            "2024-09-14T10:01:22Z",
            "2024-09-08T16:03:05Z",
            "2024-09-01T17:56:08Z",
            "2024-09-01T16:45:32Z",
            "2024-09-01T16:43:56Z",
            "2024-09-01T12:54:08Z",
            "2024-08-11T22:44:58Z",
            "2024-07-30T12:40:44Z",
            "2024-07-27T20:39:43Z",
            "2024-07-27T20:39:09Z",
            "2024-07-24T03:37:15Z",
            "2024-07-23T20:53:09Z"
        ],
        "creation_date": "2010-08-02T14:25:08Z",
        "contributors": 30,
        "topics": [
            "api",
            "grape",
            "hacktoberfest",
            "ruby"
        ],
        "subscribers": 210,
        "readme": "![grape logo](grape.png)\n\n[![Gem Version](https://badge.fury.io/rb/grape.svg)](http://badge.fury.io/rb/grape)\n[![Build Status](https://github.com/ruby-grape/grape/workflows/test/badge.svg?branch=master)](https://github.com/ruby-grape/grape/actions)\n[![Code Climate](https://codeclimate.com/github/ruby-grape/grape.svg)](https://codeclimate.com/github/ruby-grape/grape)\n[![Coverage Status](https://coveralls.io/repos/github/ruby-grape/grape/badge.svg?branch=master)](https://coveralls.io/github/ruby-grape/grape?branch=master)\n[![Inline docs](https://inch-ci.org/github/ruby-grape/grape.svg)](https://inch-ci.org/github/ruby-grape/grape)\n[![Join the chat at https://gitter.im/ruby-grape/grape](https://badges.gitter.im/ruby-grape/grape.svg)](https://gitter.im/ruby-grape/grape?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n## Table of Contents\n\n- [What is Grape?](#what-is-grape)\n- [Stable Release](#stable-release)\n- [Project Resources](#project-resources)\n- [Grape for Enterprise](#grape-for-enterprise)\n- [Installation](#installation)\n- [Basic Usage](#basic-usage)\n- [Rails 7.1](#rails-71)\n- [Mounting](#mounting)\n  - [All](#all)\n  - [Rack](#rack)\n  - [Alongside Sinatra (or other frameworks)](#alongside-sinatra-or-other-frameworks)\n  - [Rails](#rails)\n    - [Zeitwerk](#zeitwerk)\n  - [Modules](#modules)\n- [Remounting](#remounting)\n  - [Mount Configuration](#mount-configuration)\n- [Versioning](#versioning)\n  - [Strategies](#strategies)\n    - [Path](#path)\n    - [Header](#header)\n    - [Accept-Version Header](#accept-version-header)\n    - [Param](#param)\n- [Describing Methods](#describing-methods)\n- [Configuration](#configuration)\n- [Parameters](#parameters)\n  - [Params Class](#params-class)\n  - [Declared](#declared)\n  - [Include Parent Namespaces](#include-parent-namespaces)\n  - [Include Missing](#include-missing)\n  - [Evaluate Given](#evaluate-given)\n  - [Parameter Precedence](#parameter-precedence)\n- [Parameter Validation and Coercion](#parameter-validation-and-coercion)\n  - [Supported Parameter Types](#supported-parameter-types)\n  - [Integer/Fixnum and Coercions](#integerfixnum-and-coercions)\n  - [Custom Types and Coercions](#custom-types-and-coercions)\n  - [Multipart File Parameters](#multipart-file-parameters)\n  - [First-Class JSON Types](#first-class-json-types)\n  - [Multiple Allowed Types](#multiple-allowed-types)\n  - [Validation of Nested Parameters](#validation-of-nested-parameters)\n  - [Dependent Parameters](#dependent-parameters)\n  - [Group Options](#group-options)\n  - [Renaming](#renaming)\n  - [Built-in Validators](#built-in-validators)\n    - [allow_blank](#allow_blank)\n    - [values](#values)\n    - [except_values](#except_values)\n    - [same_as](#same_as)\n    - [length](#length)\n    - [regexp](#regexp)\n    - [mutually_exclusive](#mutually_exclusive)\n    - [exactly_one_of](#exactly_one_of)\n    - [at_least_one_of](#at_least_one_of)\n    - [all_or_none_of](#all_or_none_of)\n    - [Nested mutually_exclusive, exactly_one_of, at_least_one_of, all_or_none_of](#nested-mutually_exclusive-exactly_one_of-at_least_one_of-all_or_none_of)\n  - [Namespace Validation and Coercion](#namespace-validation-and-coercion)\n  - [Custom Validators](#custom-validators)\n  - [Validation Errors](#validation-errors)\n  - [I18n](#i18n)\n  - [Custom Validation messages](#custom-validation-messages)\n    - [presence, allow_blank, values, regexp](#presence-allow_blank-values-regexp)\n    - [same_as](#same_as-1)\n    - [length](#length-1)\n    - [all_or_none_of](#all_or_none_of-1)\n    - [mutually_exclusive](#mutually_exclusive-1)\n    - [exactly_one_of](#exactly_one_of-1)\n    - [at_least_one_of](#at_least_one_of-1)\n    - [Coerce](#coerce)\n    - [With Lambdas](#with-lambdas)\n    - [Pass symbols for i18n translations](#pass-symbols-for-i18n-translations)\n    - [Overriding Attribute Names](#overriding-attribute-names)\n    - [With Default](#with-default)\n  - [Using dry-validation or dry-schema](#using-dry-validation-or-dry-schema)\n- [Headers](#headers)\n  - [Request](#request)\n    - [Header Case Handling](#header-case-handling)\n  - [Response](#response)\n- [Routes](#routes)\n- [Helpers](#helpers)\n- [Path Helpers](#path-helpers)\n- [Parameter Documentation](#parameter-documentation)\n- [Cookies](#cookies)\n- [HTTP Status Code](#http-status-code)\n- [Redirecting](#redirecting)\n- [Recognizing Path](#recognizing-path)\n- [Allowed Methods](#allowed-methods)\n- [Raising Exceptions](#raising-exceptions)\n  - [Default Error HTTP Status Code](#default-error-http-status-code)\n  - [Handling 404](#handling-404)\n- [Exception Handling](#exception-handling)\n    - [Rescuing exceptions inside namespaces](#rescuing-exceptions-inside-namespaces)\n    - [Unrescuable Exceptions](#unrescuable-exceptions)\n    - [Exceptions that should be rescued explicitly](#exceptions-that-should-be-rescued-explicitly)\n- [Logging](#logging)\n- [API Formats](#api-formats)\n  - [JSONP](#jsonp)\n  - [CORS](#cors)\n- [Content-type](#content-type)\n- [API Data Formats](#api-data-formats)\n- [JSON and XML Processors](#json-and-xml-processors)\n- [RESTful Model Representations](#restful-model-representations)\n  - [Grape Entities](#grape-entities)\n  - [Hypermedia and Roar](#hypermedia-and-roar)\n  - [Rabl](#rabl)\n  - [Active Model Serializers](#active-model-serializers)\n- [Sending Raw or No Data](#sending-raw-or-no-data)\n- [Authentication](#authentication)\n  - [Basic Auth](#basic-auth)\n  - [Register custom middleware for authentication](#register-custom-middleware-for-authentication)\n- [Describing and Inspecting an API](#describing-and-inspecting-an-api)\n- [Current Route and Endpoint](#current-route-and-endpoint)\n- [Before, After and Finally](#before-after-and-finally)\n- [Anchoring](#anchoring)\n- [Instance Variables](#instance-variables)\n- [Using Custom Middleware](#using-custom-middleware)\n  - [Grape Middleware](#grape-middleware)\n  - [Rails Middleware](#rails-middleware)\n  - [Remote IP](#remote-ip)\n- [Writing Tests](#writing-tests)\n  - [Writing Tests with Rack](#writing-tests-with-rack)\n    - [RSpec](#rspec)\n    - [Airborne](#airborne)\n    - [MiniTest](#minitest)\n  - [Writing Tests with Rails](#writing-tests-with-rails)\n    - [RSpec](#rspec-1)\n    - [MiniTest](#minitest-1)\n  - [Stubbing Helpers](#stubbing-helpers)\n- [Reloading API Changes in Development](#reloading-api-changes-in-development)\n  - [Reloading in Rack Applications](#reloading-in-rack-applications)\n  - [Reloading in Rails Applications](#reloading-in-rails-applications)\n- [Performance Monitoring](#performance-monitoring)\n  - [Active Support Instrumentation](#active-support-instrumentation)\n    - [endpoint_run.grape](#endpoint_rungrape)\n    - [endpoint_render.grape](#endpoint_rendergrape)\n    - [endpoint_run_filters.grape](#endpoint_run_filtersgrape)\n    - [endpoint_run_validators.grape](#endpoint_run_validatorsgrape)\n    - [format_response.grape](#format_responsegrape)\n  - [Monitoring Products](#monitoring-products)\n- [Contributing to Grape](#contributing-to-grape)\n- [Security](#security)\n- [License](#license)\n- [Copyright](#copyright)\n\n## What is Grape?\n\nGrape is a REST-like API framework for Ruby. It's designed to run on Rack or complement existing web application frameworks such as Rails and Sinatra by providing a simple DSL to easily develop RESTful APIs. It has built-in support for common conventions, including multiple formats, subdomain/prefix restriction, content negotiation, versioning and much more.\n\n## Stable Release\n\nYou're reading the documentation for the next release of Grape, which should be 2.3.0.\nThe current stable release is [2.2.0](https://github.com/ruby-grape/grape/blob/v2.2.0/README.md).\n\n## Project Resources\n\n* [Grape Website](http://www.ruby-grape.org)\n* [Documentation](http://www.rubydoc.info/gems/grape)\n* Need help? Try [Grape Google Group](http://groups.google.com/group/ruby-grape) or [Gitter](https://gitter.im/ruby-grape/grape)\n* [Follow us on Twitter](https://twitter.com/grapeframework)\n\n## Grape for Enterprise\n\nAvailable as part of the Tidelift Subscription.\n\nThe maintainers of Grape are working with Tidelift to deliver commercial support and maintenance. Save time, reduce risk, and improve code health, while paying the maintainers of Grape. Click [here](https://tidelift.com/subscription/request-a-demo?utm_source=rubygems-grape&utm_medium=referral&utm_campaign=enterprise) for more details.\n\n## Installation\n\nRuby 2.7 or newer is required.\n\nGrape is available as a gem, to install it run:\n\n    bundle add grape\n\n## Basic Usage\n\nGrape APIs are Rack applications that are created by subclassing `Grape::API`.\nBelow is a simple example showing some of the more common features of Grape in the context of recreating parts of the Twitter API.\n\n```ruby\nmodule Twitter\n  class API < Grape::API\n    version 'v1', using: :header, vendor: 'twitter'\n    format :json\n    prefix :api\n\n    helpers do\n      def current_user\n        @current_user ||= User.authorize!(env)\n      end\n\n      def authenticate!\n        error!('401 Unauthorized', 401) unless current_user\n      end\n    end\n\n    resource :statuses do\n      desc 'Return a public timeline.'\n      get :public_timeline do\n        Status.limit(20)\n      end\n\n      desc 'Return a personal timeline.'\n      get :home_timeline do\n        authenticate!\n        current_user.statuses.limit(20)\n      end\n\n      desc 'Return a status.'\n      params do\n        requires :id, type: Integer, desc: 'Status ID.'\n      end\n      route_param :id do\n        get do\n          Status.find(params[:id])\n        end\n      end\n\n      desc 'Create a status.'\n      params do\n        requires :status, type: String, desc: 'Your status.'\n      end\n      post do\n        authenticate!\n        Status.create!({\n          user: current_user,\n          text: params[:status]\n        })\n      end\n\n      desc 'Update a status.'\n      params do\n        requires :id, type: String, desc: 'Status ID.'\n        requires :status, type: String, desc: 'Your status.'\n      end\n      put ':id' do\n        authenticate!\n        current_user.statuses.find(params[:id]).update({\n          user: current_user,\n          text: params[:status]\n        })\n      end\n\n      desc 'Delete a status.'\n      params do\n        requires :id, type: String, desc: 'Status ID.'\n      end\n      delete ':id' do\n        authenticate!\n        current_user.statuses.find(params[:id]).destroy\n      end\n    end\n  end\nend\n```\n\n## Rails 7.1\n\nGrape's [deprecator](https://api.rubyonrails.org/v7.1.0/classes/ActiveSupport/Deprecation.html) will be added to your application's deprecators [automatically](lib/grape/railtie.rb) as `:grape`, so that your application's configuration can be applied to it.\n\n## Mounting\n\n### All\n\n\nBy default Grape will compile the routes on the first route, it is possible to pre-load routes using the `compile!` method.\n\n```ruby\nTwitter::API.compile!\n```\n\nThis can be added to your `config.ru` (if using rackup), `application.rb` (if using rails), or any file that loads your server.\n\n### Rack\n\nThe above sample creates a Rack application that can be run from a rackup `config.ru` file with `rackup`:\n\n```ruby\nrun Twitter::API\n```\n\n(With pre-loading you can use)\n\n```ruby\nTwitter::API.compile!\nrun Twitter::API\n```\n\nAnd would respond to the following routes:\n\n    GET /api/statuses/public_timeline\n    GET /api/statuses/home_timeline\n    GET /api/statuses/:id\n    POST /api/statuses\n    PUT /api/statuses/:id\n    DELETE /api/statuses/:id\n\nGrape will also automatically respond to HEAD and OPTIONS for all GET, and just OPTIONS for all other routes.\n\n### Alongside Sinatra (or other frameworks)\n\nIf you wish to mount Grape alongside another Rack framework such as Sinatra, you can do so easily using `Rack::Cascade`:\n\n```ruby\n# Example config.ru\n\nrequire 'sinatra'\nrequire 'grape'\n\nclass API < Grape::API\n  get :hello do\n    { hello: 'world' }\n  end\nend\n\nclass Web < Sinatra::Base\n  get '/' do\n    'Hello world.'\n  end\nend\n\nuse Rack::Session::Cookie\nrun Rack::Cascade.new [Web, API]\n```\n\nNote that order of loading apps using `Rack::Cascade` matters. The grape application must be last if you want to raise custom 404 errors from grape (such as `error!('Not Found',404)`). If the grape application is not last and returns 404 or 405 response, [cascade utilizes that as a signal to try the next app](https://www.rubydoc.info/gems/rack/Rack/Cascade). This may lead to undesirable behavior showing the [wrong 404 page from the wrong app](https://github.com/ruby-grape/grape/issues/1515).\n\n\n### Rails\n\nPlace API files into `app/api`. Rails expects a subdirectory that matches the name of the Ruby module and a file name that matches the name of the class. In our example, the file name location and directory for `Twitter::API` should be `app/api/twitter/api.rb`.\n\nModify `config/routes`:\n\n```ruby\nmount Twitter::API => '/'\n```\n#### Zeitwerk\nRails's default autoloader is `Zeitwerk`. By default, it inflects `api` as `Api` instead of `API`. To make our example work, you need to uncomment the lines at the bottom of `config/initializers/inflections.rb`, and add `API` as an acronym:\n\n```ruby\nActiveSupport::Inflector.inflections(:en) do |inflect|\n  inflect.acronym 'API'\nend\n```\n\n### Modules\n\nYou can mount multiple API implementations inside another one. These don't have to be different versions, but may be components of the same API.\n\n```ruby\nclass Twitter::API < Grape::API\n  mount Twitter::APIv1\n  mount Twitter::APIv2\nend\n```\n\nYou can also mount on a path, which is similar to using `prefix` inside the mounted API itself.\n\n```ruby\nclass Twitter::API < Grape::API\n  mount Twitter::APIv1 => '/v1'\nend\n```\n\nDeclarations as `before/after/rescue_from` can be placed before or after `mount`. In any case they will be inherited.\n\n```ruby\nclass Twitter::API < Grape::API\n  before do\n    header 'X-Base-Header', 'will be defined for all APIs that are mounted below'\n  end\n\n  rescue_from :all do\n    error!({ \"error\" => \"Internal Server Error\" }, 500)\n  end\n\n  mount Twitter::Users\n  mount Twitter::Search\n\n  after do\n    clean_cache!\n  end\n\n  rescue_from ZeroDivisionError do\n    error!({ \"error\" => \"Not found\" }, 404)\n  end\nend\n```\n\n## Remounting\n\nYou can mount the same endpoints in two different locations.\n\n```ruby\nclass Voting::API < Grape::API\n  namespace 'votes' do\n    get do\n      # Your logic\n    end\n\n    post do\n      # Your logic\n    end\n  end\nend\n\nclass Post::API < Grape::API\n  mount Voting::API\nend\n\nclass Comment::API < Grape::API\n  mount Voting::API\nend\n```\n\nAssuming that the post and comment endpoints are mounted in `/posts` and `/comments`, you should now be able to do `get /posts/votes`, `post /posts/votes`, `get /comments/votes` and `post /comments/votes`.\n\n### Mount Configuration\n\nYou can configure remountable endpoints to change how they behave according to where they are mounted.\n\n```ruby\nclass Voting::API < Grape::API\n  namespace 'votes' do\n    desc \"Vote for your #{configuration[:votable]}\"\n    get do\n      # Your logic\n    end\n  end\nend\n\nclass Post::API < Grape::API\n  mount Voting::API, with: { votable: 'posts' }\nend\n\nclass Comment::API < Grape::API\n  mount Voting::API, with: { votable: 'comments' }\nend\n```\n\nNote that if you're passing a hash as the first parameter to `mount`, you will need to explicitly put `()` around parameters:\n```ruby\n# good\nmount({ ::Some::Api => '/some/api' }, with: { condition: true })\n\n# bad\nmount ::Some::Api => '/some/api', with: { condition: true }\n```\n\nYou can access `configuration` on the class (to use as dynamic attributes), inside blocks (like namespace)\n\nIf you want logic happening given on an `configuration`, you can use the helper `given`.\n\n```ruby\nclass ConditionalEndpoint::API < Grape::API\n  given configuration[:some_setting] do\n    get 'mount_this_endpoint_conditionally' do\n      configuration[:configurable_response]\n    end\n  end\nend\n```\n\nIf you want a block of logic running every time an endpoint is mounted (within which you can access the `configuration` Hash)\n\n\n```ruby\nclass ConditionalEndpoint::API < Grape::API\n  mounted do\n    YourLogger.info \"This API was mounted at: #{Time.now}\"\n\n    get configuration[:endpoint_name] do\n      configuration[:configurable_response]\n    end\n  end\nend\n```\n\nMore complex results can be achieved by using `mounted` as an expression within which the `configuration` is already evaluated as a Hash.\n\n```ruby\nclass ExpressionEndpointAPI < Grape::API\n  get(mounted { configuration[:route_name] || 'default_name' }) do\n    # some logic\n  end\nend\n```\n\n```ruby\nclass BasicAPI < Grape::API\n  desc 'Statuses index' do\n    params: (configuration[:entity] || API::Entities::Status).documentation\n  end\n  params do\n    requires :all, using: (configuration[:entity] || API::Entities::Status).documentation\n  end\n  get '/statuses' do\n    statuses = Status.all\n    type = current_user.admin? ? :full : :default\n    present statuses, with: (configuration[:entity] || API::Entities::Status), type: type\n  end\nend\n\nclass V1 < Grape::API\n  version 'v1'\n  mount BasicAPI, with: { entity: mounted { configuration[:entity] || API::Entities::Status } }\nend\n\nclass V2 < Grape::API\n  version 'v2'\n  mount BasicAPI, with: { entity: mounted { configuration[:entity] || API::Entities::V2::Status } }\nend\n```\n\n## Versioning\n\nYou have the option to provide various versions of your API by establishing a separate `Grape::API` class for each offered version and then integrating them into a primary `Grape::API` class. Ensure that newer versions are mounted before older ones. The default approach to versioning directs the request to the subsequent Rack middleware if a specific version is not found.\n\n```ruby\nrequire 'v1'\nrequire 'v2'\nrequire 'v3'\nclass App < Grape::API\n  mount V3\n  mount V2\n  mount V1\nend\n```\n\nTo maintain the same endpoints from earlier API versions without rewriting them, you can indicate multiple versions within the previous API versions.\n\n```ruby\nclass V1 < Grape::API\n  version 'v1', 'v2', 'v3'\n\n  get '/foo' do\n    # your code for GET /foo\n  end\n\n  get '/other' do\n    # your code for GET /other\n  end\nend\n\nclass V2 < Grape::API\n  version 'v2', 'v3'\n\n  get '/var' do\n    # your code for GET /var\n  end\nend\n\nclass V3 < Grape::API\n  version 'v3'\n\n  get '/foo' do\n    # your new code for GET /foo\n  end\nend\n```\n\nUsing the example provided, the subsequent endpoints will be accessible across various versions:\n\n```shell\nGET /v1/foo\nGET /v1/other\nGET /v2/foo # => Same behavior as v1\nGET /v2/other # => Same behavior as v1\nGET /v2/var # => New endpoint not available in v1\nGET /v3/foo # => Different behavior to v1 and v2\nGET /v3/other # => Same behavior as v1 and v2\nGET /v3/var # => Same behavior as v2\n```\n\nThere are four strategies in which clients can reach your API's endpoints: `:path`, `:header`, `:accept_version_header` and `:param`. The default strategy is `:path`.\n\n### Strategies\n\n#### Path\n\n```ruby\nversion 'v1', using: :path\n```\n\nUsing this versioning strategy, clients should pass the desired version in the URL.\n\n    curl http://localhost:9292/v1/statuses/public_timeline\n\n#### Header\n\n```ruby\nversion 'v1', using: :header, vendor: 'twitter'\n```\n\nCurrently, Grape only supports versioned media types in the following format:\n\n```\nvnd.vendor-and-or-resource-v1234+format\n```\n\nBasically all tokens between the final `-` and the `+` will be interpreted as the version.\n\nUsing this versioning strategy, clients should pass the desired version in the HTTP `Accept` head.\n\n    curl -H Accept:application/vnd.twitter-v1+json http://localhost:9292/statuses/public_timeline\n\nBy default, the first matching version is used when no `Accept` header is supplied. This behavior is similar to routing in Rails. To circumvent this default behavior, one could use the `:strict` option. When this option is set to `true`, a `406 Not Acceptable` error is returned when no correct `Accept` header is supplied.\n\nWhen an invalid `Accept` header is supplied, a `406 Not Acceptable` error is returned if the `:cascade` option is set to `false`. Otherwise a `404 Not Found` error is returned by Rack if no other route matches.\n\nGrape will evaluate the relative quality preference included in Accept headers and default to a quality of 1.0 when omitted. In the following example a Grape API that supports XML and JSON in that order will return JSON:\n\n    curl -H \"Accept: text/xml;q=0.8, application/json;q=0.9\" localhost:1234/resource\n\n#### Accept-Version Header\n\n```ruby\nversion 'v1', using: :accept_version_header\n```\n\nUsing this versioning strategy, clients should pass the desired version in the HTTP `Accept-Version` header.\n\n    curl -H \"Accept-Version:v1\" http://localhost:9292/statuses/public_timeline\n\nBy default, the first matching version is used when no `Accept-Version` header is supplied. This behavior is similar to routing in Rails. To circumvent this default behavior, one could use the `:strict` option. When this option is set to `true`, a `406 Not Acceptable` error is returned when no correct `Accept` header is supplied and the `:cascade` option is set to `false`. Otherwise a `404 Not Found` error is returned by Rack if no other route matches.\n\n#### Param\n\n```ruby\nversion 'v1', using: :param\n```\n\nUsing this versioning strategy, clients should pass the desired version as a request parameter, either in the URL query string or in the request body.\n\n    curl http://localhost:9292/statuses/public_timeline?apiver=v1\n\nThe default name for the query parameter is 'apiver' but can be specified using the `:parameter` option.\n\n```ruby\nversion 'v1', using: :param, parameter: 'v'\n```\n\n    curl http://localhost:9292/statuses/public_timeline?v=v1\n\n\n## Describing Methods\n\nYou can add a description to API methods and namespaces. The description would be used by [grape-swagger][grape-swagger] to generate swagger compliant documentation.\n\nNote: Description block is only for documentation and won't affects API behavior.\n\n```ruby\ndesc 'Returns your public timeline.' do\n  summary 'summary'\n  detail 'more details'\n  params  API::Entities::Status.documentation\n  success API::Entities::Entity\n  failure [[401, 'Unauthorized', 'Entities::Error']]\n  default { code: 500, message: 'InvalidRequest', model: Entities::Error }\n  named 'My named route'\n  headers XAuthToken: {\n            description: 'Validates your identity',\n            required: true\n          },\n          XOptionalHeader: {\n            description: 'Not really needed',\n            required: false\n          }\n  hidden false\n  deprecated false\n  is_array true\n  nickname 'nickname'\n  produces ['application/json']\n  consumes ['application/json']\n  tags ['tag1', 'tag2']\nend\nget :public_timeline do\n  Status.limit(20)\nend\n```\n\n* `detail`: A more enhanced description\n* `params`: Define parameters directly from an `Entity`\n* `success`: (former entity) The `Entity` to be used to present the success response for this route.\n* `failure`: (former http_codes) A definition of the used failure HTTP Codes and Entities.\n* `default`: The definition and `Entity` used to present the default response for this route.\n* `named`: A helper to give a route a name and find it with this name in the documentation Hash\n* `headers`: A definition of the used Headers\n* Other options can be found in [grape-swagger][grape-swagger]\n\n[grape-swagger]: https://github.com/ruby-grape/grape-swagger\n\n## Configuration\n\nUse `Grape.configure` to set up global settings at load time.\nCurrently the configurable settings are:\n\n* `param_builder`: Sets the [Parameter Builder](#parameters), defaults to `Grape::Extensions::ActiveSupport::HashWithIndifferentAccess::ParamBuilder`.\n\nTo change a setting value make sure that at some point during load time the following code runs\n\n```ruby\nGrape.configure do |config|\n  config.setting = value\nend\n```\n\nFor example, for the `param_builder`, the following code could run in an initializer:\n\n```ruby\nGrape.configure do |config|\n  config.param_builder = Grape::Extensions::Hashie::Mash::ParamBuilder\nend\n```\n\nYou can also configure a single API:\n\n```ruby\nAPI.configure do |config|\n  config[key] = value\nend\n```\n\nThis will be available inside the API with `configuration`, as if it were [mount configuration](#mount-configuration).\n\n## Parameters\n\nRequest parameters are available through the `params` hash object. This includes `GET`, `POST` and `PUT` parameters, along with any named parameters you specify in your route strings.\n\n```ruby\nget :public_timeline do\n  Status.order(params[:sort_by])\nend\n```\n\nParameters are automatically populated from the request body on `POST` and `PUT` for form input, JSON and XML content-types.\n\nThe request:\n\n```\ncurl -d '{\"text\": \"140 characters\"}' 'http://localhost:9292/statuses' -H Content-Type:application/json -v\n```\n\nThe Grape endpoint:\n\n```ruby\npost '/statuses' do\n  Status.create!(text: params[:text])\nend\n```\n\nMultipart POSTs and PUTs are supported as well.\n\nThe request:\n\n```\ncurl --form image_file='@image.jpg;type=image/jpg' http://localhost:9292/upload\n```\n\nThe Grape endpoint:\n\n```ruby\npost 'upload' do\n  # file in params[:image_file]\nend\n```\n\nIn the case of conflict between either of:\n\n* route string parameters\n* `GET`, `POST` and `PUT` parameters\n* the contents of the request body on `POST` and `PUT`\n\nRoute string parameters will have precedence.\n\n### Params Class\n\nBy default parameters are available as `ActiveSupport::HashWithIndifferentAccess`. This can be changed to, for example, Ruby `Hash` or `Hashie::Mash` for the entire API.\n\n```ruby\nclass API < Grape::API\n  include Grape::Extensions::Hashie::Mash::ParamBuilder\n\n  params do\n    optional :color, type: String\n  end\n  get do\n    params.color # instead of params[:color]\n  end\n```\n\nThe class can also be overridden on individual parameter blocks using `build_with` as follows.\n\n```ruby\nparams do\n  build_with Grape::Extensions::Hash::ParamBuilder\n  optional :color, type: String\nend\n```\n\nOr globally with the [Configuration](#configuration) `Grape.configure.param_builder`.\n\nIn the example above, `params[\"color\"]` will return `nil` since `params` is a plain `Hash`.\n\nAvailable parameter builders are `Grape::Extensions::Hash::ParamBuilder`, `Grape::Extensions::ActiveSupport::HashWithIndifferentAccess::ParamBuilder` and `Grape::Extensions::Hashie::Mash::ParamBuilder`.\n\n### Declared\n\nGrape allows you to access only the parameters that have been declared by your `params` block. It will:\n\n  * Filter out the params that have been passed, but are not allowed.\n  * Include any optional params that are declared but not passed.\n  * Perform any parameter renaming on the resulting hash.\n\nConsider the following API endpoint:\n\n````ruby\nformat :json\n\npost 'users/signup' do\n  { 'declared_params' => declared(params) }\nend\n````\n\nIf you do not specify any parameters, `declared` will return an empty hash.\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{\"user\": {\"first_name\":\"first name\", \"last_name\": \"last name\"}}'\n````\n\n**Response**\n\n````json\n{\n  \"declared_params\": {}\n}\n\n````\n\nOnce we add parameters requirements, grape will start returning only the declared parameters.\n\n````ruby\nformat :json\n\nparams do\n  optional :user, type: Hash do\n    optional :first_name, type: String\n    optional :last_name, type: String\n  end\nend\n\npost 'users/signup' do\n  { 'declared_params' => declared(params) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{\"user\": {\"first_name\":\"first name\", \"last_name\": \"last name\", \"random\": \"never shown\"}}'\n````\n\n**Response**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\",\n      \"last_name\": \"last name\"\n    }\n  }\n}\n````\n\nMissing params that are declared as type `Hash` or `Array` will be included.\n\n````ruby\nformat :json\n\nparams do\n  optional :user, type: Hash do\n    optional :first_name, type: String\n    optional :last_name, type: String\n  end\n  optional :widgets, type: Array\nend\n\npost 'users/signup' do\n  { 'declared_params' => declared(params) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{}'\n````\n\n**Response**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": null,\n      \"last_name\": null\n    },\n    \"widgets\": []\n  }\n}\n````\n\nThe returned hash is an `ActiveSupport::HashWithIndifferentAccess`.\n\nThe `#declared` method is not available to `before` filters, as those are evaluated prior to parameter coercion.\n\n### Include Parent Namespaces\n\nBy default `declared(params)` includes parameters that were defined in all parent namespaces. If you want to return only parameters from your current namespace, you can set `include_parent_namespaces` option to `false`.\n\n````ruby\nformat :json\n\nnamespace :parent do\n  params do\n    requires :parent_name, type: String\n  end\n\n  namespace ':parent_name' do\n    params do\n      requires :child_name, type: String\n    end\n    get ':child_name' do\n      {\n        'without_parent_namespaces' => declared(params, include_parent_namespaces: false),\n        'with_parent_namespaces' => declared(params, include_parent_namespaces: true),\n      }\n    end\n  end\nend\n````\n\n**Request**\n\n````bash\ncurl -X GET -H \"Content-Type: application/json\" localhost:9292/parent/foo/bar\n````\n\n**Response**\n\n````json\n{\n  \"without_parent_namespaces\": {\n    \"child_name\": \"bar\"\n  },\n  \"with_parent_namespaces\": {\n    \"parent_name\": \"foo\",\n    \"child_name\": \"bar\"\n  },\n}\n````\n\n### Include Missing\n\nBy default `declared(params)` includes parameters that have `nil` values. If you want to return only the parameters that are not `nil`, you can use the `include_missing` option. By default, `include_missing` is set to `true`. Consider the following API:\n\n````ruby\nformat :json\n\nparams do\n  requires :user, type: Hash do\n    requires :first_name, type: String\n    optional :last_name, type: String\n  end\nend\n\npost 'users/signup' do\n  { 'declared_params' => declared(params, include_missing: false) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{\"user\": {\"first_name\":\"first name\", \"random\": \"never shown\"}}'\n````\n\n**Response with include_missing:false**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\"\n    }\n  }\n}\n````\n\n**Response with include_missing:true**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\",\n      \"last_name\": null\n    }\n  }\n}\n````\n\nIt also works on nested hashes:\n\n````ruby\nformat :json\n\nparams do\n  requires :user, type: Hash do\n    requires :first_name, type: String\n    optional :last_name, type: String\n    requires :address, type: Hash do\n      requires :city, type: String\n      optional :region, type: String\n    end\n  end\nend\n\npost 'users/signup' do\n  { 'declared_params' => declared(params, include_missing: false) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{\"user\": {\"first_name\":\"first name\", \"random\": \"never shown\", \"address\": { \"city\": \"SF\"}}}'\n````\n\n**Response with include_missing:false**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\",\n      \"address\": {\n        \"city\": \"SF\"\n      }\n    }\n  }\n}\n````\n\n**Response with include_missing:true**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\",\n      \"last_name\": null,\n      \"address\": {\n        \"city\": \"Zurich\",\n        \"region\": null\n      }\n    }\n  }\n}\n````\n\nNote that an attribute with a `nil` value is not considered *missing* and will also be returned when `include_missing` is set to `false`:\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/users/signup -d '{\"user\": {\"first_name\":\"first name\", \"last_name\": null, \"address\": { \"city\": \"SF\"}}}'\n````\n\n**Response with include_missing:false**\n\n````json\n{\n  \"declared_params\": {\n    \"user\": {\n      \"first_name\": \"first name\",\n      \"last_name\": null,\n      \"address\": { \"city\": \"SF\"}\n    }\n  }\n}\n````\n\n### Evaluate Given\n\nBy default `declared(params)` will not evaluate `given` and return all parameters. Use `evaluate_given` to evaluate all `given` blocks and return only parameters that satisfy `given` conditions. Consider the following API:\n\n````ruby\nformat :json\n\nparams do\n  optional :child_id, type: Integer\n  given :child_id do\n    requires :father_id, type: Integer\n  end\nend\n\npost 'child' do\n  { 'declared_params' => declared(params, evaluate_given: true) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/child -d '{\"father_id\": 1}'\n````\n\n**Response with evaluate_given:false**\n\n````json\n{\n  \"declared_params\": {\n    \"child_id\": null,\n    \"father_id\": 1\n  }\n}\n````\n\n**Response with evaluate_given:true**\n\n````json\n{\n  \"declared_params\": {\n    \"child_id\": null\n  }\n}\n````\n\nIt also works on nested hashes:\n\n````ruby\nformat :json\n\nparams do\n  requires :child, type: Hash do\n    optional :child_id, type: Integer\n    given :child_id do\n      requires :father_id, type: Integer\n    end\n  end\nend\n\npost 'child' do\n  { 'declared_params' => declared(params, evaluate_given: true) }\nend\n````\n\n**Request**\n\n````bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/child -d '{\"child\": {\"father_id\": 1}}'\n````\n\n**Response with evaluate_given:false**\n\n````json\n{\n  \"declared_params\": {\n    \"child\": {\n      \"child_id\": null,\n      \"father_id\": 1\n    }\n  }\n}\n````\n\n**Response with evaluate_given:true**\n\n````json\n{\n  \"declared_params\": {\n    \"child\": {\n      \"child_id\": null\n    }\n  }\n}\n````\n\n### Parameter Precedence\n\nUsing `route_param` takes higher precedence over a regular parameter defined with same name:\n\n```ruby\nparams do\n  requires :foo, type: String\nend\nroute_param :foo do\n  get do\n    { value: params[:foo] }\n  end\nend\n```\n\n**Request**\n\n```bash\ncurl -X POST -H \"Content-Type: application/json\" localhost:9292/bar -d '{\"foo\": \"baz\"}'\n```\n\n**Response**\n\n```json\n{\n  \"value\": \"bar\"\n}\n```\n\n## Parameter Validation and Coercion\n\nYou can define validations and coercion options for your parameters using a `params` block.\n\n```ruby\nparams do\n  requires :id, type: Integer\n  optional :text, type: String, regexp: /\\A[a-z]+\\z/\n  group :media, type: Hash do\n    requires :url\n  end\n  optional :audio, type: Hash do\n    requires :format, type: Symbol, values: [:mp3, :wav, :aac, :ogg], default: :mp3\n  end\n  mutually_exclusive :media, :audio\nend\nput ':id' do\n  # params[:id] is an Integer\nend\n```\n\nWhen a type is specified an implicit validation is done after the coercion to ensure the output type is the one declared.\n\nOptional parameters can have a default value.\n\n```ruby\nparams do\n  optional :color, type: String, default: 'blue'\n  optional :random_number, type: Integer, default: -> { Random.rand(1..100) }\n  optional :non_random_number, type: Integer, default:  Random.rand(1..100)\nend\n```\n\nDefault values are eagerly evaluated. Above `:non_random_number` will evaluate to the same number for each call to the endpoint of this `params` block. To have the default evaluate lazily with each request use a lambda, like `:random_number` above.\n\nNote that default values will be passed through to any validation options specified.\nThe following example will always fail if `:color` is not explicitly provided.\n\n```ruby\nparams do\n  optional :color, type: String, default: 'blue', values: ['red', 'green']\nend\n```\n\nThe correct implementation is to ensure the default value passes all validations.\n\n```ruby\nparams do\n  optional :color, type: String, default: 'blue', values: ['blue', 'red', 'green']\nend\n```\n\nYou can use the value of one parameter as the default value of some other parameter. In this case, if the `primary_color` parameter is not provided, it will have the same value as the `color` one. If both of them not provided, both of them will have `blue` value.\n\n```ruby\nparams do\n  optional :color, type: String, default: 'blue'\n  optional :primary_color, type: String, default: -> (params) { params[:color] }\nend\n```\n\n### Supported Parameter Types\n\nThe following are all valid types, supported out of the box by Grape:\n\n* Integer\n* Float\n* BigDecimal\n* Numeric\n* Date\n* DateTime\n* Time\n* Boolean\n* String\n* Symbol\n* Rack::Multipart::UploadedFile (alias `File`)\n* JSON\n\n### Integer/Fixnum and Coercions\n\nPlease be aware that the behavior differs between Ruby 2.4 and earlier versions.\nIn Ruby 2.4, values consisting of numbers are converted to Integer, but in earlier versions it will be treated as Fixnum.\n\n```ruby\nparams do\n  requires :integers, type: Hash do\n    requires :int, coerce: Integer\n  end\nend\nget '/int' do\n  params[:integers][:int].class\nend\n\n...\n\nget '/int' integers: { int: '45' }\n  #=> Integer in ruby 2.4\n  #=> Fixnum in earlier ruby versions\n```\n\n### Custom Types and Coercions\n\nAside from the default set of supported types listed above, any class can be used as a type as long as an explicit coercion method is supplied. If the type implements a class-level `parse` method, Grape will use it automatically. This method must take one string argument and return an instance of the correct type, or return an instance of `Grape::Types::InvalidValue` which optionally accepts a message to be returned in the response.\n\n```ruby\nclass Color\n  attr_reader :value\n  def initialize(color)\n    @value = color\n  end\n\n  def self.parse(value)\n    return new(value) if %w[blue red green].include?(value)\n\n    Grape::Types::InvalidValue.new('Unsupported color')\n  end\nend\n\nparams do\n  requires :color, type: Color, default: Color.new('blue')\n  requires :more_colors, type: Array[Color] # Collections work\n  optional :unique_colors, type: Set[Color] # Duplicates discarded\nend\n\nget '/stuff' do\n  # params[:color] is already a Color.\n  params[:color].value\nend\n```\n\nAlternatively, a custom coercion method may be supplied for any type of parameter using `coerce_with`. Any class or object may be given that implements a `parse` or `call` method, in that order of precedence. The method must accept a single string parameter, and the return value must match the given `type`.\n\n```ruby\nparams do\n  requires :passwd, type: String, coerce_with: Base64.method(:decode64)\n  requires :loud_color, type: Color, coerce_with: ->(c) { Color.parse(c.downcase) }\n\n  requires :obj, type: Hash, coerce_with: JSON do\n    requires :words, type: Array[String], coerce_with: ->(val) { val.split(/\\s+/) }\n    optional :time, type: Time, coerce_with: Chronic\n  end\nend\n```\nNote that, a `nil` value will call the custom coercion method, while a missing parameter will not.\n\nExample of use of `coerce_with` with a lambda (a class with a `parse` method could also have been used)\nIt will parse a string and return an Array of Integers, matching the `Array[Integer]` `type`.\n\n```ruby\nparams do\n  requires :values, type: Array[Integer], coerce_with: ->(val) { val.split(/\\s+/).map(&:to_i) }\nend\n```\n\nGrape will assert that coerced values match the given `type`, and will reject the request if they do not. To override this behaviour, custom types may implement a `parsed?` method that should accept a single argument and return `true` if the value passes type validation.\n\n```ruby\nclass SecureUri\n  def self.parse(value)\n    URI.parse value\n  end\n\n  def self.parsed?(value)\n    value.is_a? URI::HTTPS\n  end\nend\n\nparams do\n  requires :secure_uri, type: SecureUri\nend\n```\n\n### Multipart File Parameters\n\nGrape makes use of `Rack::Request`'s built-in support for multipart file parameters. Such parameters can be declared with `type: File`:\n\n```ruby\nparams do\n  requires :avatar, type: File\nend\npost '/' do\n  params[:avatar][:filename] # => 'avatar.png'\n  params[:avatar][:type] # => 'image/png'\n  params[:avatar][:tempfile] # => #<File>\nend\n```\n\n### First-Class `JSON` Types\n\nGrape supports complex parameters given as JSON-formatted strings using the special `type: JSON` declaration. JSON objects and arrays of objects are accepted equally, with nested validation rules applied to all objects in either case:\n\n```ruby\nparams do\n  requires :json, type: JSON do\n    requires :int, type: Integer, values: [1, 2, 3]\n  end\nend\nget '/' do\n  params[:json].inspect\nend\n\nclient.get('/', json: '{\"int\":1}') # => \"{:int=>1}\"\nclient.get('/', json: '[{\"int\":\"1\"}]') # => \"[{:int=>1}]\"\n\nclient.get('/', json: '{\"int\":4}') # => HTTP 400\nclient.get('/', json: '[{\"int\":4}]') # => HTTP 400\n```\n\nAdditionally `type: Array[JSON]` may be used, which explicitly marks the parameter as an array of objects. If a single object is supplied it will be wrapped.\n\n```ruby\nparams do\n  requires :json, type: Array[JSON] do\n    requires :int, type: Integer\n  end\nend\nget '/' do\n  params[:json].each { |obj| ... } # always works\nend\n```\nFor stricter control over the type of JSON structure which may be supplied, use `type: Array, coerce_with: JSON` or `type: Hash, coerce_with: JSON`.\n\n### Multiple Allowed Types\n\nVariant-type parameters can be declared using the `types` option rather than `type`:\n\n```ruby\nparams do\n  requires :status_code, types: [Integer, String, Array[Integer, String]]\nend\nget '/' do\n  params[:status_code].inspect\nend\n\nclient.get('/', status_code: 'OK_GOOD') # => \"OK_GOOD\"\nclient.get('/', status_code: 300) # => 300\nclient.get('/', status_code: %w(404 NOT FOUND)) # => [404, \"NOT\", \"FOUND\"]\n```\n\nAs a special case, variant-member-type collections may also be declared, by passing a `Set` or `Array` with more than one member to `type`:\n\n```ruby\nparams do\n  requires :status_codes, type: Array[Integer,String]\nend\nget '/' do\n  params[:status_codes].inspect\nend\n\nclient.get('/', status_codes: %w(1 two)) # => [1, \"two\"]\n```\n\n### Validation of Nested Parameters\n\nParameters can be nested using `group` or by calling `requires` or `optional` with a block.\nIn the [above example](#parameter-validation-and-coercion), this means `params[:media][:url]` is required along with `params[:id]`, and `params[:audio][:format]` is required only if `params[:audio]` is present.\nWith a block, `group`, `requires` and `optional` accept an additional option `type` which can be either `Array` or `Hash`, and defaults to `Array`. Depending on the value, the nested parameters will be treated either as values of a hash or as values of hashes in an array.\n\n```ruby\nparams do\n  optional :preferences, type: Array do\n    requires :key\n    requires :value\n  end\n\n  requires :name, type: Hash do\n    requires :first_name\n    requires :last_name\n  end\nend\n```\n\n### Dependent Parameters\n\nSuppose some of your parameters are only relevant if another parameter is given; Grape allows you to express this relationship through the `given` method in your parameters block, like so:\n\n```ruby\nparams do\n  optional :shelf_id, type: Integer\n  given :shelf_id do\n    requires :bin_id, type: Integer\n  end\nend\n```\n\nIn the example above Grape will use `blank?` to check whether the `shelf_id` param is present.\n\n`given` also takes a `Proc` with custom code. Below, the param `description` is required only if the value of `category` is equal `foo`:\n\n```ruby\nparams do\n  optional :category\n  given category: ->(val) { val == 'foo' } do\n    requires :description\n  end\nend\n```\n\nYou can rename parameters:\n\n```ruby\nparams do\n  optional :category, as: :type\n  given type: ->(val) { val == 'foo' } do\n    requires :description\n  end\nend\n```\n\nNote: param in `given` should be the renamed one. In the example, it should be `type`, not `category`.\n\n### Group Options\n\nParameters options can be grouped. It can be useful if you want to extract common validation or types for several parameters.\nWithin these groups, individual parameters can extend or selectively override the common settings, allowing you to maintain the defaults at the group level while still applying parameter-specific rules where necessary.\n\nThe example below presents a typical case when parameters share common options.\n\n```ruby\nparams do\n  requires :first_name, type: String, regexp: /w+/, desc: 'First name', documentation: { in: 'body' }\n  optional :middle_name, type: String, regexp: /w+/, desc: 'Middle name', documentation: { in: 'body', x: { nullable: true } }\n  requires :last_name, type: String, regexp: /w+/, desc: 'Last name', documentation: { in: 'body' }\nend\n```\n\nGrape allows you to present the same logic through the `with` method in your parameters block, like so:\n\n```ruby\nparams do\n  with(type: String, regexp: /w+/, documentation: { in: 'body' }) do\n    requires :first_name, desc: 'First name'\n    optional :middle_name, desc: 'Middle name', documentation: { x: { nullable: true } }\n    requires :last_name, desc: 'Last name'\n  end\nend\n```\n\nYou can organize settings into layers using nested `with' blocks. Each layer can use, add to, or change the settings of the layer above it. This helps to keep complex parameters organized and consistent, while still allowing for specific customizations to be made.\n\n```ruby\nparams do\n  with(documentation: { in: 'body' }) do  # Applies documentation to all nested parameters\n    with(type: String, regexp: /\\w+/) do  # Applies type and validation to names\n      requires :first_name, desc: 'First name'\n      requires :last_name, desc: 'Last name'\n    end\n    optional :age, type: Integer, desc: 'Age', documentation: { x: { nullable: true } }  # Specific settings for 'age'\n  end\nend\n```\n\n### Renaming\n\nYou can rename parameters using `as`, which can be useful when refactoring existing APIs:\n\n```ruby\nresource :users do\n  params do\n    requires :email_address, as: :email\n    requires :password\n  end\n  post do\n    User.create!(declared(params)) # User takes email and password\n  end\nend\n```\n\nThe value passed to `as` will be the key when calling `declared(params)`.\n\n### Built-in Validators\n\n#### `allow_blank`\n\nParameters can be defined as `allow_blank`, ensuring that they contain a value. By default, `requires` only validates that a parameter was sent in the request, regardless its value. With `allow_blank: false`, empty values or whitespace only values are invalid.\n\n`allow_blank` can be combined with both `requires` and `optional`. If the parameter is required, it has to contain a value. If it's optional, it's possible to not send it in the request, but if it's being sent, it has to have some value, and not an empty string/only whitespaces.\n\n\n```ruby\nparams do\n  requires :username, allow_blank: false\n  optional :first_name, allow_blank: false\nend\n```\n\n#### `values`\n\nParameters can be restricted to a specific set of values with the `:values` option.\n\n\n```ruby\nparams do\n  requires :status, type: Symbol, values: [:not_started, :processing, :done]\n  optional :numbers, type: Array[Integer], default: 1, values: [1, 2, 3, 5, 8]\nend\n```\n\nSupplying a range to the `:values` option ensures that the parameter is (or parameters are) included in that range (using `Range#include?`).\n\n```ruby\nparams do\n  requires :latitude, type: Float, values: -90.0..+90.0\n  requires :longitude, type: Float, values: -180.0..+180.0\n  optional :letters, type: Array[String], values: 'a'..'z'\nend\n```\n\nNote endless ranges are also supported with ActiveSupport >= 6.0, but they require that the type be provided.\n\n```ruby\nparams do\n  requires :minimum, type: Integer, values: 10..\n  optional :maximum, type: Integer, values: ..10\nend\n```\n\nNote that *both* range endpoints have to be a `#kind_of?` your `:type` option (if you don't supply the `:type` option, it will be guessed to be equal to the class of the range's first endpoint). So the following is invalid:\n\n```ruby\nparams do\n  requires :invalid1, type: Float, values: 0..10 # 0.kind_of?(Float) => false\n  optional :invalid2, values: 0..10.0 # 10.0.kind_of?(0.class) => false\nend\n```\n\nThe `:values` option can also be supplied with a `Proc`, evaluated lazily with each request.\nIf the Proc has arity zero (i.e. it takes no arguments) it is expected to return either a list or a range which will then be used to validate the parameter.\n\nFor example, given a status model you may want to restrict by hashtags that you have previously defined in the `HashTag` model.\n\n```ruby\nparams do\n  requires :hashtag, type: String, values: -> { Hashtag.all.map(&:tag) }\nend\n```\n\nAlternatively, a Proc with arity one (i.e. taking one argument) can be used to explicitly validate each parameter value.  In that case, the Proc is expected to return a truthy value if the parameter value is valid. The parameter will be considered invalid if the Proc returns a falsy value or if it raises a StandardError.\n\n```ruby\nparams do\n  requires :number, type: Integer, values: ->(v) { v.even? && v < 25 }\nend\n```\n\nWhile Procs are convenient for single cases, consider using [Custom Validators](#custom-validators) in cases where a validation is used more than once.\n\nNote that [allow_blank](#allow_blank) validator applies while using `:values`. In the following example the absence of `:allow_blank` does not prevent `:state` from receiving blank values because `:allow_blank` defaults to `true`.\n\n```ruby\nparams do\n  requires :state, type: Symbol, values: [:active, :inactive]\nend\n```\n\n#### `except_values`\n\nParameters can be restricted from having a specific set of values with the `:except_values` option.\n\nThe `except_values` validator behaves similarly to the `values` validator in that it accepts either an Array, a Range, or a Proc.  Unlike the `values` validator, however, `except_values` only accepts Procs with arity zero.\n\n```ruby\nparams do\n  requires :browser, except_values: [ 'ie6', 'ie7', 'ie8' ]\n  requires :port, except_values: { value: 0..1024, message: 'is not allowed' }\n  requires :hashtag, except_values: -> { Hashtag.FORBIDDEN_LIST }\nend\n```\n\n#### `same_as`\n\nA `same_as` option can be given to ensure that values of parameters match.\n\n```ruby\nparams do\n  requires :password\n  requires :password_confirmation, same_as: :password\nend\n```\n\n#### `length`\n\nParameters with types that support `#length` method can be restricted to have a specific length with the `:length` option.\n\nThe validator accepts `:min` or `:max` or both options or only `:is` to validate that the value of the parameter is within the given limits.\n\n```ruby\nparams do\n  requires :code, type: String, length: { is: 2 }\n  requires :str, type: String, length: { min: 3 }\n  requires :list, type: [Integer], length: { min: 3, max: 5 }\n  requires :hash, type: Hash, length: { max: 5 }\nend\n```\n\n#### `regexp`\n\nParameters can be restricted to match a specific regular expression with the `:regexp` option. If the value does not match the regular expression an error will be returned. Note that this is true for both `requires` and `optional` parameters.\n\n```ruby\nparams do\n  requires :email, regexp: /.+@.+/\nend\n```\n\nThe validator will pass if the parameter was sent without value. To ensure that the parameter contains a value, use `allow_blank: false`.\n\n```ruby\nparams do\n  requires :email, allow_blank: false, regexp: /.+@.+/\nend\n```\n\n#### `mutually_exclusive`\n\nParameters can be defined as `mutually_exclusive`, ensuring that they aren't present at the same time in a request.\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  mutually_exclusive :beer, :wine\nend\n```\n\nMultiple sets can be defined:\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  mutually_exclusive :beer, :wine\n  optional :scotch\n  optional :aquavit\n  mutually_exclusive :scotch, :aquavit\nend\n```\n\n**Warning**: Never define mutually exclusive sets with any required params. Two mutually exclusive required params will mean params are never valid, thus making the endpoint useless. One required param mutually exclusive with an optional param will mean the latter is never valid.\n\n#### `exactly_one_of`\n\nParameters can be defined as 'exactly_one_of', ensuring that exactly one parameter gets selected.\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  exactly_one_of :beer, :wine\nend\n```\n\nNote that using `:default` with `mutually_exclusive` will cause multiple parameters to always have a default value and raise a `Grape::Exceptions::Validation` mutually exclusive exception.\n\n#### `at_least_one_of`\n\nParameters can be defined as 'at_least_one_of', ensuring that at least one parameter gets selected.\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  at_least_one_of :beer, :wine, :juice\nend\n```\n\n#### `all_or_none_of`\n\nParameters can be defined as 'all_or_none_of', ensuring that all or none of parameters gets selected.\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  all_or_none_of :beer, :wine, :juice\nend\n```\n\n#### Nested `mutually_exclusive`, `exactly_one_of`, `at_least_one_of`, `all_or_none_of`\n\nAll of these methods can be used at any nested level.\n\n```ruby\nparams do\n  requires :food, type: Hash do\n    optional :meat\n    optional :fish\n    optional :rice\n    at_least_one_of :meat, :fish, :rice\n  end\n  group :drink, type: Hash do\n    optional :beer\n    optional :wine\n    optional :juice\n    exactly_one_of :beer, :wine, :juice\n  end\n  optional :dessert, type: Hash do\n    optional :cake\n    optional :icecream\n    mutually_exclusive :cake, :icecream\n  end\n  optional :recipe, type: Hash do\n    optional :oil\n    optional :meat\n    all_or_none_of :oil, :meat\n  end\nend\n```\n\n### Namespace Validation and Coercion\n\nNamespaces allow parameter definitions and apply to every method within the namespace.\n\n```ruby\nnamespace :statuses do\n  params do\n    requires :user_id, type: Integer, desc: 'A user ID.'\n  end\n  namespace ':user_id' do\n    desc \"Retrieve a user's status.\"\n    params do\n      requires :status_id, type: Integer, desc: 'A status ID.'\n    end\n    get ':status_id' do\n      User.find(params[:user_id]).statuses.find(params[:status_id])\n    end\n  end\nend\n```\n\nThe `namespace` method has a number of aliases, including: `group`, `resource`, `resources`, and `segment`. Use whichever reads the best for your API.\n\nYou can conveniently define a route parameter as a namespace using `route_param`.\n\n```ruby\nnamespace :statuses do\n  route_param :id do\n    desc 'Returns all replies for a status.'\n    get 'replies' do\n      Status.find(params[:id]).replies\n    end\n    desc 'Returns a status.'\n    get do\n      Status.find(params[:id])\n    end\n  end\nend\n```\n\nYou can also define a route parameter type by passing to `route_param`'s options.\n\n```ruby\nnamespace :arithmetic do\n  route_param :n, type: Integer do\n    desc 'Returns in power'\n    get 'power' do\n      params[:n] ** params[:n]\n    end\n  end\nend\n```\n\n### Custom Validators\n\n```ruby\nclass AlphaNumeric < Grape::Validations::Validators::Base\n  def validate_param!(attr_name, params)\n    unless params[attr_name] =~ /\\A[[:alnum:]]+\\z/\n      raise Grape::Exceptions::Validation.new params: [@scope.full_name(attr_name)], message: 'must consist of alpha-numeric characters'\n    end\n  end\nend\n```\n\n```ruby\nparams do\n  requires :text, alpha_numeric: true\nend\n```\n\nYou can also create custom classes that take parameters.\n\n```ruby\nclass Length < Grape::Validations::Validators::Base\n  def validate_param!(attr_name, params)\n    unless params[attr_name].length <= @option\n      raise Grape::Exceptions::Validation.new params: [@scope.full_name(attr_name)], message: \"must be at the most #{@option} characters long\"\n    end\n  end\nend\n```\n\n```ruby\nparams do\n  requires :text, length: 140\nend\n```\n\nYou can also create custom validation that use request to validate the attribute. For example if you want to have parameters that are available to only admins, you can do the following.\n\n```ruby\nclass Admin < Grape::Validations::Validators::Base\n  def validate(request)\n    # return if the param we are checking was not in request\n    # @attrs is a list containing the attribute we are currently validating\n    # in our sample case this method once will get called with\n    # @attrs being [:admin_field] and once with @attrs being [:admin_false_field]\n    return unless request.params.key?(@attrs.first)\n    # check if admin flag is set to true\n    return unless @option\n    # check if user is admin or not\n    # as an example get a token from request and check if it's admin or not\n    raise Grape::Exceptions::Validation.new params: @attrs, message: 'Can not set admin-only field.' unless request.headers['X-Access-Token'] == 'admin'\n  end\nend\n```\n\nAnd use it in your endpoint definition as:\n\n```ruby\nparams do\n  optional :admin_field, type: String, admin: true\n  optional :non_admin_field, type: String\n  optional :admin_false_field, type: String, admin: false\nend\n```\n\nEvery validation will have its own instance of the validator, which means that the validator can have a state.\n\n### Validation Errors\n\nValidation and coercion errors are collected and an exception of type `Grape::Exceptions::ValidationErrors` is raised. If the exception goes uncaught it will respond with a status of 400 and an error message. The validation errors are grouped by parameter name and can be accessed via `Grape::Exceptions::ValidationErrors#errors`.\n\n\nThe default response from a `Grape::Exceptions::ValidationErrors` is a humanly readable string, such as \"beer, wine are mutually exclusive\", in the following example.\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  exactly_one_of :beer, :wine, :juice\nend\n```\n\nYou can rescue a `Grape::Exceptions::ValidationErrors` and respond with a custom response or turn the response into well-formatted JSON for a JSON API that separates individual parameters and the corresponding error messages. The following `rescue_from` example produces `[{\"params\":[\"beer\",\"wine\"],\"messages\":[\"are mutually exclusive\"]}]`.\n\n```ruby\nformat :json\nsubject.rescue_from Grape::Exceptions::ValidationErrors do |e|\n  error! e, 400\nend\n```\n\n`Grape::Exceptions::ValidationErrors#full_messages` returns the validation messages as an array. `Grape::Exceptions::ValidationErrors#message` joins the messages to one string.\n\nFor responding with an array of validation messages, you can use `Grape::Exceptions::ValidationErrors#full_messages`.\n```ruby\nformat :json\nsubject.rescue_from Grape::Exceptions::ValidationErrors do |e|\n  error!({ messages: e.full_messages }, 400)\nend\n```\n\nGrape returns all validation and coercion errors found by default.\nTo skip all subsequent validation checks when a specific param is found invalid, use `fail_fast: true`.\n\nThe following example will not check if `:wine` is present unless it finds `:beer`.\n```ruby\nparams do\n  required :beer, fail_fast: true\n  required :wine\nend\n```\nThe result of empty params would be a single `Grape::Exceptions::ValidationErrors` error.\n\nSimilarly, no regular expression test will be performed if `:blah` is blank in the following example.\n```ruby\nparams do\n  required :blah, allow_blank: false, regexp: /blah/, fail_fast: true\nend\n```\n\n### I18n\n\nGrape supports I18n for parameter-related error messages, but will fallback to English if translations for the default locale have not been provided. See [en.yml](lib/grape/locale/en.yml) for message keys.\n\nIn case your app enforces available locales only and :en is not included in your available locales, Grape cannot fall back to English and will return the translation key for the error message. To avoid this behaviour, either provide a translation for your default locale or add :en to your available locales.\n\n### Custom Validation messages\n\nGrape supports custom validation messages for parameter-related and coerce-related error messages.\n\n#### `presence`, `allow_blank`, `values`, `regexp`\n\n```ruby\nparams do\n  requires :name, values: { value: 1..10, message: 'not in range from 1 to 10' }, allow_blank: { value: false, message: 'cannot be blank' }, regexp: { value: /^[a-z]+$/, message: 'format is invalid' }, message: 'is required'\nend\n```\n\n#### `same_as`\n\n```ruby\nparams do\n  requires :password\n  requires :password_confirmation, same_as: { value: :password, message: 'not match' }\nend\n```\n\n#### `length`\n\n```ruby\nparams do\n  requires :code, type: String, length: { is: 2, message: 'code is expected to be exactly 2 characters long' }\n  requires :str, type: String, length: { min: 5, message: 'str is expected to be at least 5 characters long' }\n  requires :list, type: [Integer], length: { min: 2, max: 3, message: 'list is expected to have between 2 and 3 elements' }\nend\n```\n\n#### `all_or_none_of`\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  all_or_none_of :beer, :wine, :juice, message: \"all params are required or none is required\"\nend\n```\n\n#### `mutually_exclusive`\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  mutually_exclusive :beer, :wine, :juice, message: \"are mutually exclusive cannot pass both params\"\nend\n```\n\n#### `exactly_one_of`\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  exactly_one_of :beer, :wine, :juice, message: { exactly_one: \"are missing, exactly one parameter is required\", mutual_exclusion: \"are mutually exclusive, exactly one parameter is required\" }\nend\n```\n\n#### `at_least_one_of`\n\n```ruby\nparams do\n  optional :beer\n  optional :wine\n  optional :juice\n  at_least_one_of :beer, :wine, :juice, message: \"are missing, please specify at least one param\"\nend\n```\n\n#### `Coerce`\n\n```ruby\nparams do\n  requires :int, type: { value: Integer, message: \"type cast is invalid\" }\nend\n```\n\n#### `With Lambdas`\n\n```ruby\nparams do\n  requires :name, values: { value: -> { (1..10).to_a }, message: 'not in range from 1 to 10' }\nend\n```\n\n#### `Pass symbols for i18n translations`\n\nYou can pass a symbol if you want i18n translations for your custom validation messages.\n\n```ruby\nparams do\n  requires :name, message: :name_required\nend\n```\n```ruby\n# en.yml\n\nen:\n  grape:\n    errors:\n      format: ! '%{attributes} %{message}'\n      messages:\n        name_required: 'must be present'\n```\n\n#### Overriding Attribute Names\n\nYou can also override attribute names.\n\n```ruby\n# en.yml\n\nen:\n  grape:\n    errors:\n      format: ! '%{attributes} %{message}'\n      messages:\n        name_required: 'must be present'\n      attributes:\n        name: 'Oops! Name'\n```\nWill produce 'Oops! Name must be present'\n\n#### With Default\n\nYou cannot set a custom message option for Default as it requires interpolation `%{option1}: %{value1} is incompatible with %{option2}: %{value2}`. You can change the default error message for Default by changing the `incompatible_option_values` message key inside [en.yml](lib/grape/locale/en.yml)\n\n```ruby\nparams do\n  requires :name, values: { value: -> { (1..10).to_a }, message: 'not in range from 1 to 10' }, default: 5\nend\n```\n\n### Using `dry-validation` or `dry-schema`\n\nAs an alternative to the `params` DSL described above, you can use a schema or `dry-validation` contract to describe an endpoint's parameters. This can be especially useful if you use the above already in some other parts of your application. If not, you'll need to add `dry-validation` or `dry-schema` to your `Gemfile`.\n\nThen call `contract` with a contract or schema defined previously:\n\n```rb\nCreateOrdersSchema = Dry::Schema.Params do\n  required(:orders).array(:hash) do\n    required(:name).filled(:string)\n    optional(:volume).maybe(:integer, lt?: 9)\n  end\nend\n\n# ...\n\ncontract CreateOrdersSchema\n```\n\nor with a block, using the [schema definition syntax](https://dry-rb.org/gems/dry-schema/1.13/#quick-start):\n\n```rb\ncontract do\n  required(:orders).array(:hash) do\n    required(:name).filled(:string)\n    optional(:volume).maybe(:integer, lt?: 9)\n  end\nend\n```\n\nThe latter will define a coercing schema (`Dry::Schema.Params`). When using the former approach, it's up to you to decide whether the input will need coercing.\n\nThe `params` and `contract` declarations can also be used together in the same API, e.g. to describe different parts of a nested namespace for an endpoint.\n\n## Headers\n\n### Request\nRequest headers are available through the `headers` helper or from `env` in their original form.\n\n```ruby\nget do\n  error!('Unauthorized', 401) unless headers['Secret-Password'] == 'swordfish'\nend\n```\n\n```ruby\nget do\n  error!('Unauthorized', 401) unless env['HTTP_SECRET_PASSWORD'] == 'swordfish'\nend\n```\n\n#### Header Case Handling\n\nThe above example may have been requested as follows:\n\n``` shell\ncurl -H \"secret_PassWord: swordfish\" ...\n```\n\nThe header name will have been normalized for you.\n\n- In the `header` helper names will be coerced into a downcased kebab case as `secret-password` if using Rack 3.\n- In the `header` helper names will be coerced into a capitalized kebab case as `Secret-PassWord` if using Rack < 3.\n- In the `env` collection they appear in all uppercase, in snake case, and prefixed with 'HTTP_' as `HTTP_SECRET_PASSWORD`\n\nThe header name will have been normalized per HTTP standards defined in [RFC2616 Section 4.2](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2) regardless of what is being sent by a client.\n\n### Response\n\nYou can set a response header with `header` inside an API.\n\n```ruby\nheader 'X-Robots-Tag', 'noindex'\n```\n\nWhen raising `error!`, pass additional headers as arguments. Additional headers will be merged with headers set before `error!` call.\n\n```ruby\nerror! 'Unauthorized', 401, 'X-Error-Detail' => 'Invalid token.'\n```\n\n## Routes\n\nTo define routes you can use the `route` method or the shorthands for the HTTP verbs. To define a route that accepts any route set to `:any`.\nParts of the path that are denoted with a colon will be interpreted as route parameters.\n\n```ruby\nroute :get, 'status' do\nend\n\n# is the same as\n\nget 'status' do\nend\n\n# is the same as\n\nget :status do\nend\n\n# is NOT the same as\n\nget ':status' do # this makes params[:status] available\nend\n\n# This will make both params[:status_id] and params[:id] available\n\nget 'statuses/:status_id/reviews/:id' do\nend\n```\n\nTo declare a namespace that prefixes all routes within, use the `namespace` method. `group`, `resource`, `resources` and `segment` are aliases to this method. Any endpoints within will share their parent context as well as any configuration done in the namespace context.\n\nThe `route_param` method is a convenient method for defining a parameter route segment. If you define a type, it will add a validation for this parameter.\n\n```ruby\nroute_param :id, type: Integer do\n  get 'status' do\n  end\nend\n\n# is the same as\n\nnamespace ':id' do\n  params do\n    requires :id, type: Integer\n  end\n\n  get 'status' do\n  end\nend\n```\n\nOptionally, you can define requirements for your named route parameters using regular expressions on namespace or endpoint. The route will match only if all requirements are met.\n\n```ruby\nget ':id', requirements: { id: /[0-9]*/ } do\n  Status.find(params[:id])\nend\n\nnamespace :outer, requirements: { id: /[0-9]*/ } do\n  get :id do\n  end\n\n  get ':id/edit' do\n  end\nend\n```\n\n## Helpers\n\nYou can define helper methods that your endpoints can use with the `helpers` macro by either giving a block or an array of modules.\n\n```ruby\nmodule StatusHelpers\n  def user_info(user)\n    \"#{user} has statused #{user.statuses} status(s)\"\n  end\nend\n\nmodule HttpCodesHelpers\n  def unauthorized\n    401\n  end\nend\n\nclass API < Grape::API\n  # define helpers with a block\n  helpers do\n    def current_user\n      User.find(params[:user_id])\n    end\n  end\n\n  # or mix in an array of modules\n  helpers StatusHelpers, HttpCodesHelpers\n\n  before do\n    error!('Access Denied', unauthorized) unless current_user\n  end\n\n  get 'info' do\n    # helpers available in your endpoint and filters\n    user_info(current_user)\n  end\nend\n```\n\nYou can define reusable `params` using `helpers`.\n\n```ruby\nclass API < Grape::API\n  helpers do\n    params :pagination do\n      optional :page, type: Integer\n      optional :per_page, type: Integer\n    end\n  end\n\n  desc 'Get collection'\n  params do\n    use :pagination # aliases: includes, use_scope\n  end\n  get do\n    Collection.page(params[:page]).per(params[:per_page])\n  end\nend\n```\n\nYou can also define reusable `params` using shared helpers.\n\n```ruby\nmodule SharedParams\n  extend Grape::API::Helpers\n\n  params :period do\n    optional :start_date\n    optional :end_date\n  end\n\n  params :pagination do\n    optional :page, type: Integer\n    optional :per_page, type: Integer\n  end\nend\n\nclass API < Grape::API\n  helpers SharedParams\n\n  desc 'Get collection.'\n  params do\n    use :period, :pagination\n  end\n\n  get do\n    Collection\n      .from(params[:start_date])\n      .to(params[:end_date])\n      .page(params[:page])\n      .per(params[:per_page])\n  end\nend\n```\n\nHelpers support blocks that can help set default values. The following API can return a collection sorted by `id` or `created_at` in `asc` or `desc` order.\n\n```ruby\nmodule SharedParams\n  extend Grape::API::Helpers\n\n  params :order do |options|\n    optional :order_by, type: Symbol, values: options[:order_by], default: options[:default_order_by]\n    optional :order, type: Symbol, values: %i(asc desc), default: options[:default_order]\n  end\nend\n\nclass API < Grape::API\n  helpers SharedParams\n\n  desc 'Get a sorted collection.'\n  params do\n    use :order, order_by: %i(id created_at), default_order_by: :created_at, default_order: :asc\n  end\n\n  get do\n    Collection.send(params[:order], params[:order_by])\n  end\nend\n```\n\n## Path Helpers\n\nIf you need methods for generating paths inside your endpoints, please see the [grape-route-helpers](https://github.com/reprah/grape-route-helpers) gem.\n\n## Parameter Documentation\n\nYou can attach additional documentation to `params` using a `documentation` hash.\n\n```ruby\nparams do\n  optional :first_name, type: String, documentation: { example: 'Jim' }\n  requires :last_name, type: String, documentation: { example: 'Smith' }\nend\n```\n\nIf documentation isn't needed (for instance, it is an internal API), documentation can be disabled.\n\n```ruby\nclass API < Grape::API\n  do_not_document!\n\n  # endpoints...\nend\n```\n\nIn this case, Grape won't create objects related to documentation which are retained in RAM forever.\n\n## Cookies\n\nYou can set, get and delete your cookies very simply using `cookies` method.\n\n```ruby\nclass API < Grape::API\n  get 'status_count' do\n    cookies[:status_count] ||= 0\n    cookies[:status_count] += 1\n    { status_count: cookies[:status_count] }\n  end\n\n  delete 'status_count' do\n    { status_count: cookies.delete(:status_count) }\n  end\nend\n```\n\nUse a hash-based syntax to set more than one value.\n\n```ruby\ncookies[:status_count] = {\n  value: 0,\n  expires: Time.tomorrow,\n  domain: '.twitter.com',\n  path: '/'\n}\n\ncookies[:status_count][:value] +=1\n```\n\nDelete a cookie with `delete`.\n\n```ruby\ncookies.delete :status_count\n```\n\nSpecify an optional path.\n\n```ruby\ncookies.delete :status_count, path: '/'\n```\n\n## HTTP Status Code\n\nBy default Grape returns a 201 for `POST`-Requests, 204 for `DELETE`-Requests that don't return any content, and 200 status code for all other Requests.\nYou can use `status` to query and set the actual HTTP Status Code\n\n```ruby\npost do\n  status 202\n\n  if status == 200\n     # do some thing\n  end\nend\n```\n\nYou can also use one of status codes symbols that are provided by [Rack utils](http://www.rubydoc.info/github/rack/rack/Rack/Utils#HTTP_STATUS_CODES-constant)\n\n```ruby\npost do\n  status :no_content\nend\n```\n\n## Redirecting\n\nYou can redirect to a new url temporarily (302) or permanently (301).\n\n```ruby\nredirect '/statuses'\n```\n\n```ruby\nredirect '/statuses', permanent: true\n```\n\n## Recognizing Path\n\nYou can recognize the endpoint matched with given path.\n\nThis API returns an instance of `Grape::Endpoint`.\n\n```ruby\nclass API < Grape::API\n  get '/statuses' do\n  end\nend\n\nAPI.recognize_path '/statuses'\n```\n\nSince version `2.1.0`, the `recognize_path` method takes into account the parameters type to determine which endpoint should match with given path.\n\n```ruby\nclass Books < Grape::API\n  resource :books do\n    route_param :id, type: Integer do\n      # GET /books/:id\n      get do\n        #...\n      end\n    end\n\n    resource :share do\n      # POST /books/share\n      post do\n      # ....\n      end\n    end\n  end\nend\n\nAPI.recognize_path '/books/1' # => /books/:id\nAPI.recognize_path '/books/share' # => /books/share\nAPI.recognize_path '/books/other' # => nil\n```\n\n\n## Allowed Methods\n\nWhen you add a `GET` route for a resource, a route for the `HEAD` method will also be added automatically. You can disable this behavior with `do_not_route_head!`.\n\n``` ruby\nclass API < Grape::API\n  do_not_route_head!\n\n  get '/example' do\n    # only responds to GET\n  end\nend\n```\n\nWhen you add a route for a resource, a route for the `OPTIONS` method will also be added. The response to an OPTIONS request will include an \"Allow\" header listing the supported methods. If the resource has `before` and `after` callbacks they will be executed, but no other callbacks will run.\n\n```ruby\nclass API < Grape::API\n  get '/rt_count' do\n    { rt_count: current_user.rt_count }\n  end\n\n  params do\n    requires :value, type: Integer, desc: 'Value to add to the rt count.'\n  end\n  put '/rt_count' do\n    current_user.rt_count += params[:value].to_i\n    { rt_count: current_user.rt_count }\n  end\nend\n```\n\n``` shell\ncurl -v -X OPTIONS http://localhost:3000/rt_count\n\n> OPTIONS /rt_count HTTP/1.1\n>\n< HTTP/1.1 204 No Content\n< Allow: OPTIONS, GET, PUT\n```\n\nYou can disable this behavior with `do_not_route_options!`.\n\nIf a request for a resource is made with an unsupported HTTP method, an HTTP 405 (Method Not Allowed) response will be returned. If the resource has `before` callbacks they will be executed, but no other callbacks will run.\n\n``` shell\ncurl -X DELETE -v http://localhost:3000/rt_count/\n\n> DELETE /rt_count/ HTTP/1.1\n> Host: localhost:3000\n>\n< HTTP/1.1 405 Method Not Allowed\n< Allow: OPTIONS, GET, PUT\n```\n\n## Raising Exceptions\n\nYou can abort the execution of an API method by raising errors with `error!`.\n\n```ruby\nerror! 'Access Denied', 401\n```\n\nAnything that responds to `#to_s` can be given as a first argument to `error!`.\n\n```ruby\nerror! :not_found, 404\n```\n\nYou can also return JSON formatted objects by raising error! and passing a hash instead of a message.\n\n```ruby\nerror!({ error: 'unexpected error', detail: 'missing widget' }, 500)\n```\n\nYou can set additional headers for the response. They will be merged with headers set before `error!` call.\n\n```ruby\nerror!('Something went wrong', 500, 'X-Error-Detail' => 'Invalid token.')\n```\n\nYou can present documented errors with a Grape entity using the the [grape-entity](https://github.com/ruby-grape/grape-entity) gem.\n\n```ruby\nmodule API\n  class Error < Grape::Entity\n    expose :code\n    expose :message\n  end\nend\n```\n\nThe following example specifies the entity to use in the `http_codes` definition.\n\n```ruby\ndesc 'My Route' do\n failure [[408, 'Unauthorized', API::Error]]\nend\nerror!({ message: 'Unauthorized' }, 408)\n```\n\nThe following example specifies the presented entity explicitly in the error message.\n\n```ruby\ndesc 'My Route' do\n failure [[408, 'Unauthorized']]\nend\nerror!({ message: 'Unauthorized', with: API::Error }, 408)\n```\n\n### Default Error HTTP Status Code\n\nBy default Grape returns a 500 status code from `error!`. You can change this with `default_error_status`.\n\n``` ruby\nclass API < Grape::API\n  default_error_status 400\n  get '/example' do\n    error! 'This should have http status code 400'\n  end\nend\n```\n\n### Handling 404\n\nFor Grape to handle all the 404s for your API, it can be useful to use a catch-all.\nIn its simplest form, it can be like:\n\n```ruby\nroute :any, '*path' do\n  error! # or something else\nend\n```\n\nIt is very crucial to __define this endpoint at the very end of your API__, as it literally accepts every request.\n\n## Exception Handling\n\nGrape can be told to rescue all `StandardError` exceptions and return them in the API format.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from :all\nend\n```\n\nThis mimics [default `rescue` behaviour](https://ruby-doc.org/core/StandardError.html) when an exception type is not provided.\nAny other exception should be rescued explicitly, see [below](#exceptions-that-should-be-rescued-explicitly).\n\nGrape can also rescue from all exceptions and still use the built-in exception handing.\nThis will give the same behavior as `rescue_from :all` with the addition that Grape will use the exception handling defined by all Exception classes that inherit `Grape::Exceptions::Base`.\n\nThe intent of this setting is to provide a simple way to cover the most common exceptions and return any unexpected exceptions in the API format.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from :grape_exceptions\nend\n```\n\nIf you want to customize the shape of grape exceptions returned to the user, to match your `:all` handler for example, you can pass a block to `rescue_from :grape_exceptions`.\n\n```ruby\nrescue_from :grape_exceptions do |e|\n  error!(e, e.status)\nend\n```\n\nYou can also rescue specific exceptions.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from ArgumentError, UserDefinedError\nend\n```\n\nIn this case ```UserDefinedError``` must be inherited from ```StandardError```.\n\nNotice that you could combine these two approaches (rescuing custom errors takes precedence). For example, it's useful for handling all exceptions except Grape validation errors.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from Grape::Exceptions::ValidationErrors do |e|\n    error!(e, 400)\n  end\n\n  rescue_from :all\nend\n```\n\nThe error format will match the request format. See \"Content-Types\" below.\n\nCustom error formatters for existing and additional types can be defined with a proc.\n\n```ruby\nclass Twitter::API < Grape::API\n  error_formatter :txt, ->(message, backtrace, options, env, original_exception) {\n    \"error: #{message} from #{backtrace}\"\n  }\nend\n```\n\nYou can also use a module or class.\n\n```ruby\nmodule CustomFormatter\n  def self.call(message, backtrace, options, env, original_exception)\n    { message: message, backtrace: backtrace }\n  end\nend\n\nclass Twitter::API < Grape::API\n  error_formatter :custom, CustomFormatter\nend\n```\n\nYou can rescue all exceptions with a code block. The `error!` wrapper automatically sets the default error code and content-type.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from :all do |e|\n    error!(\"rescued from #{e.class.name}\")\n  end\nend\n```\n\nOptionally, you can set the format, status code and headers.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\n  rescue_from :all do |e|\n    error!({ error: 'Server error.' }, 500, { 'Content-Type' => 'text/error' })\n  end\nend\n```\n\nYou can also rescue all exceptions with a code block and handle the Rack response at the lowest level.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from :all do |e|\n    Rack::Response.new([ e.message ], 500, { 'Content-type' => 'text/error' })\n  end\nend\n```\n\nOr rescue specific exceptions.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from ArgumentError do |e|\n    error!(\"ArgumentError: #{e.message}\")\n  end\n\n  rescue_from NoMethodError do |e|\n    error!(\"NoMethodError: #{e.message}\")\n  end\nend\n```\n\nBy default, `rescue_from` will rescue the exceptions listed and all their subclasses.\n\nAssume you have the following exception classes defined.\n\n```ruby\nmodule APIErrors\n  class ParentError < StandardError; end\n  class ChildError < ParentError; end\nend\n```\n\nThen the following `rescue_from` clause will rescue exceptions of type `APIErrors::ParentError` and its subclasses (in this case `APIErrors::ChildError`).\n\n```ruby\nrescue_from APIErrors::ParentError do |e|\n    error!({\n      error: \"#{e.class} error\",\n      message: e.message\n    }, e.status)\nend\n```\n\nTo only rescue the base exception class, set `rescue_subclasses: false`.\nThe code below will rescue exceptions of type `RuntimeError` but _not_ its subclasses.\n\n```ruby\nrescue_from RuntimeError, rescue_subclasses: false do |e|\n    error!({\n      status: e.status,\n      message: e.message,\n      errors: e.errors\n    }, e.status)\nend\n```\n\nHelpers are also available inside `rescue_from`.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\n  helpers do\n    def server_error!\n      error!({ error: 'Server error.' }, 500, { 'Content-Type' => 'text/error' })\n    end\n  end\n\n  rescue_from :all do |e|\n    server_error!\n  end\nend\n```\n\nThe `rescue_from` handler must return a `Rack::Response` object, call `error!`, or raise an exception (either the original exception or another custom one). The exception raised in `rescue_from` will be handled outside Grape. For example, if you mount Grape in Rails, the exception will be handle by [Rails Action Controller](https://guides.rubyonrails.org/action_controller_overview.html#rescue).\n\nAlternately, use the `with` option in `rescue_from` to specify a method or a `proc`.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\n  helpers do\n    def server_error!\n      error!({ error: 'Server error.' }, 500, { 'Content-Type' => 'text/error' })\n    end\n  end\n\n  rescue_from :all,          with: :server_error!\n  rescue_from ArgumentError, with: -> { Rack::Response.new('rescued with a method', 400) }\nend\n```\n\nInside the `rescue_from` block, the environment of the original controller method(`.self` receiver) is accessible through the `#context` method.\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from :all do |e|\n    user_id = context.params[:user_id]\n    error!(\"error for #{user_id}\")\n  end\nend\n```\n\n#### Rescuing exceptions inside namespaces\n\nYou could put `rescue_from` clauses inside a namespace and they will take precedence over ones\ndefined in the root scope:\n\n```ruby\nclass Twitter::API < Grape::API\n  rescue_from ArgumentError do |e|\n    error!(\"outer\")\n  end\n\n  namespace :statuses do\n    rescue_from ArgumentError do |e|\n      error!(\"inner\")\n    end\n    get do\n      raise ArgumentError.new\n    end\n  end\nend\n```\n\nHere `'inner'` will be result of handling occurred `ArgumentError`.\n\n#### Unrescuable Exceptions\n\n`Grape::Exceptions::InvalidVersionHeader`, which is raised when the version in the request header doesn't match the currently evaluated version for the endpoint, will _never_ be rescued from a `rescue_from` block (even a `rescue_from :all`) This is because Grape relies on Rack to catch that error and try the next versioned-route for cases where there exist identical Grape endpoints with different versions.\n\n#### Exceptions that should be rescued explicitly\n\nAny exception that is not subclass of `StandardError` should be rescued explicitly.\nUsually it is not a case for an application logic as such errors point to problems in Ruby runtime.\nThis is following [standard recommendations for exceptions handling](https://ruby-doc.org/core/Exception.html).\n\n## Logging\n\n`Grape::API` provides a `logger` method which by default will return an instance of the `Logger` class from Ruby's standard library.\n\nTo log messages from within an endpoint, you need to define a helper to make the logger available in the endpoint context.\n\n```ruby\nclass API < Grape::API\n  helpers do\n    def logger\n      API.logger\n    end\n  end\n  post '/statuses' do\n    logger.info \"#{current_user} has statused\"\n  end\nend\n```\n\nTo change the logger level.\n\n```ruby\nclass API < Grape::API\n  self.logger.level = Logger::INFO\nend\n```\n\nYou can also set your own logger.\n\n```ruby\nclass MyLogger\n  def warning(message)\n    puts \"this is a warning: #{message}\"\n  end\nend\n\nclass API < Grape::API\n  logger MyLogger.new\n  helpers do\n    def logger\n      API.logger\n    end\n  end\n  get '/statuses' do\n    logger.warning \"#{current_user} has statused\"\n  end\nend\n```\n\nFor similar to Rails request logging try the [grape_logging](https://github.com/aserafin/grape_logging) or [grape-middleware-logger](https://github.com/ridiculous/grape-middleware-logger) gems.\n\n## API Formats\n\nYour API can declare which content-types to support by using `content_type`. If you do not specify any, Grape will support _XML_, _JSON_, _BINARY_, and _TXT_ content-types. The default format is `:txt`; you can change this with `default_format`. Essentially, the two APIs below are equivalent.\n\n```ruby\nclass Twitter::API < Grape::API\n  # no content_type declarations, so Grape uses the defaults\nend\n\nclass Twitter::API < Grape::API\n  # the following declarations are equivalent to the defaults\n\n  content_type :xml, 'application/xml'\n  content_type :json, 'application/json'\n  content_type :binary, 'application/octet-stream'\n  content_type :txt, 'text/plain'\n\n  default_format :txt\nend\n```\n\nIf you declare any `content_type` whatsoever, the Grape defaults will be overridden. For example, the following API will only support the `:xml` and `:rss` content-types, but not `:txt`, `:json`, or `:binary`. Importantly, this means the `:txt` default format is not supported! So, make sure to set a new `default_format`.\n\n```ruby\nclass Twitter::API < Grape::API\n  content_type :xml, 'application/xml'\n  content_type :rss, 'application/xml+rss'\n\n  default_format :xml\nend\n```\n\nSerialization takes place automatically. For example, you do not have to call `to_json` in each JSON API endpoint implementation. The response format (and thus the automatic serialization) is determined in the following order:\n* Use the file extension, if specified. If the file is .json, choose the JSON format.\n* Use the value of the `format` parameter in the query string, if specified.\n* Use the format set by the `format` option, if specified.\n* Attempt to find an acceptable format from the `Accept` header.\n* Use the default format, if specified by the `default_format` option.\n* Default to `:txt`.\n\nFor example, consider the following API.\n\n```ruby\nclass MultipleFormatAPI < Grape::API\n  content_type :xml, 'application/xml'\n  content_type :json, 'application/json'\n\n  default_format :json\n\n  get :hello do\n    { hello: 'world' }\n  end\nend\n```\n\n* `GET /hello` (with an `Accept: */*` header) does not have an extension or a `format` parameter, so it will respond with JSON (the default format).\n* `GET /hello.xml` has a recognized extension, so it will respond with XML.\n* `GET /hello?format=xml` has a recognized `format` parameter, so it will respond with XML.\n* `GET /hello.xml?format=json` has a recognized extension (which takes precedence over the `format` parameter), so it will respond with XML.\n* `GET /hello.xls` (with an `Accept: */*` header) has an extension, but that extension is not recognized, so it will respond with JSON (the default format).\n* `GET /hello.xls` with an `Accept: application/xml` header has an unrecognized extension, but the `Accept` header corresponds to a recognized format, so it will respond with XML.\n* `GET /hello.xls` with an `Accept: text/plain` header has an unrecognized extension *and* an unrecognized `Accept` header, so it will respond with JSON (the default format).\n\nYou can override this process explicitly by calling `api_format` in the API itself.\nFor example, the following API will let you upload arbitrary files and return their contents as an attachment with the correct MIME type.\n\n```ruby\nclass Twitter::API < Grape::API\n  post 'attachment' do\n    filename = params[:file][:filename]\n    content_type MIME::Types.type_for(filename)[0].to_s\n    api_format :binary # there's no formatter for :binary, data will be returned \"as is\"\n    header 'Content-Disposition', \"attachment; filename*=UTF-8''#{CGI.escape(filename)}\"\n    params[:file][:tempfile].read\n  end\nend\n```\n\nYou can have your API only respond to a single format with `format`. If you use this, the API will **not** respond to file extensions other than specified in `format`. For example, consider the following API.\n\n```ruby\nclass SingleFormatAPI < Grape::API\n  format :json\n\n  get :hello do\n    { hello: 'world' }\n  end\nend\n```\n\n* `GET /hello` will respond with JSON.\n* `GET /hello.json` will respond with JSON.\n* `GET /hello.xml`, `GET /hello.foobar`, or *any* other extension will respond with an HTTP 404 error code.\n* `GET /hello?format=xml` will respond with an HTTP 406 error code, because the XML format specified by the request parameter is not supported.\n* `GET /hello` with an `Accept: application/xml` header will still respond with JSON, since it could not negotiate a recognized content-type from the headers and JSON is the effective default.\n\nThe formats apply to parsing, too. The following API will only respond to the JSON content-type and will not parse any other input than `application/json`, `application/x-www-form-urlencoded`, `multipart/form-data`, `multipart/related` and `multipart/mixed`. All other requests will fail with an HTTP 406 error code.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\nend\n```\n\nWhen the content-type is omitted, Grape will return a 406 error code unless `default_format` is specified.\nThe following API will try to parse any data without a content-type using a JSON parser.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\n  default_format :json\nend\n```\n\nIf you combine `format` with `rescue_from :all`, errors will be rendered using the same format.\nIf you do not want this behavior, set the default error formatter with `default_error_formatter`.\n\n```ruby\nclass Twitter::API < Grape::API\n  format :json\n  content_type :txt, 'text/plain'\n  default_error_formatter :txt\nend\n```\n\nCustom formatters for existing and additional types can be defined with a proc.\n\n```ruby\nclass Twitter::API < Grape::API\n  content_type :xls, 'application/vnd.ms-excel'\n  formatter :xls, ->(object, env) { object.to_xls }\nend\n```\n\nYou can also use a module or class.\n\n```ruby\nmodule XlsFormatter\n  def self.call(object, env)\n    object.to_xls\n  end\nend\n\nclass Twitter::API < Grape::API\n  content_type :xls, 'application/vnd.ms-excel'\n  formatter :xls, XlsFormatter\nend\n```\n\nBuilt-in formatters are the following.\n\n* `:json`: use object's `to_json` when available, otherwise call `MultiJson.dump`\n* `:xml`: use object's `to_xml` when available, usually via `MultiXml`\n* `:txt`: use object's `to_txt` when available, otherwise `to_s`\n* `:serializable_hash`: use object's `serializable_hash` when available, otherwise fallback to `:json`\n* `:binary`: data will be returned \"as is\"\n\nIf a body is present in a request to an API, with a Content-Type header value that is of an unsupported type a \"415 Unsupported Media Type\" error code will be returned by Grape.\n\nResponse statuses that indicate no content as defined by [Rack](https://github.com/rack) [here](https://github.com/rack/rack/blob/master/lib/rack/utils.rb#L567) will bypass serialization and the body entity - though there should be none - will not be modified.\n\n### JSONP\n\nGrape supports JSONP via [Rack::JSONP](https://github.com/rack/rack-contrib), part of the [rack-contrib](https://github.com/rack/rack-contrib) gem. Add `rack-contrib` to your `Gemfile`.\n\n```ruby\nrequire 'rack/contrib'\n\nclass API < Grape::API\n  use Rack::JSONP\n  format :json\n  get '/' do\n    'Hello World'\n  end\nend\n```\n\n### CORS\n\nGrape supports CORS via [Rack::CORS](https://github.com/cyu/rack-cors), part of the [rack-cors](https://github.com/cyu/rack-cors) gem. Add `rack-cors` to your `Gemfile`, then use the middleware in your config.ru file.\n\n```ruby\nrequire 'rack/cors'\n\nuse Rack::Cors do\n  allow do\n    origins '*'\n    resource '*', headers: :any, methods: :get\n  end\nend\n\nrun Twitter::API\n\n```\n\n## Content-type\n\nContent-type is set by the formatter. You can override the content-type of the response at runtime by setting the `Content-Type` header.\n\n```ruby\nclass API < Grape::API\n  get '/home_timeline_js' do\n    content_type 'application/javascript'\n    \"var statuses = ...;\"\n  end\nend\n```\n\n## API Data Formats\n\nGrape accepts and parses input data sent with the POST and PUT methods as described in the Parameters section above. It also supports custom data formats. You must declare additional content-types via `content_type` and optionally supply a parser via `parser` unless a parser is already available within Grape to enable a custom format. Such a parser can be a function or a class.\n\nWith a parser, parsed data is available \"as-is\" in `env['api.request.body']`.\nWithout a parser, data is available \"as-is\" and in `env['api.request.input']`.\n\nThe following example is a trivial parser that will assign any input with the \"text/custom\" content-type to `:value`. The parameter will be available via `params[:value]` inside the API call.\n\n```ruby\nmodule CustomParser\n  def self.call(object, env)\n    { value: object.to_s }\n  end\nend\n```\n\n```ruby\ncontent_type :txt, 'text/plain'\ncontent_type :custom, 'text/custom'\nparser :custom, CustomParser\n\nput 'value' do\n  params[:value]\nend\n```\n\nYou can invoke the above API as follows.\n\n```\ncurl -X PUT -d 'data' 'http://localhost:9292/value' -H Content-Type:text/custom -v\n```\n\nYou can disable parsing for a content-type with `nil`. For example, `parser :json, nil` will disable JSON parsing altogether. The request data is then available as-is in `env['api.request.body']`.\n\n## JSON and XML Processors\n\nGrape uses `JSON` and `ActiveSupport::XmlMini` for JSON and XML parsing by default. It also detects and supports [multi_json](https://github.com/intridea/multi_json) and [multi_xml](https://github.com/sferik/multi_xml). Adding those gems to your Gemfile and requiring them will enable them and allow you to swap the JSON and XML back-ends.\n\n## RESTful Model Representations\n\nGrape supports a range of ways to present your data with some help from a generic `present` method, which accepts two arguments: the object to be presented and the options associated with it. The options hash may include `:with`, which defines the entity to expose.\n\n### Grape Entities\n\nAdd the [grape-entity](https://github.com/ruby-grape/grape-entity) gem to your Gemfile.\nPlease refer to the [grape-entity documentation](https://github.com/ruby-grape/grape-entity/blob/master/README.md)\nfor more details.\n\nThe following example exposes statuses.\n\n```ruby\nmodule API\n  module Entities\n    class Status < Grape::Entity\n      expose :user_name\n      expose :text, documentation: { type: 'string', desc: 'Status update text.' }\n      expose :ip, if: { type: :full }\n      expose :user_type, :user_id, if: ->(status, options) { status.user.public? }\n      expose :digest do |status, options|\n        Digest::MD5.hexdigest(status.txt)\n      end\n      expose :replies, using: API::Status, as: :replies\n    end\n  end\n\n  class Statuses < Grape::API\n    version 'v1'\n\n    desc 'Statuses index' do\n      params: API::Entities::Status.documentation\n    end\n    get '/statuses' do\n      statuses = Status.all\n      type = current_user.admin? ? :full : :default\n      present statuses, with: API::Entities::Status, type: type\n    end\n  end\nend\n```\n\nYou can use entity documentation directly in the params block with `using: Entity.documentation`.\n\n```ruby\nmodule API\n  class Statuses < Grape::API\n    version 'v1'\n\n    desc 'Create a status'\n    params do\n      requires :all, except: [:ip], using: API::Entities::Status.documentation.except(:id)\n    end\n    post '/status' do\n      Status.create! params\n    end\n  end\nend\n```\n\nYou can present with multiple entities using an optional Symbol argument.\n\n```ruby\n  get '/statuses' do\n    statuses = Status.all.page(1).per(20)\n    present :total_page, 10\n    present :per_page, 20\n    present :statuses, statuses, with: API::Entities::Status\n  end\n```\n\nThe response will be\n\n```\n  {\n    total_page: 10,\n    per_page: 20,\n    statuses: []\n  }\n```\n\nIn addition to separately organizing entities, it may be useful to put them as namespaced classes underneath the model they represent.\n\n```ruby\nclass Status\n  def entity\n    Entity.new(self)\n  end\n\n  class Entity < Grape::Entity\n    expose :text, :user_id\n  end\nend\n```\n\nIf you organize your entities this way, Grape will automatically detect the `Entity` class and use it to present your models. In this example, if you added `present Status.new` to your endpoint, Grape will automatically detect that there is a `Status::Entity` class and use that as the representative entity. This can still be overridden by using the `:with` option or an explicit `represents` call.\n\nYou can present `hash` with `Grape::Presenters::Presenter` to keep things consistent.\n\n```ruby\nget '/users' do\n  present { id: 10, name: :dgz }, with: Grape::Presenters::Presenter\nend\n````\nThe response will be\n\n```ruby\n{\n  id:   10,\n  name: 'dgz'\n}\n```\n\nIt has the same result with\n\n```ruby\nget '/users' do\n  present :id, 10\n  present :name, :dgz\nend\n```\n\n### Hypermedia and Roar\n\nYou can use [Roar](https://github.com/apotonick/roar) to render HAL or Collection+JSON with the help of [grape-roar](https://github.com/ruby-grape/grape-roar), which defines a custom JSON formatter and enables presenting entities with Grape's `present` keyword.\n\n### Rabl\n\nYou can use [Rabl](https://github.com/nesquena/rabl) templates with the help of the [grape-rabl](https://github.com/ruby-grape/grape-rabl) gem, which defines a custom Grape Rabl formatter.\n\n### Active Model Serializers\n\nYou can use [Active Model Serializers](https://github.com/rails-api/active_model_serializers) serializers with the help of the [grape-active_model_serializers](https://github.com/jrhe/grape-active_model_serializers) gem, which defines a custom Grape AMS formatter.\n\n## Sending Raw or No Data\n\nIn general, use the binary format to send raw data.\n\n```ruby\nclass API < Grape::API\n  get '/file' do\n    content_type 'application/octet-stream'\n    File.binread 'file.bin'\n  end\nend\n```\n\nYou can set the response body explicitly with `body`.\n\n```ruby\nclass API < Grape::API\n  get '/' do\n    content_type 'text/plain'\n    body 'Hello World'\n    # return value ignored\n  end\nend\n```\n\nUse `body false` to return `204 No Content` without any data or content-type.\n\nIf you want to empty the body with an HTTP status code other than `204 No Content`, you can override the status code after specifying `body false` as follows\n\n```ruby\nclass API < Grape::API\n  get '/' do\n    body false\n    status 304\n  end\nend\n```\n\nYou can also set the response to a file with `sendfile`. This works with the [Rack::Sendfile](https://www.rubydoc.info/gems/rack/Rack/Sendfile) middleware to optimally send the file through your web server software.\n\n```ruby\nclass API < Grape::API\n  get '/' do\n    sendfile '/path/to/file'\n  end\nend\n```\n\nTo stream a file in chunks use `stream`\n\n```ruby\nclass API < Grape::API\n  get '/' do\n    stream '/path/to/file'\n  end\nend\n```\n\nIf you want to stream non-file data use the `stream` method and a `Stream` object.\nThis is an object that responds to `each` and yields for each chunk to send to the client.\nEach chunk will be sent as it is yielded instead of waiting for all of the content to be available.\n\n```ruby\nclass MyStream\n  def each\n    yield 'part 1'\n    yield 'part 2'\n    yield 'part 3'\n  end\nend\n\nclass API < Grape::API\n  get '/' do\n    stream MyStream.new\n  end\nend\n```\n\n## Authentication\n\n### Basic Auth\n\nGrape has built-in Basic authentication (the given `block` is executed in the context of the current `Endpoint`).  Authentication applies to the current namespace and any children, but not parents.\n\n```ruby\nhttp_basic do |username, password|\n  # verify user's password here\n  # IMPORTANT: make sure you use a comparison method which isn't prone to a timing attack\nend\n```\n\n### Register custom middleware for authentication\n\nGrape can use custom Middleware for authentication. How to implement these Middleware have a look at `Rack::Auth::Basic` or similar implementations.\n\nFor registering a Middleware you need the following options:\n\n* `label` - the name for your authenticator to use it later\n* `MiddlewareClass` - the MiddlewareClass to use for authentication\n* `option_lookup_proc` - A Proc with one Argument to lookup the options at runtime (return value is an `Array` as Parameter for the Middleware).\n\nExample:\n\n```ruby\n\nGrape::Middleware::Auth::Strategies.add(:my_auth, AuthMiddleware, ->(options) { [options[:realm]] } )\n\n\nauth :my_auth, { realm: 'Test Api'} do |credentials|\n  # lookup the user's password here\n  { 'user1' => 'password1' }[username]\nend\n\n```\n\nUse [Doorkeeper](https://github.com/doorkeeper-gem/doorkeeper), [warden-oauth2](https://github.com/opperator/warden-oauth2) or [rack-oauth2](https://github.com/nov/rack-oauth2) for OAuth2 support.\n\nYou can access the controller params, headers, and helpers through the context with the `#context` method inside any auth middleware inherited from `Grape::Middleware::Auth::Base`.\n\n## Describing and Inspecting an API\n\nGrape routes can be reflected at runtime. This can notably be useful for generating documentation.\n\nGrape exposes arrays of API versions and compiled routes. Each route contains a `prefix`, `version`, `namespace`, `method` and `params`. You can add custom route settings to the route metadata with `route_setting`.\n\n```ruby\nclass TwitterAPI < Grape::API\n  version 'v1'\n  desc 'Includes custom settings.'\n  route_setting :custom, key: 'value'\n  get do\n\n  end\nend\n```\n\nExamine the routes at runtime.\n\n```ruby\nTwitterAPI::versions # yields [ 'v1', 'v2' ]\nTwitterAPI::routes # yields an array of Grape::Route objects\nTwitterAPI::routes[0].version # => 'v1'\nTwitterAPI::routes[0].description # => 'Includes custom settings.'\nTwitterAPI::routes[0].settings[:custom] # => { key: 'value' }\n```\n\nNote that `Route#route_xyz` methods have been deprecated since 0.15.0 and removed since 2.0.1.\n\nPlease use `Route#xyz` instead.\n\nNote that difference of `Route#options` and `Route#settings`.\n\nThe `options` can be referred from your route, it should be set by specifying key and value on verb methods such as `get`, `post` and `put`.\nThe `settings` can also be referred from your route, but it should be set by specifying key and value on `route_setting`.\n\n## Current Route and Endpoint\n\nIt's possible to retrieve the information about the current route from within an API call with `route`.\n\n```ruby\nclass MyAPI < Grape::API\n  desc 'Returns a description of a parameter.'\n  params do\n    requires :id, type: Integer, desc: 'Identity.'\n  end\n  get 'params/:id' do\n    route.params[params[:id]] # yields the parameter description\n  end\nend\n```\n\nThe current endpoint responding to the request is `self` within the API block or `env['api.endpoint']` elsewhere. The endpoint has some interesting properties, such as `source` which gives you access to the original code block of the API implementation. This can be particularly useful for building a logger middleware.\n\n```ruby\nclass ApiLogger < Grape::Middleware::Base\n  def before\n    file = env['api.endpoint'].source.source_location[0]\n    line = env['api.endpoint'].source.source_location[1]\n    logger.debug \"[api] #{file}:#{line}\"\n  end\nend\n```\n\n## Before, After and Finally\n\nBlocks can be executed before or after every API call, using `before`, `after`, `before_validation` and `after_validation`.\nIf the API fails the `after` call will not be triggered, if you need code to execute for sure use the `finally`.\n\nBefore and after callbacks execute in the following order:\n\n1. `before`\n2. `before_validation`\n3. _validations_\n4. `after_validation` (upon successful validation)\n5. _the API call_ (upon successful validation)\n6. `after` (upon successful validation and API call)\n7. `finally` (always)\n\nSteps 4, 5 and 6 only happen if validation succeeds.\n\nIf a request for a resource is made with an unsupported HTTP method (returning HTTP 405) only `before` callbacks will be executed.  The remaining callbacks will be bypassed.\n\nIf a request for a resource is made that triggers the built-in `OPTIONS` handler, only `before` and `after` callbacks will be executed.  The remaining callbacks will be bypassed.\n\nFor example, using a simple `before` block to set a header.\n\n```ruby\nbefore do\n  header 'X-Robots-Tag', 'noindex'\nend\n```\n\nYou can ensure a block of code runs after every request (including failures) with `finally`:\n\n```ruby\nfinally do\n  # this code will run after every request (successful or failed)\nend\n```\n\n**Namespaces**\n\nCallbacks apply to each API call within and below the current namespace:\n\n```ruby\nclass MyAPI < Grape::API\n  get '/' do\n    \"root - #{@blah}\"\n  end\n\n  namespace :foo do\n    before do\n      @blah = 'blah'\n    end\n\n    get '/' do\n      \"root - foo - #{@blah}\"\n    end\n\n    namespace :bar do\n      get '/' do\n        \"root - foo - bar - #{@blah}\"\n      end\n    end\n  end\nend\n```\n\nThe behavior is then:\n\n```bash\nGET /           # 'root - '\nGET /foo        # 'root - foo - blah'\nGET /foo/bar    # 'root - foo - bar - blah'\n```\n\nParams on a `namespace` (or whichever alias you are using) will also be available when using `before_validation` or `after_validation`:\n\n```ruby\nclass MyAPI < Grape::API\n  params do\n    requires :blah, type: Integer\n  end\n  resource ':blah' do\n    after_validation do\n      # if we reach this point validations will have passed\n      @blah = declared(params, include_missing: false)[:blah]\n    end\n\n    get '/' do\n      @blah.class\n    end\n  end\nend\n```\n\nThe behavior is then:\n\n```bash\nGET /123        # 'Integer'\nGET /foo        # 400 error - 'blah is invalid'\n```\n\n**Versioning**\n\nWhen a callback is defined within a version block, it's only called for the routes defined in that block.\n\n```ruby\nclass Test < Grape::API\n  resource :foo do\n    version 'v1', :using => :path do\n      before do\n        @output ||= 'v1-'\n      end\n      get '/' do\n        @output += 'hello'\n      end\n    end\n\n    version 'v2', :using => :path do\n      before do\n        @output ||= 'v2-'\n      end\n      get '/' do\n        @output += 'hello'\n      end\n    end\n  end\nend\n```\n\nThe behavior is then:\n\n```bash\nGET /foo/v1       # 'v1-hello'\nGET /foo/v2       # 'v2-hello'\n```\n\n**Altering Responses**\n\nUsing `present` in any callback allows you to add data to a response:\n\n```ruby\nclass MyAPI < Grape::API\n  format :json\n\n  after_validation do\n    present :name, params[:name] if params[:name]\n  end\n\n  get '/greeting' do\n    present :greeting, 'Hello!'\n  end\nend\n```\n\nThe behavior is then:\n\n```bash\nGET /greeting              # {\"greeting\":\"Hello!\"}\nGET /greeting?name=Alan    # {\"name\":\"Alan\",\"greeting\":\"Hello!\"}\n```\n\nInstead of altering a response, you can also terminate and rewrite it from any callback using `error!`, including `after`. This will cause all subsequent steps in the process to not be called. **This includes the actual api call and any callbacks**\n\n## Anchoring\n\nGrape by default anchors all request paths, which means that the request URL should match from start to end to match, otherwise a `404 Not Found` is returned. However, this is sometimes not what you want, because it is not always known upfront what can be expected from the call. This is because Rack-mount by default anchors requests to match from the start to the end, or not at all.\nRails solves this problem by using a `anchor: false` option in your routes.\nIn Grape this option can be used as well when a method is defined.\n\nFor instance when your API needs to get part of an URL, for instance:\n\n```ruby\nclass TwitterAPI < Grape::API\n  namespace :statuses do\n    get '/(*:status)', anchor: false do\n\n    end\n  end\nend\n```\n\nThis will match all paths starting with '/statuses/'. There is one caveat though: the `params[:status]` parameter only holds the first part of the request url.\nLuckily this can be circumvented by using the described above syntax for path specification and using the `PATH_INFO` Rack environment variable, using `env['PATH_INFO']`. This will hold everything that comes after the '/statuses/' part.\n\n## Instance Variables\n\nYou can use instance variables to pass information across the various stages of a request. An instance variable set within a `before` validator is accessible within the endpoint's code and can also be utilized within the `rescue_from` handler.\n\n```ruby\nclass TwitterAPI < Grape::API\n  before do\n    @var = 1\n  end\n\n  get '/' do\n    puts @var # => 1\n    raise\n  end\n\n  rescue_from :all do\n    puts @var # => 1\n  end\nend\n```\n\nThe values of instance variables cannot be shared among various endpoints within the same API. This limitation arises due to Grape generating a new instance for each request made. Consequently, instance variables set within an endpoint during one request differ from those set during a subsequent request, as they exist within separate instances.\n\n```ruby\nclass TwitterAPI < Grape::API\n  get '/first' do\n    @var = 1\n    puts @var # => 1\n  end\n\n  get '/second' do\n    puts @var # => nil\n  end\nend\n```\n\n## Using Custom Middleware\n\n### Grape Middleware\n\nYou can make a custom middleware by using `Grape::Middleware::Base`.\nIt's inherited from some grape official middlewares in fact.\n\nFor example, you can write a middleware to log application exception.\n\n```ruby\nclass LoggingError < Grape::Middleware::Base\n  def after\n    return unless @app_response && @app_response[0] == 500\n    env['rack.logger'].error(\"Raised error on #{env['PATH_INFO']}\")\n  end\nend\n```\n\nYour middleware can overwrite application response as follows, except error case.\n\n```ruby\nclass Overwriter < Grape::Middleware::Base\n  def after\n    [200, { 'Content-Type' => 'text/plain' }, ['Overwritten.']]\n  end\nend\n```\n\nYou can add your custom middleware with `use`, that push the middleware onto the stack, and you can also control where the middleware is inserted using `insert`, `insert_before` and `insert_after`.\n\n```ruby\nclass CustomOverwriter < Grape::Middleware::Base\n  def after\n    [200, { 'Content-Type' => 'text/plain' }, [@options[:message]]]\n  end\nend\n\n\nclass API < Grape::API\n  use Overwriter\n  insert_before Overwriter, CustomOverwriter, message: 'Overwritten again.'\n  insert 0, CustomOverwriter, message: 'Overwrites all other middleware.'\n\n  get '/' do\n  end\nend\n```\n\nYou can access the controller params, headers, and helpers through the context with the `#context` method inside any middleware inherited from `Grape::Middleware::Base`.\n\n### Rails Middleware\n\nNote that when you're using Grape mounted on Rails you don't have to use Rails middleware because it's already included into your middleware stack.\nYou only have to implement the helpers to access the specific `env` variable.\n\nIf you are using a custom application that is inherited from `Rails::Application` and need to insert a new middleware among the ones initiated via Rails, you will need to register it manually in your custom application class.\n\n```ruby\nclass Company::Application < Rails::Application\n  config.middleware.insert_before(Rack::Attack, Middleware::ApiLogger)\nend\n```\n\n### Remote IP\n\nBy default you can access remote IP with `request.ip`. This is the remote IP address implemented by Rack. Sometimes it is desirable to get the remote IP [Rails-style](http://stackoverflow.com/questions/10997005/whats-the-difference-between-request-remote-ip-and-request-ip-in-rails) with `ActionDispatch::RemoteIp`.\n\nAdd `gem 'actionpack'` to your Gemfile and `require 'action_dispatch/middleware/remote_ip.rb'`. Use the middleware in your API and expose a `client_ip` helper. See [this documentation](http://api.rubyonrails.org/classes/ActionDispatch/RemoteIp.html) for additional options.\n\n```ruby\nclass API < Grape::API\n  use ActionDispatch::RemoteIp\n\n  helpers do\n    def client_ip\n      env['action_dispatch.remote_ip'].to_s\n    end\n  end\n\n  get :remote_ip do\n    { ip: client_ip }\n  end\nend\n```\n\n## Writing Tests\n\n### Writing Tests with Rack\n\nUse `rack-test` and define your API as `app`.\n\n#### RSpec\n\nYou can test a Grape API with RSpec by making HTTP requests and examining the response.\n\n```ruby\n\n\ndescribe Twitter::API do\n  include Rack::Test::Methods\n\n  def app\n    Twitter::API\n  end\n\n  context 'GET /api/statuses/public_timeline' do\n    it 'returns an empty array of statuses' do\n      get '/api/statuses/public_timeline'\n      expect(last_response.status).to eq(200)\n      expect(JSON.parse(last_response.body)).to eq []\n    end\n  end\n  context 'GET /api/statuses/:id' do\n    it 'returns a status by id' do\n      status = Status.create!\n      get \"/api/statuses/#{status.id}\"\n      expect(last_response.body).to eq status.to_json\n    end\n  end\nend\n```\n\nThere's no standard way of sending arrays of objects via an HTTP GET, so POST JSON data and specify the correct content-type.\n\n```ruby\ndescribe Twitter::API do\n  context 'POST /api/statuses' do\n    it 'creates many statuses' do\n      statuses = [{ text: '...' }, { text: '...'}]\n      post '/api/statuses', statuses.to_json, 'CONTENT_TYPE' => 'application/json'\n      expect(last_response.body).to eq 201\n    end\n  end\nend\n```\n\n#### Airborne\n\nYou can test with other RSpec-based frameworks, including [Airborne](https://github.com/brooklynDev/airborne), which uses `rack-test` to make requests.\n\n```ruby\nrequire 'airborne'\n\nAirborne.configure do |config|\n  config.rack_app = Twitter::API\nend\n\ndescribe Twitter::API do\n  context 'GET /api/statuses/:id' do\n    it 'returns a status by id' do\n      status = Status.create!\n      get \"/api/statuses/#{status.id}\"\n      expect_json(status.as_json)\n    end\n  end\nend\n```\n\n#### MiniTest\n\n```ruby\nrequire 'test_helper'\n\nclass Twitter::APITest < MiniTest::Test\n  include Rack::Test::Methods\n\n  def app\n    Twitter::API\n  end\n\n  def test_get_api_statuses_public_timeline_returns_an_empty_array_of_statuses\n    get '/api/statuses/public_timeline'\n    assert last_response.ok?\n    assert_equal [], JSON.parse(last_response.body)\n  end\n\n  def test_get_api_statuses_id_returns_a_status_by_id\n    status = Status.create!\n    get \"/api/statuses/#{status.id}\"\n    assert_equal status.to_json, last_response.body\n  end\nend\n```\n\n### Writing Tests with Rails\n\n#### RSpec\n\n```ruby\ndescribe Twitter::API do\n  context 'GET /api/statuses/public_timeline' do\n    it 'returns an empty array of statuses' do\n      get '/api/statuses/public_timeline'\n      expect(response.status).to eq(200)\n      expect(JSON.parse(response.body)).to eq []\n    end\n  end\n  context 'GET /api/statuses/:id' do\n    it 'returns a status by id' do\n      status = Status.create!\n      get \"/api/statuses/#{status.id}\"\n      expect(response.body).to eq status.to_json\n    end\n  end\nend\n```\n\nIn Rails, HTTP request tests would go into the `spec/requests` group. You may want your API code to go into `app/api` - you can match that layout under `spec` by adding the following in `spec/rails_helper.rb`.\n\n```ruby\nRSpec.configure do |config|\n  config.include RSpec::Rails::RequestExampleGroup, type: :request, file_path: /spec\\/api/\nend\n```\n\n#### MiniTest\n\n```ruby\nclass Twitter::APITest < ActiveSupport::TestCase\n  include Rack::Test::Methods\n\n  def app\n    Rails.application\n  end\n\n  test 'GET /api/statuses/public_timeline returns an empty array of statuses' do\n    get '/api/statuses/public_timeline'\n    assert last_response.ok?\n    assert_equal [], JSON.parse(last_response.body)\n  end\n\n  test 'GET /api/statuses/:id returns a status by id' do\n    status = Status.create!\n    get \"/api/statuses/#{status.id}\"\n    assert_equal status.to_json, last_response.body\n  end\nend\n```\n\n### Stubbing Helpers\n\nBecause helpers are mixed in based on the context when an endpoint is defined, it can be difficult to stub or mock them for testing. The `Grape::Endpoint.before_each` method can help by allowing you to define behavior on the endpoint that will run before every request.\n\n```ruby\ndescribe 'an endpoint that needs helpers stubbed' do\n  before do\n    Grape::Endpoint.before_each do |endpoint|\n      allow(endpoint).to receive(:helper_name).and_return('desired_value')\n    end\n  end\n\n  after do\n    Grape::Endpoint.before_each nil\n  end\n\n  it 'stubs the helper' do\n\n  end\nend\n```\n\n## Reloading API Changes in Development\n\n### Reloading in Rack Applications\n\nUse [grape-reload](https://github.com/AlexYankee/grape-reload).\n\n### Reloading in Rails Applications\n\nAdd API paths to `config/application.rb`.\n\n```ruby\n# Auto-load API and its subdirectories\nconfig.paths.add File.join('app', 'api'), glob: File.join('**', '*.rb')\nconfig.autoload_paths += Dir[Rails.root.join('app', 'api', '*')]\n```\n\nCreate `config/initializers/reload_api.rb`.\n\n```ruby\nif Rails.env.development?\n  ActiveSupport::Dependencies.explicitly_unloadable_constants << 'Twitter::API'\n\n  api_files = Dir[Rails.root.join('app', 'api', '**', '*.rb')]\n  api_reloader = ActiveSupport::FileUpdateChecker.new(api_files) do\n    Rails.application.reload_routes!\n  end\n  ActionDispatch::Callbacks.to_prepare do\n    api_reloader.execute_if_updated\n  end\nend\n```\n\nFor Rails >= 5.1.4, change this:\n\n```ruby\nActionDispatch::Callbacks.to_prepare do\n  api_reloader.execute_if_updated\nend\n```\n\nto this:\n\n```ruby\nActiveSupport::Reloader.to_prepare do\n  api_reloader.execute_if_updated\nend\n```\n\nSee [StackOverflow #3282655](http://stackoverflow.com/questions/3282655/ruby-on-rails-3-reload-lib-directory-for-each-request/4368838#4368838) for more information.\n\n## Performance Monitoring\n\n### Active Support Instrumentation\n\nGrape has built-in support for [ActiveSupport::Notifications](http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html) which provides simple hook points to instrument key parts of your application.\n\nThe following are currently supported:\n\n#### endpoint_run.grape\n\nThe main execution of an endpoint, includes filters and rendering.\n\n* *endpoint* - The endpoint instance\n\n#### endpoint_render.grape\n\nThe execution of the main content block of the endpoint.\n\n* *endpoint* - The endpoint instance\n\n#### endpoint_run_filters.grape\n\n* *endpoint* - The endpoint instance\n* *filters* - The filters being executed\n* *type* - The type of filters (before, before_validation, after_validation, after)\n\n#### endpoint_run_validators.grape\n\nThe execution of validators.\n\n* *endpoint* - The endpoint instance\n* *validators* - The validators being executed\n* *request* - The request being validated\n\n#### format_response.grape\n\nSerialization or template rendering.\n\n* *env* - The request environment\n* *formatter* - The formatter object (e.g., `Grape::Formatter::Json`)\n\nSee the [ActiveSupport::Notifications documentation](http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html) for information on how to subscribe to these events.\n\n### Monitoring Products\n\nGrape integrates with following third-party tools:\n\n* **New Relic** - [built-in support](https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/grape-instrumentation) from v3.10.0 of the official [newrelic_rpm](https://github.com/newrelic/rpm) gem, also [newrelic-grape](https://github.com/xinminlabs/newrelic-grape) gem\n* **Librato Metrics** - [grape-librato](https://github.com/seanmoon/grape-librato) gem\n* **[Skylight](https://www.skylight.io/)** - [skylight](https://github.com/skylightio/skylight-ruby) gem, [documentation](https://docs.skylight.io/grape/)\n* **[AppSignal](https://www.appsignal.com)** - [appsignal-ruby](https://github.com/appsignal/appsignal-ruby) gem, [documentation](http://docs.appsignal.com/getting-started/supported-frameworks.html#grape)\n* **[ElasticAPM](https://www.elastic.co/products/apm)** - [elastic-apm](https://github.com/elastic/apm-agent-ruby) gem, [documentation](https://www.elastic.co/guide/en/apm/agent/ruby/3.x/getting-started-rack.html#getting-started-grape)\n* **[Datadog APM](https://docs.datadoghq.com/tracing/)** - [ddtrace](https://github.com/datadog/dd-trace-rb) gem, [documentation](https://docs.datadoghq.com/tracing/setup_overview/setup/ruby/#grape)\n\n## Contributing to Grape\n\nGrape is work of hundreds of contributors. You're encouraged to submit pull requests, propose features and discuss issues.\n\nSee [CONTRIBUTING](CONTRIBUTING.md).\n\n## Security\n\nSee [SECURITY](SECURITY.md) for details.\n\n## License\n\nMIT License. See [LICENSE](LICENSE) for details.\n\n## Copyright\n\nCopyright (c) 2010-2020 Michael Bleigh, Intridea Inc. and Contributors.\n",
        "releases": []
    }
}
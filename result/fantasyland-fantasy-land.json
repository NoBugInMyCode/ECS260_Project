{
    "https://api.github.com/repos/fantasyland/fantasy-land": {
        "forks": 377,
        "watchers": 10153,
        "stars": 10153,
        "languages": {
            "JavaScript": 2095,
            "Shell": 957
        },
        "commits": [
            "2024-11-10T21:50:53Z",
            "2023-12-26T21:42:11Z",
            "2023-12-26T21:26:04Z",
            "2021-04-27T13:42:27Z",
            "2022-12-05T09:59:51Z",
            "2022-12-05T09:18:34Z",
            "2022-11-22T19:30:03Z",
            "2021-04-26T20:00:20Z",
            "2021-04-19T09:15:10Z",
            "2021-04-14T19:58:38Z",
            "2020-06-20T16:58:16Z",
            "2020-06-20T16:02:26Z",
            "2020-05-25T09:35:17Z",
            "2020-05-25T09:29:59Z",
            "2020-05-25T09:21:51Z",
            "2020-05-22T05:20:11Z",
            "2020-05-03T20:17:17Z",
            "2019-10-08T11:13:03Z",
            "2019-10-08T05:34:17Z",
            "2019-03-02T21:06:26Z",
            "2019-03-02T21:03:18Z",
            "2019-03-02T20:25:17Z",
            "2019-03-02T20:17:32Z",
            "2019-03-02T20:07:22Z",
            "2018-07-04T14:54:01Z",
            "2019-03-02T19:44:14Z",
            "2017-08-11T12:56:58Z",
            "2019-03-02T19:18:45Z",
            "2019-02-15T19:18:27Z",
            "2019-03-02T14:18:43Z"
        ],
        "creation_date": "2013-04-12T03:10:22Z",
        "contributors": 30,
        "topics": [
            "fantasy-land",
            "functional",
            "javascript",
            "specification"
        ],
        "subscribers": 228,
        "readme": "# Fantasy Land Specification\n\n[![Build Status](https://travis-ci.org/fantasyland/fantasy-land.svg?branch=master)](https://travis-ci.org/fantasyland/fantasy-land) [![Join the chat at https://gitter.im/fantasyland/fantasy-land](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/fantasyland/fantasy-land?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n(aka \"Algebraic JavaScript Specification\")\n\n<img src=\"logo.png\" width=\"200\" height=\"200\" />\n\nThis project specifies interoperability of common algebraic\nstructures:\n\n<pre>\n <a href=\"#setoid\">Setoid</a>   <a href=\"#emigroupoid\">Semigroupoid</a>  <a href=\"#semigroup\">Semigroup</a>   <a href=\"#foldable\">Foldable</a>        <a href=\"#functor\">Functor</a>      <a href=\"#contravariant\">Contravariant</a>  <a href=\"#filterable\">Filterable</a>\n(<a href=\"#equals-method\">equals</a>)    (<a href=\"#compose-method\">compose</a>)    (<a href=\"#concat-method\">concat</a>)   (<a href=\"#reduce-method\">reduce</a>)         (<a href=\"#map-method\">map</a>)        (<a href=\"#contramap-method\">contramap</a>)    (<a href=\"#filter-method\">filter</a>)\n    |           |           |           \\         / | | | | \\\n    |           |           |            \\       /  | | | |  \\\n    |           |           |             \\     /   | | | |   \\\n    |           |           |              \\   /    | | | |    \\\n    |           |           |               \\ /     | | | |     \\\n   <a href=\"#ord\">Ord</a>      <a href=\"#category\">Category</a>     <a href=\"#monoid\">Monoid</a>         <a href=\"#traversable\">Traversable</a> | | | |      \\\n  (<a href=\"#lte-method\">lte</a>)       (<a href=\"#id-method\">id</a>)       (<a href=\"#empty-method\">empty</a>)        (<a href=\"#traverse-method\">traverse</a>)  / | | \\       \\\n                            |                      /  | |  \\       \\\n                            |                     /   / \\   \\       \\\n                            |             <a href=\"#profunctor\">Profunctor</a> /   \\ <a href=\"#bifunctor\">Bifunctor</a> \\\n                            |              (<a href=\"#promap-method\">promap</a>) /     \\ (<a href=\"#bimap-method\">bimap</a>)   \\\n                            |                      /       \\           \\\n                          <a href=\"#group\">Group</a>                   /         \\           \\\n                         (<a href=\"#invert-method\">invert</a>)               <a href=\"#alt\">Alt</a>        <a href=\"#apply\">Apply</a>      <a href=\"#extend\">Extend</a>\n                                               (<a href=\"#alt-method\">alt</a>)        (<a href=\"#ap-method\">ap</a>)     (<a href=\"#extend-method\">extend</a>)\n                                                /           / \\           \\\n                                               /           /   \\           \\\n                                              /           /     \\           \\\n                                             /           /       \\           \\\n                                            /           /         \\           \\\n                                          <a href=\"#plus\">Plus</a>    <a href=\"#applicative\">Applicative</a>    <a href=\"#chain\">Chain</a>      <a href=\"#comonad\">Comonad</a>\n                                         (<a href=\"#zero-method\">zero</a>)       (<a href=\"#of-method\">of</a>)      (<a href=\"#chain-method\">chain</a>)    (<a href=\"#extract-method\">extract</a>)\n                                            \\         / \\         / \\\n                                             \\       /   \\       /   \\\n                                              \\     /     \\     /     \\\n                                               \\   /       \\   /       \\\n                                                \\ /         \\ /         \\\n                                            <a href=\"#alternative\">Alternative</a>    <a href=\"#monad\">Monad</a>     <a href=\"#chainrec\">ChainRec</a>\n                                                                    (<a href=\"#chainrec-method\">chainRec</a>)\n</pre>\n\n## General\n\nAn algebra is a set of values, a set of operators that it is closed\nunder and some laws it must obey.\n\nEach Fantasy Land algebra is a separate specification. An algebra may\nhave dependencies on other algebras which must be implemented.\n\n## Terminology\n\n1. \"value\" is any JavaScript value, including any which have the\n   structures defined below.\n2. \"equivalent\" is an appropriate definition of equivalence for the given value.\n    The definition should ensure that the two values can be safely swapped out in a program that respects abstractions. For example:\n    - Two lists are equivalent if they are equivalent at all indices.\n    - Two plain old JavaScript objects, interpreted as dictionaries, are equivalent when they are equivalent for all keys.\n    - Two promises are equivalent when they yield equivalent values.\n    - Two functions are equivalent if they yield equivalent outputs for equivalent inputs.\n\n## Type signature notation\n\nThe type signature notation used in this document is described below:<sup\nid=\"sanctuary-types-return\">[1](#sanctuary-types)</sup>\n\n* `::` _\"is a member of\"._\n    - `e :: t` can be read as: \"the expression `e` is a member of type `t`\".\n    - `true :: Boolean` - \"`true` is a member of type `Boolean`\".\n    - `42 :: Integer, Number` - \"`42` is a member of the `Integer` and\n      `Number` types\".\n* _New types can be created via type constructors._\n    - Type constructors can take zero or more type arguments.\n    - `Array` is a type constructor which takes one type argument.\n    - `Array String` is the type of all arrays of strings. Each of the\n      following has type `Array String`: `[]`, `['foo', 'bar', 'baz']`.\n    - `Array (Array String)` is the type of all arrays of arrays of strings.\n      Each of the following has type `Array (Array String)`: `[]`, `[ [], []\n      ]`, `[ [], ['foo'], ['bar', 'baz'] ]`.\n* _Lowercase letters stand for type variables._\n    - Type variables can take any type unless they have been restricted by\n      means of type constraints (see fat arrow below).\n* `->` (arrow) _Function type constructor._\n    - `->` is an _infix_ type constructor that takes two type arguments where\n      left argument is the input type and the right argument is the output type.\n    - `->`'s input type can be a grouping of types to create the type of a\n      function which accepts zero or more arguments. The syntax is:\n      `(<input-types>) -> <output-type>`, where `<input-types>` comprises zero\n      or more comma\u2013space (`, `)-separated type representations and parens\n      may be omitted for unary functions.\n    - `String -> Array String` is a type satisfied by functions which take a\n      `String` and return an `Array String`.\n    - `String -> Array String -> Array String` is a type satisfied by functions\n      which take a `String` and return a function which takes an `Array String`\n      and returns an `Array String`.\n    - `(String, Array String) -> Array String` is a type satisfied by functions\n      which take a `String` and an `Array String` as arguments and return an\n      `Array String`.\n    - `() -> Number` is a type satisfied by functions\n      which do not take arguments and return a `Number`.\n* `~>` (squiggly arrow) _Method type constructor._\n    - When a function is a property of an Object, it is called a method. All\n      methods have an implicit parameter type - the type of which they are a\n      property.\n    - `a ~> a -> a` is a type satisfied by methods on Objects of type `a` which\n      take a type `a` as an argument and return a value of type `a`.\n* `=>` (fat arrow) _Expresses constraints on type variables._\n    - In `a ~> a -> a` (see squiggly arrow above), `a` can be of any type.\n      `Semigroup a => a ~> a -> a` adds a constraint such that the type `a`\n      must now satisfy the `Semigroup` typeclass. To satisfy a typeclass means\n      to lawfully implement all functions/methods specified by that typeclass.\n\nFor example:\n\n```\nfantasy-land/traverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n'-------------------'    '--------------------------'    '-'    '-------------------'    '-----'\n '                        '                               '      '                        '\n '                        ' - type constraints            '      ' - argument types       ' - return type\n '                                                        '\n '- method name                                           ' - method target type\n```\n\n- - -\n1. <a name=\"sanctuary-types\"></a>See the [Types](https://sanctuary.js.org/#types)\n   section in Sanctuary's docs for more info. [\u21a9](#sanctuary-types-return)\n\n## Type representatives\n\nCertain behaviours are defined from the perspective of a member of a type.\nOther behaviours do not require a member. Thus certain algebras require a\ntype to provide a value-level representative (with certain properties). The\nIdentity type, for example, could provide `Id` as its type representative:\n`Id :: TypeRep Identity`.\n\nIf a type provides a type representative, each member of the type must have\na `constructor` property which is a reference to the type representative.\n\n## Algebras\n\n### Setoid\n\n1. `a['fantasy-land/equals'](a) === true` (reflexivity)\n2. `a['fantasy-land/equals'](b) === b['fantasy-land/equals'](a)` (symmetry)\n3. If `a['fantasy-land/equals'](b)` and `b['fantasy-land/equals'](c)`, then `a['fantasy-land/equals'](c)` (transitivity)\n\n<a name=\"equals-method\"></a>\n\n#### `fantasy-land/equals` method\n\n```hs\nfantasy-land/equals :: Setoid a => a ~> a -> Boolean\n```\n\nA value which has a Setoid must provide a `fantasy-land/equals` method. The\n`fantasy-land/equals` method takes one argument:\n\n    a['fantasy-land/equals'](b)\n\n1. `b` must be a value of the same Setoid\n\n    1. If `b` is not the same Setoid, behaviour of `fantasy-land/equals` is\n       unspecified (returning `false` is recommended).\n\n2. `fantasy-land/equals` must return a boolean (`true` or `false`).\n\n### Ord\n\nA value that implements the Ord specification must also implement\nthe [Setoid](#setoid) specification.\n\n1. `a['fantasy-land/lte'](b)` or `b['fantasy-land/lte'](a)` (totality)\n2. If `a['fantasy-land/lte'](b)` and `b['fantasy-land/lte'](a)`, then `a['fantasy-land/equals'](b)` (antisymmetry)\n3. If `a['fantasy-land/lte'](b)` and `b['fantasy-land/lte'](c)`, then `a['fantasy-land/lte'](c)` (transitivity)\n\n<a name=\"lte-method\"></a>\n\n#### `fantasy-land/lte` method\n\n```hs\nfantasy-land/lte :: Ord a => a ~> a -> Boolean\n```\n\nA value which has an Ord must provide a `fantasy-land/lte` method. The\n`fantasy-land/lte` method takes one argument:\n\n     a['fantasy-land/lte'](b)\n\n1. `b` must be a value of the same Ord\n\n    1. If `b` is not the same Ord, behaviour of `fantasy-land/lte` is\n       unspecified (returning `false` is recommended).\n\n2. `fantasy-land/lte` must return a boolean (`true` or `false`).\n\n### Semigroupoid\n\n1. `a['fantasy-land/compose'](b)['fantasy-land/compose'](c) === a['fantasy-land/compose'](b['fantasy-land/compose'](c))` (associativity)\n\n<a name=\"compose-method\"></a>\n\n#### `fantasy-land/compose` method\n\n```hs\nfantasy-land/compose :: Semigroupoid c => c i j ~> c j k -> c i k\n```\n\nA value which has a Semigroupoid must provide a `fantasy-land/compose` method. The\n`fantasy-land/compose` method takes one argument:\n\n    a['fantasy-land/compose'](b)\n\n1. `b` must be a value of the same Semigroupoid\n\n    1. If `b` is not the same semigroupoid, behaviour of `fantasy-land/compose` is\n       unspecified.\n\n2. `fantasy-land/compose` must return a value of the same Semigroupoid.\n\n### Category\n\nA value that implements the Category specification must also implement\nthe [Semigroupoid](#semigroupoid) specification.\n\n1. `a['fantasy-land/compose'](C['fantasy-land/id']())` is equivalent to `a` (right identity)\n2. `C['fantasy-land/id']()['fantasy-land/compose'](a)` is equivalent to `a` (left identity)\n\n<a name=\"id-method\"></a>\n\n#### `fantasy-land/id` method\n\n```hs\nfantasy-land/id :: Category c => () -> c a a\n```\n\nA value which has a Category must provide a `fantasy-land/id` function on its\n[type representative](#type-representatives):\n\n    C['fantasy-land/id']()\n\nGiven a value `c`, one can access its type representative via the\n`constructor` property:\n\n    c.constructor['fantasy-land/id']()\n\n1. `fantasy-land/id` must return a value of the same Category\n\n### Semigroup\n\n1. `a['fantasy-land/concat'](b)['fantasy-land/concat'](c)` is equivalent to `a['fantasy-land/concat'](b['fantasy-land/concat'](c))` (associativity)\n\n<a name=\"concat-method\"></a>\n\n#### `fantasy-land/concat` method\n\n```hs\nfantasy-land/concat :: Semigroup a => a ~> a -> a\n```\n\nA value which has a Semigroup must provide a `fantasy-land/concat` method. The\n`fantasy-land/concat` method takes one argument:\n\n    s['fantasy-land/concat'](b)\n\n1. `b` must be a value of the same Semigroup\n\n    1. If `b` is not the same semigroup, behaviour of `fantasy-land/concat` is\n       unspecified.\n\n2. `fantasy-land/concat` must return a value of the same Semigroup.\n\n### Monoid\n\nA value that implements the Monoid specification must also implement\nthe [Semigroup](#semigroup) specification.\n\n1. `m['fantasy-land/concat'](M['fantasy-land/empty']())` is equivalent to `m` (right identity)\n2. `M['fantasy-land/empty']()['fantasy-land/concat'](m)` is equivalent to `m` (left identity)\n\n<a name=\"empty-method\"></a>\n\n#### `fantasy-land/empty` method\n\n```hs\nfantasy-land/empty :: Monoid m => () -> m\n```\n\nA value which has a Monoid must provide a `fantasy-land/empty` function on its\n[type representative](#type-representatives):\n\n    M['fantasy-land/empty']()\n\nGiven a value `m`, one can access its type representative via the\n`constructor` property:\n\n    m.constructor['fantasy-land/empty']()\n\n1. `fantasy-land/empty` must return a value of the same Monoid\n\n### Group\n\nA value that implements the Group specification must also implement\nthe [Monoid](#monoid) specification.\n\n1. `g['fantasy-land/concat'](g['fantasy-land/invert']())` is equivalent to `g.constructor['fantasy-land/empty']()` (right inverse)\n2. `g['fantasy-land/invert']()['fantasy-land/concat'](g)` is equivalent to `g.constructor['fantasy-land/empty']()` (left inverse)\n\n<a name=\"invert-method\"></a>\n\n#### `fantasy-land/invert` method\n\n```hs\nfantasy-land/invert :: Group g => g ~> () -> g\n```\n\nA value which has a Group must provide a `fantasy-land/invert` method. The\n`fantasy-land/invert` method takes no arguments:\n\n    g['fantasy-land/invert']()\n\n1. `fantasy-land/invert` must return a value of the same Group.\n\n### Filterable\n\n1. `v['fantasy-land/filter'](x => p(x) && q(x))` is equivalent to `v['fantasy-land/filter'](p)['fantasy-land/filter'](q)` (distributivity)\n2. `v['fantasy-land/filter'](x => true)` is equivalent to `v` (identity)\n3. `v['fantasy-land/filter'](x => false)` is equivalent to `w['fantasy-land/filter'](x => false)`\n   if `v` and `w` are values of the same Filterable (annihilation)\n\n<a name=\"filter-method\"></a>\n\n#### `fantasy-land/filter` method\n\n```hs\nfantasy-land/filter :: Filterable f => f a ~> (a -> Boolean) -> f a\n```\n\nA value which has a Filterable must provide a `fantasy-land/filter` method. The `fantasy-land/filter`\nmethod takes one argument:\n\n    v['fantasy-land/filter'](p)\n\n1. `p` must be a function.\n\n    1. If `p` is not a function, the behaviour of `fantasy-land/filter` is unspecified.\n    2. `p` must return either `true` or `false`. If it returns any other value,\n       the behaviour of `fantasy-land/filter` is unspecified.\n\n2. `fantasy-land/filter` must return a value of the same Filterable.\n\n### Functor\n\n1. `u['fantasy-land/map'](a => a)` is equivalent to `u` (identity)\n2. `u['fantasy-land/map'](x => f(g(x)))` is equivalent to `u['fantasy-land/map'](g)['fantasy-land/map'](f)` (composition)\n\n<a name=\"map-method\"></a>\n\n#### `fantasy-land/map` method\n\n```hs\nfantasy-land/map :: Functor f => f a ~> (a -> b) -> f b\n```\n\nA value which has a Functor must provide a `fantasy-land/map` method. The `fantasy-land/map`\nmethod takes one argument:\n\n    u['fantasy-land/map'](f)\n\n1. `f` must be a function,\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/map` is\n       unspecified.\n    2. `f` can return any value.\n    3. No parts of `f`'s return value should be checked.\n\n2. `fantasy-land/map` must return a value of the same Functor\n\n### Contravariant\n\n1. `u['fantasy-land/contramap'](a => a)` is equivalent to `u` (identity)\n2. `u['fantasy-land/contramap'](x => f(g(x)))` is equivalent to `u['fantasy-land/contramap'](f)['fantasy-land/contramap'](g)`\n(composition)\n\n<a name=\"contramap-method\"></a>\n\n#### `fantasy-land/contramap` method\n\n```hs\nfantasy-land/contramap :: Contravariant f => f a ~> (b -> a) -> f b\n```\n\nA value which has a Contravariant must provide a `fantasy-land/contramap` method. The\n`fantasy-land/contramap` method takes one argument:\n\n    u['fantasy-land/contramap'](f)\n\n1. `f` must be a function,\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/contramap` is\n       unspecified.\n    2. `f` can return any value.\n    3. No parts of `f`'s return value should be checked.\n\n2. `fantasy-land/contramap` must return a value of the same Contravariant\n\n### Apply\n\nA value that implements the Apply specification must also\nimplement the [Functor](#functor) specification.\n\n1. `v['fantasy-land/ap'](u['fantasy-land/ap'](a['fantasy-land/map'](f => g => x => f(g(x)))))` is equivalent to `v['fantasy-land/ap'](u)['fantasy-land/ap'](a)` (composition)\n\n<a name=\"ap-method\"></a>\n\n#### `fantasy-land/ap` method\n\n```hs\nfantasy-land/ap :: Apply f => f a ~> f (a -> b) -> f b\n```\n\nA value which has an Apply must provide a `fantasy-land/ap` method. The `fantasy-land/ap`\nmethod takes one argument:\n\n    a['fantasy-land/ap'](b)\n\n1. `b` must be an Apply of a function\n\n    1. If `b` does not represent a function, the behaviour of `fantasy-land/ap` is\n       unspecified.\n    2. `b` must be same Apply as `a`.\n\n2. `a` must be an Apply of any value\n\n3. `fantasy-land/ap` must apply the function in Apply `b` to the value in\n   Apply `a`\n\n   1. No parts of return value of that function should be checked.\n\n4. The `Apply` returned by `fantasy-land/ap` must be the same as `a` and `b`\n\n### Applicative\n\nA value that implements the Applicative specification must also\nimplement the [Apply](#apply) specification.\n\n1. `v['fantasy-land/ap'](A['fantasy-land/of'](x => x))` is equivalent to `v` (identity)\n2. `A['fantasy-land/of'](x)['fantasy-land/ap'](A['fantasy-land/of'](f))` is equivalent to `A['fantasy-land/of'](f(x))` (homomorphism)\n3. `A['fantasy-land/of'](y)['fantasy-land/ap'](u)` is equivalent to `u['fantasy-land/ap'](A['fantasy-land/of'](f => f(y)))` (interchange)\n\n<a name=\"of-method\"></a>\n\n#### `fantasy-land/of` method\n\n```hs\nfantasy-land/of :: Applicative f => a -> f a\n```\n\nA value which has an Applicative must provide a `fantasy-land/of` function on its\n[type representative](#type-representatives). The `fantasy-land/of` function takes\none argument:\n\n    F['fantasy-land/of'](a)\n\nGiven a value `f`, one can access its type representative via the\n`constructor` property:\n\n    f.constructor['fantasy-land/of'](a)\n\n1. `fantasy-land/of` must provide a value of the same Applicative\n\n    1. No parts of `a` should be checked\n\n### Alt\n\nA value that implements the Alt specification must also implement\nthe [Functor](#functor) specification.\n\n1. `a['fantasy-land/alt'](b)['fantasy-land/alt'](c)` is equivalent to `a['fantasy-land/alt'](b['fantasy-land/alt'](c))` (associativity)\n2. `a['fantasy-land/alt'](b)['fantasy-land/map'](f)` is equivalent to `a['fantasy-land/map'](f)['fantasy-land/alt'](b['fantasy-land/map'](f))` (distributivity)\n\n<a name=\"alt-method\"></a>\n\n#### `fantasy-land/alt` method\n\n```hs\nfantasy-land/alt :: Alt f => f a ~> f a -> f a\n```\n\nA value which has a Alt must provide a `fantasy-land/alt` method. The\n`fantasy-land/alt` method takes one argument:\n\n    a['fantasy-land/alt'](b)\n\n1. `b` must be a value of the same Alt\n\n    1. If `b` is not the same Alt, behaviour of `fantasy-land/alt` is\n       unspecified.\n    2. `a` and `b` can contain any value of same type.\n    3. No parts of `a`'s and `b`'s containing value should be checked.\n\n2. `fantasy-land/alt` must return a value of the same Alt.\n\n### Plus\n\nA value that implements the Plus specification must also implement\nthe [Alt](#alt) specification.\n\n1. `x['fantasy-land/alt'](A['fantasy-land/zero']())` is equivalent to `x` (right identity)\n2. `A['fantasy-land/zero']()['fantasy-land/alt'](x)` is equivalent to `x` (left identity)\n3. `A['fantasy-land/zero']()['fantasy-land/map'](f)` is equivalent to `A['fantasy-land/zero']()` (annihilation)\n\n<a name=\"zero-method\"></a>\n\n#### `fantasy-land/zero` method\n\n```hs\nfantasy-land/zero :: Plus f => () -> f a\n```\n\nA value which has a Plus must provide a `fantasy-land/zero` function on its\n[type representative](#type-representatives):\n\n    A['fantasy-land/zero']()\n\nGiven a value `x`, one can access its type representative via the\n`constructor` property:\n\n    x.constructor['fantasy-land/zero']()\n\n1. `fantasy-land/zero` must return a value of the same Plus\n\n### Alternative\n\nA value that implements the Alternative specification must also implement\nthe [Applicative](#applicative) and [Plus](#plus) specifications.\n\n1. `x['fantasy-land/ap'](f['fantasy-land/alt'](g))` is equivalent to `x['fantasy-land/ap'](f)['fantasy-land/alt'](x['fantasy-land/ap'](g))` (distributivity)\n2. `x['fantasy-land/ap'](A['fantasy-land/zero']())` is equivalent to `A['fantasy-land/zero']()` (annihilation)\n\n### Foldable\n\n1. `u['fantasy-land/reduce']` is equivalent to `u['fantasy-land/reduce']((acc, x) => acc.concat([x]), []).reduce`\n\n<a name=\"reduce-method\"></a>\n\n#### `fantasy-land/reduce` method\n\n```hs\nfantasy-land/reduce :: Foldable f => f a ~> ((b, a) -> b, b) -> b\n```\n\nA value which has a Foldable must provide a `fantasy-land/reduce` method. The `fantasy-land/reduce`\nmethod takes two arguments:\n\n    u['fantasy-land/reduce'](f, x)\n\n1. `f` must be a binary function\n\n    1. if `f` is not a function, the behaviour of `fantasy-land/reduce` is unspecified.\n    2. The first argument to `f` must be the same type as `x`.\n    3. `f` must return a value of the same type as `x`.\n    4. No parts of `f`'s return value should be checked.\n\n1. `x` is the initial accumulator value for the reduction\n\n    1. No parts of `x` should be checked.\n\n### Traversable\n\nA value that implements the Traversable specification must also\nimplement the [Functor](#functor) and [Foldable](#foldable) specifications.\n\n1. `t(u['fantasy-land/traverse'](F, x => x))` is equivalent to `u['fantasy-land/traverse'](G, t)` for any\n   `t` such that `t(a)['fantasy-land/map'](f)` is equivalent to `t(a['fantasy-land/map'](f))` (naturality)\n\n2. `u['fantasy-land/traverse'](F, F['fantasy-land/of'])` is equivalent to `F['fantasy-land/of'](u)` for any Applicative `F`\n   (identity)\n\n3. `u['fantasy-land/traverse'](Compose, x => new Compose(x))` is equivalent to\n   `new Compose(u['fantasy-land/traverse'](F, x => x)['fantasy-land/map'](x => x['fantasy-land/traverse'](G, x => x)))` for\n   `Compose` defined below and any Applicatives `F` and `G` (composition)\n\n```js\nfunction Compose(c) {\n  this.c = c;\n}\n\nCompose['fantasy-land/of'] = function(x) {\n  return new Compose(F['fantasy-land/of'](G['fantasy-land/of'](x)));\n};\n\nCompose.prototype['fantasy-land/ap'] = function(f) {\n  return new Compose(this.c['fantasy-land/ap'](f.c['fantasy-land/map'](u => y => y['fantasy-land/ap'](u))));\n};\n\nCompose.prototype['fantasy-land/map'] = function(f) {\n  return new Compose(this.c['fantasy-land/map'](y => y['fantasy-land/map'](f)));\n};\n```\n\n<a name=\"traverse-method\"></a>\n\n#### `fantasy-land/traverse` method\n\n```hs\nfantasy-land/traverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n```\n\nA value which has a Traversable must provide a `fantasy-land/traverse` method. The `fantasy-land/traverse`\nmethod takes two arguments:\n\n    u['fantasy-land/traverse'](A, f)\n\n1. `A` must be the [type representative](#type-representatives) of an\n   Applicative.\n\n2. `f` must be a function which returns a value\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/traverse` is\n       unspecified.\n    2. `f` must return a value of the type represented by `A`.\n\n3. `fantasy-land/traverse` must return a value of the type represented by `A`.\n\n### Chain\n\nA value that implements the Chain specification must also\nimplement the [Apply](#apply) specification.\n\n1. `m['fantasy-land/chain'](f)['fantasy-land/chain'](g)` is equivalent to `m['fantasy-land/chain'](x => f(x)['fantasy-land/chain'](g))` (associativity)\n\n<a name=\"chain-method\"></a>\n\n#### `fantasy-land/chain` method\n\n```hs\nfantasy-land/chain :: Chain m => m a ~> (a -> m b) -> m b\n```\n\nA value which has a Chain must provide a `fantasy-land/chain` method. The `fantasy-land/chain`\nmethod takes one argument:\n\n    m['fantasy-land/chain'](f)\n\n1. `f` must be a function which returns a value\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/chain` is\n       unspecified.\n    2. `f` must return a value of the same Chain\n\n2. `fantasy-land/chain` must return a value of the same Chain\n\n### ChainRec\n\nA value that implements the ChainRec specification must also implement the [Chain](#chain) specification.\n\n1. `M['fantasy-land/chainRec']((next, done, v) => p(v) ? d(v)['fantasy-land/map'](done) : n(v)['fantasy-land/map'](next), i)`\n   is equivalent to\n   `(function step(v) { return p(v) ? d(v) : n(v)['fantasy-land/chain'](step); }(i))` (equivalence)\n2. Stack usage of `M['fantasy-land/chainRec'](f, i)` must be at most a constant multiple of the stack usage of `f` itself.\n\n<a name=\"chainRec-method\"></a>\n\n#### `fantasy-land/chainRec` method\n\n```hs\nfantasy-land/chainRec :: ChainRec m => ((a -> c, b -> c, a) -> m c, a) -> m b\n```\n\nA Type which has a ChainRec must provide a `fantasy-land/chainRec` function on its\n[type representative](#type-representatives). The `fantasy-land/chainRec` function\ntakes two arguments:\n\n    M['fantasy-land/chainRec'](f, i)\n\nGiven a value `m`, one can access its type representative via the\n`constructor` property:\n\n    m.constructor['fantasy-land/chainRec'](f, i)\n\n1. `f` must be a function which returns a value\n    1. If `f` is not a function, the behaviour of `fantasy-land/chainRec` is unspecified.\n    2. `f` takes three arguments `next`, `done`, `value`\n        1. `next` is a function which takes one argument of same type as `i` and can return any value\n        2. `done` is a function which takes one argument and returns the same type as the return value of `next`\n        3. `value` is some value of the same type as `i`\n    3. `f` must return a value of the same ChainRec which contains a value returned from either `done` or `next`\n2. `fantasy-land/chainRec` must return a value of the same ChainRec which contains a value of same type as argument of `done`\n\n### Monad\n\nA value that implements the Monad specification must also implement\nthe [Applicative](#applicative) and [Chain](#chain) specifications.\n\n1. `M['fantasy-land/of'](a)['fantasy-land/chain'](f)` is equivalent to `f(a)` (left identity)\n2. `m['fantasy-land/chain'](M['fantasy-land/of'])` is equivalent to `m` (right identity)\n\n### Extend\n\nA value that implements the Extend specification must also implement the [Functor](#functor) specification.\n\n1. `w['fantasy-land/extend'](g)['fantasy-land/extend'](f)` is equivalent to `w['fantasy-land/extend'](_w => f(_w['fantasy-land/extend'](g)))`\n\n<a name=\"extend-method\"></a>\n\n#### `fantasy-land/extend` method\n\n```hs\nfantasy-land/extend :: Extend w => w a ~> (w a -> b) -> w b\n```\n\nAn Extend must provide a `fantasy-land/extend` method. The `fantasy-land/extend`\nmethod takes one argument:\n\n     w['fantasy-land/extend'](f)\n\n1. `f` must be a function which returns a value\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/extend` is\n       unspecified.\n    2. `f` must return a value of type `v`, for some variable `v` contained in `w`.\n    3. No parts of `f`'s return value should be checked.\n\n2. `fantasy-land/extend` must return a value of the same Extend.\n\n### Comonad\n\nA value that implements the Comonad specification must also implement the [Extend](#extend) specification.\n\n1. `w['fantasy-land/extend'](_w => _w['fantasy-land/extract']())` is equivalent to `w` (left identity)\n2. `w['fantasy-land/extend'](f)['fantasy-land/extract']()` is equivalent to `f(w)` (right identity)\n\n<a name=\"extract-method\"></a>\n\n#### `fantasy-land/extract` method\n\n```hs\nfantasy-land/extract :: Comonad w => w a ~> () -> a\n```\n\nA value which has a Comonad must provide a `fantasy-land/extract` method on itself.\nThe `fantasy-land/extract` method takes no arguments:\n\n    w['fantasy-land/extract']()\n\n1. `fantasy-land/extract` must return a value of type `v`, for some variable `v` contained in `w`.\n    1. `v` must have the same type that `f` returns in `fantasy-land/extend`.\n\n### Bifunctor\n\nA value that implements the Bifunctor specification must also implement\nthe [Functor](#functor) specification.\n\n1. `p['fantasy-land/bimap'](a => a, b => b)` is equivalent to `p` (identity)\n2. `p['fantasy-land/bimap'](a => f(g(a)), b => h(i(b)))` is equivalent to `p['fantasy-land/bimap'](g, i)['fantasy-land/bimap'](f, h)` (composition)\n\n<a name=\"bimap-method\"></a>\n\n#### `fantasy-land/bimap` method\n\n```hs\nfantasy-land/bimap :: Bifunctor f => f a c ~> (a -> b, c -> d) -> f b d\n```\n\nA value which has a Bifunctor must provide a `fantasy-land/bimap` method. The `fantasy-land/bimap`\nmethod takes two arguments:\n\n    c['fantasy-land/bimap'](f, g)\n\n1. `f` must be a function which returns a value\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/bimap` is unspecified.\n    2. `f` can return any value.\n    3. No parts of `f`'s return value should be checked.\n\n2. `g` must be a function which returns a value\n\n    1. If `g` is not a function, the behaviour of `fantasy-land/bimap` is unspecified.\n    2. `g` can return any value.\n    3. No parts of `g`'s return value should be checked.\n\n3. `fantasy-land/bimap` must return a value of the same Bifunctor.\n\n### Profunctor\n\nA value that implements the Profunctor specification must also implement\nthe [Functor](#functor) specification.\n\n1. `p['fantasy-land/promap'](a => a, b => b)` is equivalent to `p` (identity)\n2. `p['fantasy-land/promap'](a => f(g(a)), b => h(i(b)))` is equivalent to `p['fantasy-land/promap'](f, i)['fantasy-land/promap'](g, h)` (composition)\n\n<a name=\"promap-method\"></a>\n\n#### `fantasy-land/promap` method\n\n```hs\nfantasy-land/promap :: Profunctor p => p b c ~> (a -> b, c -> d) -> p a d\n```\n\nA value which has a Profunctor must provide a `fantasy-land/promap` method.\n\nThe `fantasy-land/promap` method takes two arguments:\n\n    c['fantasy-land/promap'](f, g)\n\n1. `f` must be a function which returns a value\n\n    1. If `f` is not a function, the behaviour of `fantasy-land/promap` is unspecified.\n    2. `f` can return any value.\n    3. No parts of `f`'s return value should be checked.\n\n2. `g` must be a function which returns a value\n\n    1. If `g` is not a function, the behaviour of `fantasy-land/promap` is unspecified.\n    2. `g` can return any value.\n    3. No parts of `g`'s return value should be checked.\n\n3. `fantasy-land/promap` must return a value of the same Profunctor\n\n## Derivations\n\nWhen creating data types which satisfy multiple algebras, authors may choose\nto implement certain methods then derive the remaining methods. Derivations:\n\n  - [`fantasy-land/equals`][] may be derived from [`fantasy-land/lte`][]:\n\n    ```js\n    function equals(other) { return this['fantasy-land/lte'](other) && other['fantasy-land/lte'](this); }\n    ```\n\n  - [`fantasy-land/map`][] may be derived from [`fantasy-land/ap`][] and [`fantasy-land/of`][]:\n\n    ```js\n    function map(f) { return this['fantasy-land/ap'](this.constructor['fantasy-land/of'](f)); }\n    ```\n\n  - [`fantasy-land/map`][] may be derived from [`fantasy-land/chain`][] and [`fantasy-land/of`][]:\n\n    ```js\n    function map(f) { return this['fantasy-land/chain'](a => this.constructor['fantasy-land/of'](f(a))); }\n    ```\n\n  - [`fantasy-land/map`][] may be derived from [`fantasy-land/bimap`][]:\n\n    ```js\n    function map(f) { return this['fantasy-land/bimap'](a => a, f); }\n    ```\n\n  - [`fantasy-land/map`][] may be derived from [`fantasy-land/promap`][]:\n\n    ```js\n    function map(f) { return this['fantasy-land/promap'](a => a, f); }\n    ```\n\n  - [`fantasy-land/ap`][] may be derived from [`fantasy-land/chain`][]:\n\n    ```js\n    function ap(m) { return m['fantasy-land/chain'](f => this['fantasy-land/map'](f)); }\n    ```\n\n  - [`fantasy-land/reduce`][] may be derived as follows:\n\n    ```js\n    function reduce(f, acc) {\n      function Const(value) {\n        this.value = value;\n      }\n      Const['fantasy-land/of'] = function(_) {\n        return new Const(acc);\n      };\n      Const.prototype['fantasy-land/map'] = function(_) {\n        return this;\n      };\n      Const.prototype['fantasy-land/ap'] = function(b) {\n        return new Const(f(b.value, this.value));\n      };\n      return this['fantasy-land/traverse'](x => new Const(x), Const['fantasy-land/of']).value;\n    }\n    ```\n\n  - [`fantasy-land/map`][] may be derived as follows:\n\n    ```js\n    function map(f) {\n      function Id(value) {\n        this.value = value;\n      }\n      Id['fantasy-land/of'] = function(x) {\n        return new Id(x);\n      };\n      Id.prototype['fantasy-land/map'] = function(f) {\n        return new Id(f(this.value));\n      };\n      Id.prototype['fantasy-land/ap'] = function(b) {\n        return new Id(this.value(b.value));\n      };\n      return this['fantasy-land/traverse'](x => Id['fantasy-land/of'](f(x)), Id['fantasy-land/of']).value;\n    }\n    ```\n\n  - [`fantasy-land/filter`][] may be derived from [`fantasy-land/of`][], [`fantasy-land/chain`][], and [`fantasy-land/zero`][]:\n\n    ```js\n    function filter(pred) {\n      var F = this.constructor;\n      return this['fantasy-land/chain'](x => pred(x) ? F['fantasy-land/of'](x) : F['fantasy-land/zero']());\n    }\n    ```\n\n  - [`fantasy-land/filter`][] may be derived from [`fantasy-land/concat`][], [`fantasy-land/of`][], [`fantasy-land/zero`][], and\n    [`fantasy-land/reduce`][]:\n\n    ```js\n    function filter(pred) {\n      var F = this.constructor;\n      return this['fantasy-land/reduce']((f, x) => pred(x) ? f['fantasy-land/concat'](F['fantasy-land/of'](x)) : f, F['fantasy-land/zero']());\n    }\n    ```\n\nIf a data type provides a method which *could* be derived, its behaviour must\nbe equivalent to that of the derivation (or derivations).\n\n## Notes\n\n1. If there's more than a single way to implement the methods and\n   laws, the implementation should choose one and provide wrappers for\n   other uses.\n2. It's discouraged to overload the specified methods. It can easily\n   result in broken and buggy behaviour.\n3. It is recommended to throw an exception on unspecified behaviour.\n4. An `Identity` container which implements many of the methods is provided by\n   [sanctuary-identity](https://github.com/sanctuary-js/sanctuary-identity).\n\n\n[`fantasy-land/ap`]: #ap-method\n[`fantasy-land/bimap`]: #bimap-method\n[`fantasy-land/chain`]: #chain-method\n[`fantasy-land/concat`]: #concat-method\n[`fantasy-land/equals`]: #equals-method\n[`fantasy-land/filter`]: #filter-method\n[`fantasy-land/lte`]: #lte-method\n[`fantasy-land/map`]: #map-method\n[`fantasy-land/of`]: #of-method\n[`fantasy-land/promap`]: #promap-method\n[`fantasy-land/reduce`]: #reduce-method\n[`fantasy-land/zero`]: #zero-method\n\n## Alternatives\n\nThere also exists [Static Land Specification](https://github.com/rpominov/static-land)\nwith exactly the same ideas as Fantasy Land but based on static methods instead of instance methods.\n",
        "releases": [
            {
                "name": "Version 5.0.1",
                "date": "2022-12-05T10:05:00Z"
            },
            {
                "name": "Version 5.0.0",
                "date": "2021-04-26T20:03:39Z"
            },
            {
                "name": "Version 4.1.0",
                "date": "2020-05-25T09:40:45Z"
            },
            {
                "name": "Version 4.0.1",
                "date": "2019-03-02T21:22:26Z"
            },
            {
                "name": "Version 4.0.0",
                "date": "2019-03-02T21:20:43Z"
            },
            {
                "name": "Version 3.5.0",
                "date": "2018-01-07T11:34:22Z"
            },
            {
                "name": "Version 3.4.0",
                "date": "2017-10-14T14:06:33Z"
            },
            {
                "name": "Version 3.3.0",
                "date": "2017-05-17T01:35:17Z"
            },
            {
                "name": "Version 3.2.0",
                "date": "2017-04-04T20:17:58Z"
            },
            {
                "name": "Version 3.1.0",
                "date": "2017-03-04T14:00:02Z"
            },
            {
                "name": "Version 3.0.0",
                "date": "2017-01-17T15:39:25Z"
            },
            {
                "name": "Version 1.0.1",
                "date": "2016-09-16T15:28:00Z"
            },
            {
                "name": "Version 1.0.0",
                "date": "2016-09-14T08:36:30Z"
            },
            {
                "name": "Version 0.3.0",
                "date": "2016-12-27T00:33:43Z"
            },
            {
                "name": "Version 0.2.1",
                "date": "2016-02-07T11:38:46Z"
            },
            {
                "name": "Version 0.2.0",
                "date": "2016-12-26T23:14:21Z"
            },
            {
                "name": "Version 0.1.0",
                "date": "2016-12-26T23:08:21Z"
            },
            {
                "name": "Version 2.2.0",
                "date": "2016-12-24T22:42:28Z"
            },
            {
                "name": "Version 2.1.0",
                "date": "2016-11-05T17:27:21Z"
            },
            {
                "name": "Version 2.0.0",
                "date": "2016-10-25T21:01:06Z"
            }
        ]
    }
}
{
    "https://api.github.com/repos/emilk/egui": {
        "forks": 1656,
        "watchers": 23514,
        "stars": 23514,
        "languages": {
            "Rust": 3290716,
            "Python": 16398,
            "HTML": 12697,
            "Shell": 10686,
            "WGSL": 6673,
            "GLSL": 2796
        },
        "commits": [
            "2025-01-21T10:56:45Z",
            "2025-01-20T17:06:35Z",
            "2025-01-16T20:12:19Z",
            "2025-01-16T16:00:29Z",
            "2025-01-14T07:44:39Z",
            "2025-01-13T07:29:13Z",
            "2025-01-11T17:05:57Z",
            "2025-01-08T14:45:46Z",
            "2025-01-08T13:24:58Z",
            "2025-01-07T12:26:57Z",
            "2025-01-07T07:37:23Z",
            "2025-01-07T07:35:58Z",
            "2025-01-07T07:33:44Z",
            "2025-01-06T18:29:53Z",
            "2025-01-06T09:03:33Z",
            "2025-01-06T08:19:17Z",
            "2025-01-04T09:29:22Z",
            "2025-01-03T15:23:31Z",
            "2025-01-03T13:55:51Z",
            "2025-01-03T13:54:57Z",
            "2025-01-02T22:50:40Z",
            "2025-01-02T16:48:39Z",
            "2025-01-02T15:22:44Z",
            "2025-01-02T15:05:52Z",
            "2025-01-02T14:34:28Z",
            "2025-01-02T14:32:43Z",
            "2025-01-02T13:56:27Z",
            "2025-01-02T13:55:49Z",
            "2025-01-02T13:29:50Z",
            "2024-12-31T12:37:05Z"
        ],
        "creation_date": "2019-01-13T15:39:15Z",
        "contributors": 30,
        "topics": [
            "egui",
            "game-development",
            "gamedev",
            "gui",
            "imgui",
            "rust",
            "wasm"
        ],
        "subscribers": 138,
        "readme": "# \ud83d\udd8c egui: an easy-to-use GUI in pure Rust\n\n[<img alt=\"github\" src=\"https://img.shields.io/badge/github-emilk/egui-8da0cb?logo=github\" height=\"20\">](https://github.com/emilk/egui)\n[![Latest version](https://img.shields.io/crates/v/egui.svg)](https://crates.io/crates/egui)\n[![Documentation](https://docs.rs/egui/badge.svg)](https://docs.rs/egui)\n[![unsafe forbidden](https://img.shields.io/badge/unsafe-forbidden-success.svg)](https://github.com/rust-secure-code/safety-dance/)\n[![Build Status](https://github.com/emilk/egui/workflows/CI/badge.svg)](https://github.com/emilk/egui/actions?workflow=CI)\n[![MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/emilk/egui/blob/master/LICENSE-MIT)\n[![Apache](https://img.shields.io/badge/license-Apache-blue.svg)](https://github.com/emilk/egui/blob/master/LICENSE-APACHE)\n[![Discord](https://img.shields.io/discord/900275882684477440?label=egui%20discord)](https://discord.gg/JFcEma9bJq)\n\n\n<div align=\"center\">\n<a href=\"https://www.rerun.io/\"><img src=\"media/rerun_io_logo.png\" width=\"250\"></a>\n\negui development is sponsored by [Rerun](https://www.rerun.io/), a startup building<br>\nan SDK for visualizing streams of multimodal data.\n</div>\n\n---\n\n\ud83d\udc49 [Click to run the web demo](https://www.egui.rs/#demo) \ud83d\udc48\n\negui (pronounced \"e-gooey\") is a simple, fast, and highly portable immediate mode GUI library for Rust. egui runs on the web, natively, and [in your favorite game engine](#integrations).\n\negui aims to be the easiest-to-use Rust GUI library, and the simplest way to make a web app in Rust.\n\negui can be used anywhere you can draw textured triangles, which means you can easily integrate it into your game engine of choice.\n\n[`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe) is the official egui framework, which supports writing apps for Web, Linux, Mac, Windows, and Android.\n\n\n## Example\n\n``` rust\nui.heading(\"My egui Application\");\nui.horizontal(|ui| {\n    ui.label(\"Your name: \");\n    ui.text_edit_singleline(&mut name);\n});\nui.add(egui::Slider::new(&mut age, 0..=120).text(\"age\"));\nif ui.button(\"Increment\").clicked() {\n    age += 1;\n}\nui.label(format!(\"Hello '{name}', age {age}\"));\nui.image(egui::include_image!(\"ferris.png\"));\n```\n\n<img alt=\"Dark mode\" src=\"media/demo.gif\"> &nbsp; &nbsp; <img alt=\"Light mode\" src=\"media/demo_light_mode.png\" height=\"278\">\n\n## Sections:\n\n* [Example](#example)\n* [Quick start](#quick-start)\n* [Demo](#demo)\n* [Goals](#goals)\n* [State / features](#state)\n* [Dependencies](#dependencies)\n* [Who is egui for?](#who-is-egui-for)\n* [Integrations](#integrations)\n* [Why immediate mode](#why-immediate-mode)\n* [FAQ](#faq)\n* [Other](#other)\n* [Credits](#credits)\n\n([egui \u7684\u4e2d\u6587\u7ffb\u8bd1\u6587\u6863 / chinese translation](https://github.com/Re-Ch-Love/egui-doc-cn/blob/main/README_zh-hans.md))\n\n\n## Quick start\n\nThere are simple examples in [the `examples/` folder](https://github.com/emilk/egui/blob/master/examples/). If you want to write a web app, then go to <https://github.com/emilk/eframe_template/> and follow the instructions. The official docs are at <https://docs.rs/egui>. For inspiration and more examples, check out the [the egui web demo](https://www.egui.rs/#demo) and follow the links in it to its source code.\n\nIf you want to integrate egui into an existing engine, go to the [Integrations](#integrations) section.\n\nIf you have questions, use [GitHub Discussions](https://github.com/emilk/egui/discussions). There is also [an egui discord server](https://discord.gg/JFcEma9bJq). If you want to contribute to egui, please read the [Contributing Guidelines](https://github.com/emilk/egui/blob/master/CONTRIBUTING.md).\n\n## Demo\n\n[Click to run egui web demo](https://www.egui.rs/#demo) (works in any browser with Wasm and WebGL support). Uses [`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe).\n\nTo test the demo app locally, run `cargo run --release -p egui_demo_app`.\n\nThe native backend is [`egui_glow`](https://github.com/emilk/egui/tree/master/crates/egui_glow) (using [`glow`](https://crates.io/crates/glow)) and should work out-of-the-box on Mac and Windows, but on Linux you need to first run:\n\n`sudo apt-get install -y libclang-dev libgtk-3-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libxkbcommon-dev libssl-dev`\n\nOn Fedora Rawhide you need to run:\n\n`dnf install clang clang-devel clang-tools-extra libxkbcommon-devel pkg-config openssl-devel libxcb-devel gtk3-devel atk fontconfig-devel`\n\n**NOTE**: This is just for the demo app - egui itself is completely platform agnostic!\n\n## Goals\n\n* The easiest to use GUI library\n* Responsive: target 60 Hz in debug build\n* Friendly: difficult to make mistakes, and shouldn't panic\n* Portable: the same code works on the web and as a native app\n* Easy to integrate into any environment\n* A simple 2D graphics API for custom painting ([`epaint`](https://docs.rs/epaint)).\n* Pure immediate mode: no callbacks\n* Extensible: [easy to write your own widgets for egui](https://github.com/emilk/egui/blob/master/crates/egui_demo_lib/src/demo/toggle_switch.rs)\n* Modular: You should be able to use small parts of egui and combine them in new ways\n* Safe: there is no `unsafe` code in egui\n* Minimal dependencies\n\negui is *not* a framework. egui is a library you call into, not an environment you program for.\n\n**NOTE**: egui does not claim to have reached all these goals yet! egui is still work in progress.\n\n### Non-goals\n\n* Become the most powerful GUI library\n* Native looking interface\n\n## State\n\negui is in active development. It works well for what it does, but it lacks many features and the interfaces are still in flux. New releases will have breaking changes.\n\nStill, egui can be used to create professional looking applications, like [the Rerun Viewer](https://app.rerun.io/).\n\n### Features\n\n* Widgets: label, text button, hyperlink, checkbox, radio button, slider, draggable value, text editing, color picker, spinner\n* Images\n* Layouts: horizontal, vertical, columns, automatic wrapping\n* Text editing: multiline, copy/paste, undo, emoji supports\n* Windows: move, resize, name, minimize and close. Automatically sized and positioned.\n* Regions: resizing, vertical scrolling, collapsing headers (sections), panels\n* Rendering: Anti-aliased rendering of lines, circles, text and convex polygons.\n* Tooltips on hover\n* Accessibility via [AccessKit](https://accesskit.dev/)\n* Label text selection\n* And more!\n\nCheck out the [3rd party egui crates wiki](https://github.com/emilk/egui/wiki/3rd-party-egui-crates) for even more \nwidgets and features, maintained by the community.\n\n<img src=\"media/widget_gallery_0.23.gif\" width=\"50%\">\n\nLight Theme:\n\n<img src=\"media/widget_gallery_0.23_light.png\" width=\"50%\">\n\n\n## Dependencies\n`egui` has a minimal set of default dependencies:\n\n* [`ab_glyph`](https://crates.io/crates/ab_glyph)\n* [`ahash`](https://crates.io/crates/ahash)\n* [`bitflags`](https://crates.io/crates/bitflags)\n* [`nohash-hasher`](https://crates.io/crates/nohash-hasher)\n* [`parking_lot`](https://crates.io/crates/parking_lot)\n\nHeavier dependencies are kept out of `egui`, even as opt-in.\nNo code that isn't fully Wasm-friendly is part of `egui`.\n\nTo load images into `egui` you can use the official [`egui_extras`](https://github.com/emilk/egui/tree/master/crates/egui_extras) crate.\n\n[`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe) on the other hand has a lot of dependencies, including [`winit`](https://crates.io/crates/winit), [`image`](https://crates.io/crates/image), graphics crates, clipboard crates, etc,\n\n## Who is egui for?\n\negui aims to be the best choice when you want a simple way to create a GUI, or you want to add a GUI to a game engine.\n\nIf you are not using Rust, egui is not for you. If you want a GUI that looks native, egui is not for you. If you want something that doesn't break when you upgrade it, egui isn't for you (yet).\n\nBut if you are writing something interactive in Rust that needs a simple GUI, egui may be for you.\n\n\n## Integrations\n\negui is built to be easy to integrate into any existing game engine or platform you are working on.\negui itself doesn't know or care on what OS it is running or how to render things to the screen - that is the job of the egui integration.\n\nAn integration needs to do the following each frame:\n\n* **Input**: Gather input (mouse, touches, keyboard, screen size, etc) and give it to egui\n* Call into the application GUI code\n* **Output**: Handle egui output (cursor changes, paste, texture allocations, \u2026)\n* **Painting**: Render the triangle mesh egui produces (see [OpenGL example](https://github.com/emilk/egui/blob/master/crates/egui_glow/src/painter.rs))\n\n### Official integrations\n\nThese are the official egui integrations:\n\n* [`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe) for compiling the same app to web/wasm and desktop/native. Uses `egui-winit` and `egui_glow` or `egui-wgpu`\n* [`egui_glow`](https://github.com/emilk/egui/tree/master/crates/egui_glow) for rendering egui with [glow](https://github.com/grovesNL/glow) on native and web, and for making native apps\n* [`egui-wgpu`](https://github.com/emilk/egui/tree/master/crates/egui-wgpu) for [wgpu](https://crates.io/crates/wgpu) (WebGPU API)\n* [`egui-winit`](https://github.com/emilk/egui/tree/master/crates/egui-winit) for integrating with [winit](https://github.com/rust-windowing/winit)\n\n### 3rd party integrations\n\nCheck the wiki to find [3rd party integrations](https://github.com/emilk/egui/wiki/3rd-party-integrations) \nand [egui crates](https://github.com/emilk/egui/wiki/3rd-party-egui-crates).\n\n### Writing your own egui integration\nMissing an integration for the thing you're working on? Create one, it's easy!\nSee <https://docs.rs/egui/latest/egui/#integrating-with-egui>.\n\n\n## Why immediate mode\n\n`egui` is an [immediate mode GUI library](https://en.wikipedia.org/wiki/Immediate_mode_GUI), as opposed to a *retained mode* GUI library. The difference between retained mode and immediate mode is best illustrated with the example of a button: In a retained GUI you create a button, add it to some UI and install some on-click handler (callback). The button is retained in the UI, and to change the text on it you need to store some sort of reference to it. By contrast, in immediate mode you show the button and interact with it immediately, and you do so every frame (e.g. 60 times per second). This means there is no need for any on-click handler, nor to store any reference to it. In `egui` this looks like this: `if ui.button(\"Save file\").clicked() { save(file); }`.\n\nA more detailed description of immediate mode can be found [in the `egui` docs](https://docs.rs/egui/latest/egui/#understanding-immediate-mode).\n\nThere are advantages and disadvantages to both systems.\n\nThe short of it is this: immediate mode GUI libraries are easier to use, but less powerful.\n\n### Advantages of immediate mode\n#### Usability\nThe main advantage of immediate mode is that the application code becomes vastly simpler:\n\n* You never need to have any on-click handlers and callbacks that disrupts your code flow.\n* You don't have to worry about a lingering callback calling something that is gone.\n* Your GUI code can easily live in a simple function (no need for an object just for the UI).\n* You don't have to worry about app state and GUI state being out-of-sync (i.e. the GUI showing something outdated), because the GUI isn't storing any state - it is showing the latest state *immediately*.\n\nIn other words, a whole lot of code, complexity and bugs are gone, and you can focus your time on something more interesting than writing GUI code.\n\n### Disadvantages of immediate mode\n\n#### Layout\nThe main disadvantage of immediate mode is it makes layout more difficult. Say you want to show a small dialog window in the center of the screen. To position the window correctly the GUI library must first know the size of it. To know the size of the window the GUI library must first layout the contents of the window. In retained mode this is easy: the GUI library does the window layout, positions the window, then checks for interaction (\"was the OK button clicked?\").\n\nIn immediate mode you run into a paradox: to know the size of the window, we must do the layout, but the layout code also checks for interaction (\"was the OK button clicked?\") and so it needs to know the window position *before* showing the window contents. This means we must decide where to show the window *before* we know its size!\n\nThis is a fundamental shortcoming of immediate mode GUIs, and any attempt to resolve it comes with its own downsides.\n\nOne workaround is to store the size and use it the next frame. This produces a frame-delay for the correct layout, producing occasional flickering the first frame something shows up. `egui` does this for some things such as windows and grid layouts.\n\nThe \"first-frame jitter\" can be covered up with an extra _pass_, which egui supports via `Context::request_discard`.\nThe downside of this is the added CPU cost of a second pass, so egui only does this in very rare circumstances (the majority of frames are single-pass).\n\nFor \"atomic\" widgets (e.g. a button) `egui` knows the size before showing it, so centering buttons, labels etc is possible in `egui` without any special workarounds.\n\nSee [this issue](https://github.com/emilk/egui/issues/4378) for more.\n\n#### CPU usage\nSince an immediate mode GUI does a full layout each frame, the layout code needs to be quick. If you have a very complex GUI this can tax the CPU. In particular, having a very large UI in a scroll area (with very long scrollback) can be slow, as the content needs to be laid out each frame.\n\nIf you design the GUI with this in mind and refrain from huge scroll areas (or only lay out the part that is in view) then the performance hit is generally pretty small. For most cases you can expect `egui` to take up 1-2 ms per frame, but `egui` still has a lot of room for optimization (it's not something I've focused on yet). `egui` only repaints when there is interaction (e.g. mouse movement) or an animation, so if your app is idle, no CPU is wasted.\n\nIf your GUI is highly interactive, then immediate mode may actually be more performant compared to retained mode. Go to any web page and resize the browser window, and you'll notice that the browser is very slow to do the layout and eats a lot of CPU doing it. Resize a window in `egui` by contrast, and you'll get smooth 60 FPS at no extra CPU cost.\n\n\n#### IDs\nThere are some GUI state that you want the GUI library to retain, even in an immediate mode library such as `egui`. This includes position and sizes of windows and how far the user has scrolled in some UI. In these cases you need to provide `egui` with a seed of a unique identifier (unique within the parent UI). For instance: by default `egui` uses the window titles as unique IDs to store window positions. If you want two windows with the same name (or one window with a dynamic name) you must provide some other ID source to `egui` (some unique integer or string).\n\n`egui` also needs to track which widget is being interacted with (e.g. which slider is being dragged). `egui` uses unique IDs for this as well, but in this case the IDs are automatically generated, so there is no need for the user to worry about it. In particular, having two buttons with the same name is no problem (this is in contrast with [`Dear ImGui`](https://github.com/ocornut/imgui)).\n\nOverall, ID handling is a rare inconvenience, and not a big disadvantage.\n\n\n## FAQ\n\nAlso see [GitHub Discussions](https://github.com/emilk/egui/discussions/categories/q-a).\n\n### Can I use `egui` with non-latin characters?\nYes! But you need to install your own font (`.ttf` or `.otf`) using [`Context::set_fonts`](https://docs.rs/egui/latest/egui/struct.Context.html#method.set_fonts).\n\n### Can I customize the look of egui?\nYes! You can customize the colors, spacing, fonts and sizes of everything using `Context::set_style`.\n\nThis is not yet as powerful as say CSS, [but this is going to improve](https://github.com/emilk/egui/issues/3284).\n\nHere is an example (from https://github.com/a-liashenko/TinyPomodoro):\n\n<img src=\"media/pompodoro-skin.png\" width=\"50%\">\n\n### How do I use egui with `async`?\nIf you call `.await` in your GUI code, the UI will freeze, which is very bad UX. Instead, keep the GUI thread non-blocking and communicate with any concurrent tasks (`async` tasks or other threads) with something like:\n* Channels (e.g. [`std::sync::mpsc::channel`](https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html)). Make sure to use [`try_recv`](https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.try_recv) so you don't block the gui thread!\n* `Arc<Mutex<Value>>` (background thread sets a value; GUI thread reads it)\n* [`poll_promise::Promise`](https://docs.rs/poll-promise)\n* [`eventuals::Eventual`](https://docs.rs/eventuals/latest/eventuals/struct.Eventual.html)\n* [`tokio::sync::watch::channel`](https://docs.rs/tokio/latest/tokio/sync/watch/fn.channel.html)\n\n### How do I create a file dialog?\n\nThe async version of [rfd](https://docs.rs/rfd/latest/rfd/) supports both native and Wasm. See example app here https://github.com/woelper/egui_pick_file which also has a demo available via [gitub pages](https://woelper.github.io/egui_pick_file/).\n\n### What about accessibility, such as screen readers?\negui includes optional support for [AccessKit](https://accesskit.dev/), which currently implements the native accessibility APIs on Windows and macOS. This feature is enabled by default in eframe. For platforms that AccessKit doesn't yet support, including web, there is an experimental built-in screen reader; in [the web demo](https://www.egui.rs/#demo) you can enable it in the \"Backend\" tab.\n\nThe original discussion of accessibility in egui is at <https://github.com/emilk/egui/issues/167>. Now that AccessKit support is merged, providing a strong foundation for future accessibility work, please open new issues on specific accessibility problems.\n\n### What is the difference between [egui](https://docs.rs/egui) and [eframe](https://github.com/emilk/egui/tree/master/crates/eframe)?\n\n`egui` is a 2D user interface library for laying out and interacting with buttons, sliders, etc.\n`egui` has no idea if it is running on the web or natively, and does not know how to collect input or show things on screen.\nThat is the job of *the integration* or *backend*.\n\nIt is common to use `egui` from a game engine (using e.g. [`bevy_egui`](https://docs.rs/bevy_egui)),\nbut you can also use `egui` stand-alone using `eframe`. `eframe` has integration for web and native, and handles input and rendering.\nThe _frame_ in `eframe` stands both for the frame in which your egui app resides and also for \"framework\" (`eframe` is a framework, `egui` is a library).\n\n### How do I render 3D stuff in an egui area?\nThere are multiple ways to combine egui with 3D. The simplest way is to use a 3D library and have egui sit on top of the 3D view. See for instance [`bevy_egui`](https://github.com/mvlabat/bevy_egui) or [`three-d`](https://github.com/asny/three-d).\n\nIf you want to embed 3D into an egui view there are two options:\n\n#### `Shape::Callback`\nExample:\n* <https://github.com/emilk/egui/blob/master/examples/custom_3d_glow/src/main.rs>\n\n`Shape::Callback` will call your code when egui gets painted, to show anything using whatever the background rendering context is. When using [`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe) this will be [`glow`](https://github.com/grovesNL/glow). Other integrations will give you other rendering contexts, if they support `Shape::Callback` at all.\n\n#### Render-to-texture\nYou can also render your 3D scene to a texture and display it using [`ui.image(\u2026)`](https://docs.rs/egui/latest/egui/struct.Ui.html#method.image). You first need to convert the native texture to an [`egui::TextureId`](https://docs.rs/egui/latest/egui/enum.TextureId.html), and how to do this depends on the integration you use.\n\nExamples:\n* Using [`egui-miniquad`]( https://github.com/not-fl3/egui-miniquad): https://github.com/not-fl3/egui-miniquad/blob/master/examples/render_to_egui_image.rs\n\n\n## Other\n\n### Conventions and design choices\n\nAll coordinates are in screen space coordinates, with (0, 0) in the top left corner\n\nAll coordinates are in logical \"points\" which may consist of many physical pixels.\n\nAll colors have premultiplied alpha, unless otherwise stated.\n\negui uses the builder pattern for construction widgets. For instance: `ui.add(Label::new(\"Hello\").text_color(RED));` I am not a big fan of the builder pattern (it is quite verbose both in implementation and in use) but until Rust has named, default arguments it is the best we can do. To alleviate some of the verbosity there are common-case helper functions, like `ui.label(\"Hello\");`.\n\nInstead of using matching `begin/end` style function calls (which can be error prone) egui prefers to use `FnOnce` closures passed to a wrapping function. Lambdas are a bit ugly though, so I'd like to find a nicer solution to this. More discussion of this at <https://github.com/emilk/egui/issues/1004#issuecomment-1001650754>.\n\negui uses a single `RwLock` for short-time locks on each access of `Context` data. This is to leave implementation simple and transactional and allow users to run their UI logic in parallel. Instead of creating mutex guards, egui uses closures passed to a wrapping function, e.g. `ctx.input(|i| i.key_down(Key::A))`. This is to make it less likely that a user would accidentally double-lock the `Context`, which would lead to a deadlock.\n\n### Inspiration\n\nThe one and only [Dear ImGui](https://github.com/ocornut/imgui) is a great Immediate Mode GUI for C++ which works with many backends. That library revolutionized how I think about GUI code and turned GUI programming from something I hated to do to something I now enjoy.\n\n### Name\n\nThe name of the library and the project is \"egui\" and pronounced as \"e-gooey\". Please don't write it as \"EGUI\".\n\nThe library was originally called \"Emigui\", but was renamed to \"egui\" in 2020.\n\n## Credits\n\negui author and maintainer: Emil Ernerfeldt ([@emilk](https://github.com/emilk)).\n\nNotable contributions by:\n\n* [@n2](https://github.com/n2): [Mobile web input and IME support](https://github.com/emilk/egui/pull/253)\n* [@optozorax](https://github.com/optozorax): [Arbitrary widget data storage](https://github.com/emilk/egui/pull/257)\n* [@quadruple-output](https://github.com/quadruple-output): [Multitouch](https://github.com/emilk/egui/pull/306)\n* [@EmbersArc](https://github.com/EmbersArc): [Plots](https://github.com/emilk/egui/pulls?q=+is%3Apr+author%3AEmbersArc)\n* [@AsmPrgmC3](https://github.com/AsmPrgmC3): [Proper sRGBA blending for web](https://github.com/emilk/egui/pull/650)\n* [@AlexApps99](https://github.com/AlexApps99): [`egui_glow`](https://github.com/emilk/egui/pull/685)\n* [@mankinskin](https://github.com/mankinskin): [Context menus](https://github.com/emilk/egui/pull/543)\n* [@t18b219k](https://github.com/t18b219k): [Port glow painter to web](https://github.com/emilk/egui/pull/868)\n* [@danielkeller](https://github.com/danielkeller): [`Context` refactor](https://github.com/emilk/egui/pull/1050)\n* [@MaximOsipenko](https://github.com/MaximOsipenko): [`Context` lock refactor](https://github.com/emilk/egui/pull/2625)\n* [@mwcampbell](https://github.com/mwcampbell): [AccessKit](https://github.com/AccessKit/accesskit) [integration](https://github.com/emilk/egui/pull/2294)\n* [@hasenbanck](https://github.com/hasenbanck), [@s-nie](https://github.com/s-nie), [@Wumpf](https://github.com/Wumpf): [`egui-wgpu`](https://github.com/emilk/egui/tree/master/crates/egui-wgpu)\n* [@jprochazk](https://github.com/jprochazk): [egui image API](https://github.com/emilk/egui/issues/3291)\n* And [many more](https://github.com/emilk/egui/graphs/contributors?type=a).\n\negui is licensed under [MIT](LICENSE-MIT) OR [Apache-2.0](LICENSE-APACHE).\n\n* The flattening algorithm for the cubic bezier curve and quadratic bezier curve is from [lyon_geom](https://docs.rs/lyon_geom/latest/lyon_geom/)\n\nDefault fonts:\n\n* `emoji-icon-font.ttf`: [Copyright (c) 2014 John Slegers](https://github.com/jslegers/emoji-icon-font) , MIT License\n* `Hack-Regular.ttf`: <https://github.com/source-foundry/Hack>, [MIT Licence](https://github.com/source-foundry/Hack/blob/master/LICENSE.md)\n* `NotoEmoji-Regular.ttf`: [google.com/get/noto](https://google.com/get/noto), [SIL Open Font License](https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL)\n* `Ubuntu-Light.ttf` by [Dalton Maag](http://www.daltonmaag.com/): [Ubuntu font licence](https://ubuntu.com/legal/font-licence)\n\n---\n\n<div align=\"center\">\n<a href=\"https://www.rerun.io/\"><img src=\"media/rerun_io_logo.png\" width=\"440\"></a>\n\negui development is sponsored by [Rerun](https://www.rerun.io/), a startup building<br>\nan SDK for visualizing streams of multimodal data.\n</div>\n",
        "releases": [
            {
                "name": "0.30.0 - egui_kittest and modals",
                "date": "2024-12-16T17:11:55Z"
            },
            {
                "name": "0.29.1 - Bug fixes",
                "date": "2024-10-01T08:12:03Z"
            },
            {
                "name": "0.29.0 - Multipass, `UiBuilder`, & visual improvements",
                "date": "2024-09-26T13:35:19Z"
            },
            {
                "name": "0.28.1 - Tooltip tweaks",
                "date": "2024-07-05T10:13:44Z"
            },
            {
                "name": "0.28.0 - Sizing pass, and better eframe web",
                "date": "2024-07-03T13:02:35Z"
            },
            {
                "name": "0.27.2 - Fix blurry text on web, and other bug fixes",
                "date": "2024-04-02T16:17:44Z"
            },
            {
                "name": "0.27.1 - Bug fixes for shadows and touch input",
                "date": "2024-03-29T11:57:49Z"
            },
            {
                "name": "0.27.0 - Nicer menus and new hit test logic",
                "date": "2024-03-26T16:21:33Z"
            },
            {
                "name": "0.26.2 - Response.interact/context_menu fix",
                "date": "2024-02-14T09:51:02Z"
            },
            {
                "name": "0.26.1 - Bug Fixes",
                "date": "2024-02-11T08:05:30Z"
            },
            {
                "name": "0.26.0 - Text selection in labels",
                "date": "2024-02-05T16:43:35Z"
            },
            {
                "name": "0.26.0 Alpha 1 - Selectable Labels",
                "date": "2024-02-01T19:31:59Z"
            },
            {
                "name": "0.25.0 - Better keyboard input",
                "date": "2024-01-08T11:36:42Z"
            },
            {
                "name": "0.24.1 - Bug fixes",
                "date": "2023-11-30T16:54:11Z"
            },
            {
                "name": "0.24.0 - Multi-viewport",
                "date": "2023-11-23T15:28:08Z"
            },
            {
                "name": "0.23.0 - New image API",
                "date": "2023-09-28T06:47:40Z"
            },
            {
                "name": "0.22.0 - A plethora of small improvements",
                "date": "2023-05-23T18:07:21Z"
            },
            {
                "name": "0.21.0 - Deadlock fix and winit update",
                "date": "2023-02-08T19:39:51Z"
            },
            {
                "name": "0.20.1 - Fix key-repeats",
                "date": "2022-12-11T16:21:46Z"
            },
            {
                "name": "0.20.0 - AccessKit, prettier text, overlapping widgets",
                "date": "2022-12-08T14:27:37Z"
            },
            {
                "name": "0.19.0 - wgpu backend, repaint_after, continue-after-close",
                "date": "2022-08-20T15:05:47Z"
            },
            {
                "name": "0.18.0 - Shape::Callback, Table, and better text contrast",
                "date": "2022-04-30T18:35:47Z"
            },
            {
                "name": "0.17.0 - Improved font selection and image handling",
                "date": "2022-02-22T18:47:52Z"
            },
            {
                "name": "0.16.0 - Context menus and rich text",
                "date": "2021-12-29T11:26:11Z"
            },
            {
                "name": "0.15.0 - Syntax highlighting, hscroll, egui-winit and egui_glow",
                "date": "2021-10-24T14:30:21Z"
            },
            {
                "name": "0.14.1 - Bug fixes and better web blending",
                "date": "2021-08-28T09:15:46Z"
            },
            {
                "name": "0.14.0 - Ui panels and bug fixes",
                "date": "2021-08-27T17:16:10Z"
            },
            {
                "name": "0.1.0 - initial release",
                "date": "2020-05-30T16:26:30Z"
            }
        ]
    }
}
{
    "https://api.github.com/repos/Idnan/bash-guide": {
        "forks": 1030,
        "watchers": 11924,
        "stars": 11924,
        "languages": {},
        "commits": [
            "2024-01-03T04:26:44Z",
            "2024-01-02T15:27:00Z",
            "2024-01-02T15:25:47Z",
            "2023-12-29T14:16:22Z",
            "2023-12-29T14:15:14Z",
            "2023-12-29T14:13:01Z",
            "2023-12-29T14:11:56Z",
            "2023-12-29T14:10:59Z",
            "2023-12-29T14:10:31Z",
            "2023-12-09T14:43:59Z",
            "2023-03-01T15:51:40Z",
            "2023-03-01T15:50:54Z",
            "2023-03-01T15:49:27Z",
            "2023-03-01T15:44:47Z",
            "2023-03-01T15:42:37Z",
            "2023-03-01T15:36:35Z",
            "2023-03-01T15:35:42Z",
            "2023-03-01T15:34:27Z",
            "2023-03-01T15:34:01Z",
            "2021-03-30T14:13:57Z",
            "2020-01-28T08:44:45Z",
            "2019-10-16T11:37:13Z",
            "2019-05-23T19:30:12Z",
            "2019-05-05T06:46:26Z",
            "2018-01-03T15:21:51Z",
            "2017-11-19T18:34:39Z",
            "2017-11-19T18:32:54Z",
            "2017-11-19T18:32:35Z",
            "2017-10-05T06:44:46Z",
            "2017-06-30T03:03:43Z"
        ],
        "creation_date": "2017-04-01T07:38:28Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 304,
        "readme": "<p align=\"center\">\n  <img src=\"https://cloud.githubusercontent.com/assets/2059754/24601246/753a7f36-1858-11e7-9d6b-7a0e64fb27f7.png\" alt=\"bash logo\"/>\n</p>\n\n## Table of Contents\n  1. [Basic Operations](#1-basic-operations)  \n    1.1. [File Operations](#11-file-operations)  \n    1.2. [Text Operations](#12-text-operations)  \n    1.3. [Directory Operations](#13-directory-operations)  \n    1.4. [SSH, System Info & Network Operations](#14-ssh-system-info--network-operations)  \n    1.5. [Process Monitoring Operations](#15-process-monitoring-operations)\n  2. [Basic Shell Programming](#2-basic-shell-programming)  \n    2.1. [Variables](#21-variables)  \n    2.2. [Array](#22-array)  \n    2.3. [String Substitution](#23-string-substitution)  \n    2.4. [Other String Tricks](#24-other-string-tricks)  \n    2.5. [Functions](#25-functions)  \n    2.6. [Conditionals](#26-conditionals)  \n    2.7. [Loops](#27-loops)  \n    2.8. [Regex](#28-regex)  \n    2.9. [Pipes](#29-pipes)  \n  3. [Tricks](#3-tricks)  \n  4. [Debugging](#4-debugging)  \n  5. [Multi-threading](#5-multi-threading)\n\n# 1. Basic Operations\n\n### a. `export`\nDisplays all environment variables. If you want to get details of a specific variable, use `echo $VARIABLE_NAME`.  \n```bash\nexport\n```\nExample:\n```bash\n$ export\nAWS_HOME=/Users/adnanadnan/.aws\nLANG=en_US.UTF-8\nLC_CTYPE=en_US.UTF-8\nLESS=-R\n\n$ echo $AWS_HOME\n/Users/adnanadnan/.aws\n```\n\n### b. `whatis`\nwhatis shows description for user commands, system calls, library functions, and others in manual pages\n```bash\nwhatis something\n```\nExample:\n```bash\n$ whatis bash\nbash (1)             - GNU Bourne-Again SHell\n```\n\n### c. `whereis`\nwhereis searches for executables, source files, and manual pages using a database built by system automatically.\n```bash\nwhereis name\n```\nExample:\n```bash\n$ whereis php\n/usr/bin/php\n```\n\n### d. `which`\nwhich searches for executables in the directories specified by the environment variable PATH. This command will print the full path of the executable(s).\n```bash\nwhich program_name \n```\nExample:\n```bash\n$ which php\n/c/xampp/php/php\n```\n\n### e. clear\nClears content on window.\n\n## 1.1. File Operations\n<table>\n   <tr>\n      <td><a href=\"#a-cat\">cat</a></td>\n      <td><a href=\"#b-chmod\">chmod</a></td>\n      <td><a href=\"#c-chown\">chown</a></td>\n      <td><a href=\"#d-cp\">cp</a></td>\n      <td><a href=\"#e-diff\">diff</a></td>\n      <td><a href=\"#f-file\">file</a></td>\n      <td><a href=\"#g-find\">find</a></td>\n      <td><a href=\"#h-gunzip\">gunzip</a></td>\n      <td><a href=\"#i-gzcat\">gzcat</a></td>\n      <td><a href=\"#j-gzip\">gzip</a></td>\n      <td><a href=\"#k-head\">head</a></td>\n   </tr>\n   <tr>\n      <td><a href=\"#l-less\">less</a></td>\n      <td><a href=\"#m-lpq\">lpq</a></td>\n      <td><a href=\"#n-lpr\">lpr</a></td>\n      <td><a href=\"#o-lprm\">lprm</a></td>\n      <td><a href=\"#p-ls\">ls</a></td>\n      <td><a href=\"#q-more\">more</a></td>\n      <td><a href=\"#r-mv\">mv</a></td>\n      <td><a href=\"#s-rm\">rm</a></td>\n      <td><a href=\"#t-tail\">tail</a></td>\n      <td><a href=\"#u-touch\">touch</a></td>\n   </tr>\n</table>\n\n### a. `cat`\nIt can be used for the following purposes under UNIX or Linux.  \n* Display text files on screen\n* Copy text files  \n* Combine text files  \n* Create new text files  \n```bash\ncat filename\ncat file1 file2 \ncat file1 file2 > newcombinedfile\ncat < file1 > file2 #copy file1 to file2\n```\n\n### b. `chmod`\nThe chmod command stands for \"change mode\" and allows you to change the read, write, and execute permissions on your files and folders. For more information on this command check this [link](https://ss64.com/bash/chmod.html).\n```bash\nchmod -options filename\n```\n\n### c. `chown`\nThe chown command stands for \"change owner\", and allows you to change the owner of a given file or folder, which can be a user and a group. Basic usage is simple forward first comes the user (owner), and then the group, delimited by a colon.\n```bash\nchown -options user:group filename\n```\n\n### d. `cp`\nCopies a file from one location to other.  \n```bash\ncp filename1 filename2\n```\nWhere `filename1` is the source path to the file and `filename2` is the destination path to the file.\n\n### e. `diff`\nCompares files, and lists their differences.  \n```bash\ndiff filename1 filename2\n```\n\n### f. `file`\nDetermine file type.  \n```bash\nfile filename\n```\nExample:\n```bash\n$ file index.html\n index.html: HTML document, ASCII text\n```\n### g. `find`\nFind files in directory\n```bash\nfind directory options pattern\n```\nExample:\n```bash\n$ find . -name README.md\n$ find /home/user1 -name '*.png'\n```\n\n### h. `gunzip`\nUn-compresses files compressed by gzip.  \n```bash\ngunzip filename\n```\n\n### i. `gzcat`\nLets you look at gzipped file without actually having to gunzip it.  \n```bash\ngzcat filename\n```\n\n### j. `gzip`\nCompresses files.  \n```bash\ngzip filename\n```\n\n### k. `head`\nOutputs the first 10 lines of file  \n```bash\nhead filename\n```\n\n### l. `less`\nShows the contents of a file or a command output, one page at a time. It is similar to [more](#q-more), but has more advanced features and allows you to navigate both forward and backward through the file.  \n```bash\nless filename\n```\n\n### m. `lpq`\nCheck out the printer queue.  \n```bash\nlpq\n```\nExample:\n```bash\n$ lpq\nRank    Owner   Job     File(s)                         Total Size\nactive  adnanad 59      demo                            399360 bytes\n1st     adnanad 60      (stdin)                         0 bytes\n```\n\n### n. `lpr`\nPrint the file.  \n```bash\nlpr filename\n```\n\n### o. `lprm`\nRemove something from the printer queue.  \n```bash\nlprm jobnumber\n```\n\n### p. `ls`\nLists your files. `ls` has many options: `-l` lists files in 'long format', which contains the exact size of the file, who owns the file, who has the right to look at it, and when it was last modified. `-a` lists all files, including hidden files. For more information on this command check this [link](https://ss64.com/bash/ls.html).  \n```bash\nls option\n```\nExample:\n<pre>\n$ ls -la\nrwxr-xr-x   33 adnan  staff    1122 Mar 27 18:44 .\ndrwxrwxrwx  60 adnan  staff    2040 Mar 21 15:06 ..\n-rw-r--r--@  1 adnan  staff   14340 Mar 23 15:05 .DS_Store\n-rw-r--r--   1 adnan  staff     157 Mar 25 18:08 .bumpversion.cfg\n-rw-r--r--   1 adnan  staff    6515 Mar 25 18:08 .config.ini\n-rw-r--r--   1 adnan  staff    5805 Mar 27 18:44 .config.override.ini\ndrwxr-xr-x  17 adnan  staff     578 Mar 27 23:36 .git\n-rwxr-xr-x   1 adnan  staff    2702 Mar 25 18:08 .gitignore\n</pre>\n\n### q. `more`\nShows the first part of a file (move with space and type q to quit).  \n```bash\nmore filename\n```\n\n### r. `mv`\nMoves a file from one location to other.  \n```bash\nmv filename1 filename2\n```\nWhere `filename1` is the source path to the file and `filename2` is the destination path to the file.\n\nAlso it can be used for rename a file.\n```bash\nmv old_name new_name\n```\n\n### s. `rm`\nRemoves a file. Using this command on a directory gives you an error.\n`rm: directory: is a directory`\nTo remove a directory you have to pass `-r` which will remove the content of the directory recursively. Optionally you can use `-f` flag to force the deletion i.e. without any confirmations etc.\n```bash\nrm filename\n```\n\n### t. `tail`\nOutputs the last 10 lines of file. Use `-f` to output appended data as the file grows.  \n```bash\ntail filename\n```\n\n### u. `touch`\nUpdates access and modification time stamps of your file. If it doesn't exists, it'll be created.\n```bash\ntouch filename\n```\nExample:\n```bash\n$ touch trick.md\n```\n\n## 1.2. Text Operations\n\n<table>\n    <tr>\n      <td><a href=\"#a-awk\">awk</a></td>\n      <td><a href=\"#b-cut\">cut</a></td>\n      <td><a href=\"#c-echo\">echo</a></td>\n      <td><a href=\"#d-egrep\">egrep</a></td>\n      <td><a href=\"#e-fgrep\">fgrep</a></td>\n      <td><a href=\"#f-fmt\">fmt</a></td>\n      <td><a href=\"#g-grep\">grep</a></td>\n      <td><a href=\"#h-nl\">nl</a></td>\n      <td><a href=\"#i-sed\">sed</a></td>\n      <td><a href=\"#j-sort\">sort</a></td>\n   </tr>\n   <tr>\n      <td><a href=\"#k-tr\">tr</a></td>\n      <td><a href=\"#l-uniq\">uniq</a></td>\n      <td><a href=\"#m-wc\">wc</a></td>\n   </tr>\n</table>\n\n### a. `awk`\nawk is the most useful command for handling text files. It operates on an entire file line by line. By default it uses whitespace to separate the fields. The most common syntax for awk command is\n\n```bash\nawk '/search_pattern/ { action_to_take_if_pattern_matches; }' file_to_parse\n```\n\nLets take following file `/etc/passwd`. Here's the sample data that this file contains:\n```\nroot:x:0:0:root:/root:/usr/bin/zsh\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\n```\nSo now lets get only username from this file. Where `-F` specifies that on which base we are going to separate the fields. In our case it's `:`. `{ print $1 }` means print out the first matching field.\n```bash\nawk -F':' '{ print $1 }' /etc/passwd\n```\nAfter running the above command you will get following output.\n```\nroot\ndaemon\nbin\nsys\nsync\n```\nFor more detail on how to use `awk`, check following [link](https://www.cyberciti.biz/faq/bash-scripting-using-awk).\n\n\n### b. `cut`\nRemove sections from each line of files\n\n*example.txt*\n```bash\nred riding hood went to the park to play\n```\n\n*show me columns 2 , 7 , and 9 with a space as a separator*\n```bash\ncut -d \" \" -f2,7,9 example.txt\n```\n```bash\nriding park play\n```\n\n### c. `echo`\nDisplay a line of text\n\n*display \"Hello World\"*\n```bash\necho Hello World\n```\n```bash\nHello World\n```\n\n*display \"Hello World\" with newlines between words*\n```bash\necho -ne \"Hello\\nWorld\\n\"\n```\n```bash\nHello\nWorld\n```\n\n### d. `egrep`\nPrint lines matching a pattern - Extended Expression (alias for: 'grep -E')\n\n*example.txt*\n```bash\nLorem ipsum\ndolor sit amet, \nconsetetur\nsadipscing elitr,\nsed diam nonumy\neirmod tempor\ninvidunt ut labore\net dolore magna\naliquyam erat, sed\ndiam voluptua. At\nvero eos et\naccusam et justo\nduo dolores et ea\nrebum. Stet clita\nkasd gubergren,\nno sea takimata\nsanctus est Lorem\nipsum dolor sit\namet.\n```\n\n*display lines that have either \"Lorem\" or \"dolor\" in them.*\n```bash\negrep '(Lorem|dolor)' example.txt\nor\ngrep -E '(Lorem|dolor)' example.txt\n```\n```bash\nLorem ipsum\ndolor sit amet,\net dolore magna\nduo dolores et ea\nsanctus est Lorem\nipsum dolor sit\n```\n\n### e. `fgrep`\nPrint lines matching a pattern - FIXED pattern matching  (alias for: 'grep -F')\n\n*example.txt*\n```bash\nLorem ipsum\ndolor sit amet,\nconsetetur\nsadipscing elitr,\nsed diam nonumy\neirmod tempor\nfoo (Lorem|dolor) \ninvidunt ut labore\net dolore magna\naliquyam erat, sed\ndiam voluptua. At\nvero eos et\naccusam et justo\nduo dolores et ea\nrebum. Stet clita\nkasd gubergren,\nno sea takimata\nsanctus est Lorem\nipsum dolor sit\namet.\n```\n\n*Find the exact string '(Lorem|dolor)' in example.txt*\n```bash\nfgrep '(Lorem|dolor)' example.txt\nor\ngrep -F '(Lorem|dolor)' example.txt\n```\n```bash\nfoo (Lorem|dolor) \n```\n\n### f. `fmt`\nSimple optimal text formatter\n\n*example: example.txt (1 line)*\n```bash\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\n```\n\n*output the lines of example.txt to 20 character width*\n```bash\ncat example.txt | fmt -w 20\n```\n```bash\nLorem ipsum\ndolor sit amet,\nconsetetur\nsadipscing elitr,\nsed diam nonumy\neirmod tempor\ninvidunt ut labore\net dolore magna\naliquyam erat, sed\ndiam voluptua. At\nvero eos et\naccusam et justo\nduo dolores et ea\nrebum. Stet clita\nkasd gubergren,\nno sea takimata\nsanctus est Lorem\nipsum dolor sit\namet.\n```\n\n### g. `grep`\nLooks for text inside files. You can use grep to search for lines of text that match one or many regular expressions, and outputs only the matching lines.  \n```bash\ngrep pattern filename\n```\nExample:\n```bash\n$ grep admin /etc/passwd\n_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false\n_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false\n_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false\n```\nYou can also force grep to ignore word case by using `-i` option. `-r` can be used to search all files under the specified directory, for example:\n```bash\n$ grep -r admin /etc/\n```\nAnd `-w` to search for words only. For more detail on `grep`, check following [link](https://www.cyberciti.biz/faq/grep-in-bash).\n\n### h. `nl`\nNumber lines of files\n\n*example.txt*\n```bash\nLorem ipsum\ndolor sit amet,\nconsetetur\nsadipscing elitr,\nsed diam nonumy\neirmod tempor\ninvidunt ut labore\net dolore magna\naliquyam erat, sed\ndiam voluptua. At\nvero eos et\naccusam et justo\nduo dolores et ea\nrebum. Stet clita\nkasd gubergren,\nno sea takimata\nsanctus est Lorem\nipsum dolor sit\namet.\n```\n\n*show example.txt with line numbers*\n```bash\nnl -s\". \" example.txt \n```\n```bash\n     1. Lorem ipsum\n     2. dolor sit amet,\n     3. consetetur\n     4. sadipscing elitr,\n     5. sed diam nonumy\n     6. eirmod tempor\n     7. invidunt ut labore\n     8. et dolore magna\n     9. aliquyam erat, sed\n    10. diam voluptua. At\n    11. vero eos et\n    12. accusam et justo\n    13. duo dolores et ea\n    14. rebum. Stet clita\n    15. kasd gubergren,\n    16. no sea takimata\n    17. sanctus est Lorem\n    18. ipsum dolor sit\n    19. amet.\n```\n\n### i. `sed`\nStream editor for filtering and transforming text\n\n*example.txt*\n```bash\nHello This is a Test 1 2 3 4\n``` \n\n*replace all spaces with hyphens*\n```bash\nsed 's/ /-/g' example.txt\n```\n```bash\nHello-This-is-a-Test-1-2-3-4\n```\n\n*replace all digits with \"d\"*\n```bash\nsed 's/[0-9]/d/g' example.txt\n```\n```bash\nHello This is a Test d d d d\n```\n\n### j. `sort`\nSort lines of text files\n\n*example.txt*\n```bash\nf\nb\nc\ng\na\ne\nd\n```\n\n*sort example.txt*\n```bash\nsort example.txt\n```\n```bash\na\nb\nc\nd\ne\nf\ng\n```\n\n*randomize a sorted example.txt*\n```bash\nsort example.txt | sort -R\n```\n```bash\nb\nf\na\nc\nd\ng\ne\n```\n\n### k. `tr`\nTranslate or delete characters\n\n*example.txt*\n```bash\nHello World Foo Bar Baz!\n```\n\n*take all lower case letters and make them upper case*\n```bash\ncat example.txt | tr 'a-z' 'A-Z' \n```\n```bash\nHELLO WORLD FOO BAR BAZ!\n```\n\n*take all spaces and make them into newlines*\n```bash\ncat example.txt | tr ' ' '\\n'\n```\n```bash\nHello\nWorld\nFoo\nBar\nBaz!\n```\n\n### l. `uniq`\nReport or omit repeated lines\n\n*example.txt*\n```bash\na\na\nb\na\nb\nc\nd\nc\n```\n\n*show only unique lines of example.txt (first you need to sort it, otherwise it won't see the overlap)*\n```bash\nsort example.txt | uniq\n```\n```bash\na\nb\nc\nd\n```\n\n*show the unique items for each line, and tell me how many instances it found*\n```bash\nsort example.txt | uniq -c\n```\n```bash\n    3 a\n    2 b\n    2 c\n    1 d\n```\n\n### m. `wc`\nTells you how many lines, words and characters there are in a file.  \n```bash\nwc filename\n```\nExample:\n```bash\n$ wc demo.txt\n7459   15915  398400 demo.txt\n```\nWhere `7459` is lines, `15915` is words and `398400` is characters.\n\n## 1.3. Directory Operations\n\n<table>\n   <tr>\n      <td><a href=\"#a-cd\">cd</a></td>\n      <td><a href=\"#b-mkdir\">mkdir</a></td>\n      <td><a href=\"#c-pwd\">pwd</a></td>\n   </tr>\n</table>\n\n### a. `cd`\nMoves you from one directory to other. Running this  \n```bash\n$ cd\n```\nmoves you to home directory. This command accepts an optional `dirname`, which moves you to that directory.\n```bash\ncd dirname\n```\nSwitch to the previous working directory\n```bash\ncd -\n```\n\n### b. `mkdir`\nMakes a new directory.  \n```bash\nmkdir dirname\n```\nYou can use this to create multiple directories at once within your current directory.\n```bash\nmkdir 1stDirectory 2ndDirectory 3rdDirectory\n```\nYou can also use this to create parent directories at the same time with the -p (or --parents) flag. For instance, if you wanted a directory named 'project1' in another subdirectory at '/samples/bash/projects/', you could run:\n```bash \nmkdir -p /samples/bash/projects/project1\nmkdir --parents /samples/bash/projects/project1\n```\nBoth commands above will do the same thing.\nIf any of these directories did no already exist, they would be created as well.\n\n### c. `pwd`\nTells you which directory you currently are in.  \n```bash\npwd\n```\n\n## 1.4. SSH, System Info & Network Operations\n\n<table>\n   <tr>\n      <td><a href=\"#a-bg\">bg</a></td>\n      <td><a href=\"#b-cal\">cal</a></td>\n      <td><a href=\"#c-date\">date</a></td>\n      <td><a href=\"#d-df\">df</a></td>\n      <td><a href=\"#e-dig\">dig</a></td>\n      <td><a href=\"#f-du\">du</a></td>\n      <td><a href=\"#g-fg\">fg</a></td>\n      <td><a href=\"#h-finger\">finger</a></td>   \n      <td><a href=\"#i-jobs\">jobs</a></td>\n      <td><a href=\"#j-last\">last</a></td>\n   </tr>\n   <tr>\n      <td><a href=\"#k-man\">man</a></td>\n      <td><a href=\"#l-passwd\">passwd</a></td>\n      <td><a href=\"#m-ping\">ping</a></td>\n      <td><a href=\"#n-ps\">ps</a></td>\n      <td><a href=\"#o-quota\">quota</a></td>\n      <td><a href=\"#p-scp\">scp</a></td>\n      <td><a href=\"#q-ssh\">ssh</a></td>\n      <td><a href=\"#r-top\">top</a></td>\n      <td><a href=\"#s-uname\">uname</a></td>\n      <td><a href=\"#t-uptime\">uptime</a></td>\n   </tr>\n   <tr>\n      <td><a href=\"#u-w\">w</a></td>\n      <td><a href=\"#v-wget\">wget</a></td>\n      <td><a href=\"#w-whoami\">whoami</a></td>\n      <td><a href=\"#x-whois\">whois</a></td>\n      <td><a href=\"#y-rsync\">sync</a></td>\n      <td><a href=\"#z-curl\">curl</a></td>\n   </tr>\n</table>\n\n### a. `bg`\nLists stopped or background jobs; resume a stopped job in the background.\n\n### b. `cal`\nShows the month's calendar.\n\n### c. `date`\nShows the current date and time.\n\n### d. `df`\nShows disk usage.\n\n### e. `dig`\nGets DNS information for domain.  \n```bash\ndig domain\n```\n\n### f. `du`\nShows the disk usage of files or directories. For more information on this command check this [link](http://www.linfo.org/du.html)\n```bash\ndu [option] [filename|directory]\n```\nOptions:\n- `-h` (human readable) Displays output it in kilobytes (K), megabytes (M) and gigabytes (G).\n- `-s` (supress or summarize) Outputs total disk space of a directory and supresses reports for subdirectories. \n\nExample:\n```bash\ndu -sh pictures\n1.4M pictures\n```\n\n### g. `fg`\nBrings the most recent job in the foreground.\n\n### h. `finger`\nDisplays information about user.  \n```bash\nfinger username\n```\n### i. `jobs`\nLists the jobs running in the background, giving the job number.\n\n### j. `last`\nLists your last logins of specified user.  \n```bash\nlast yourUsername\n```\n\n### k. `man`\nShows the manual for specified command.  \n```bash\nman command\n```\n\n### l. `passwd`\nAllows the current logged user to change their password.\n\n### m. `ping`\nPings host and outputs results.  \n```bash\nping host\n```\n\n### n. `ps`\nLists your processes.  \n```bash\nps -u yourusername\n```\nUse the flags ef. e for every process and f for full listing. \n```bash\nps -ef\n```\n\n### o. `quota`\nShows what your disk quota is.  \n```bash\nquota -v\n```\n\n### p. `scp`\nTransfer files between a local host and a remote host or between two remote hosts.\n\n*copy from local host to remote host*\n```bash\nscp source_file user@host:directory/target_file\n```\n*copy from remote host to local host*\n```bash\nscp user@host:directory/source_file target_file\nscp -r user@host:directory/source_folder target_folder\n```\nThis command also accepts an option `-P` that can be used to connect to specific port.  \n```bash\nscp -P port user@host:directory/source_file target_file\n```\n\n### q. `ssh`\nssh (SSH client) is a program for logging into and executing commands on a remote machine.  \n```bash\nssh user@host\n```\nThis command also accepts an option `-p` that can be used to connect to specific port.  \n```bash\nssh -p port user@host\n```\n\n### r. `top`\nDisplays your currently active processes.\n\n### s. `uname`\nShows kernel information.  \n```bash\nuname -a\n```\n\n### t. `uptime`\nShows current uptime.\n\n### u. `w`\nDisplays who is online.\n\n### v. `wget`\nDownloads file.  \n```bash\nwget file\n```\n\n### w. `whoami`\nReturn current logged in username.\n\n### x. `whois`\nGets whois information for domain.  \n```bash\nwhois domain\n```\n\n### y. `rsync`\nDoes the same job as `scp` command, but transfers only changed files. Useful when transferring the same folder to/from server multiple times.\n```bash\nrsync source_folder user@host:target_folder\nrsync user@host:target_folder target_folder\n```\n\n### z. `curl`\nCurl is a command-line tool for requesting or sending data using URL syntax. Usefull on systems where you only have terminal available for making various requests.\n```bash\ncurl url\n```\nUse  `-X` or `--request` to specify which method you would like invoke (GET, POST, DELETE, ...).\nUse `-d <data>` or `--data <data>` to POST data on given URL.\n\n## 1.5. Process Monitoring Operations\n\n<table>\n   <tr>\n      <td><a href=\"#a-kill\">kill</a></td>\n      <td><a href=\"#b-killall\">killall</a></td>\n      <td><a href=\"#c-&\">&amp;</a></td>\n      <td><a href=\"#d-nohup\">nohup</a></td>\n   </tr>\n</table>\n\n### a. `kill`\nKills (ends) the processes with the ID you gave.  \n```bash\nkill PID\n```\n\n### b. `killall`\nKill all processes with the name.  \n```bash\nkillall processname\n```\n\n### c. &\nThe `&` symbol instructs the command to run as a background process in a subshell.\n```bash\ncommand &\n```\n\n### d. `nohup`\nnohup stands for \"No Hang Up\". This allows to run command/process or shell script that can continue running in the background after you log out from a shell.\n```bash\nnohup command\n```\nCombine it with `&` to create background processes \n```bash\nnohup command &\n```\n\n# 2. Basic Shell Programming\n\n\nThe first line that you will write in bash script files is called `shebang`. This line in any script determines the script's ability to be executed like a standalone executable without typing sh, bash, python, php etc beforehand in the terminal.\n\n```bash\n#!/usr/bin/env bash\n```\n\n## 2.1. Variables\n\nCreating variables in bash is similar to other languages. There are no data types. A variable in bash can contain a number, a character, a string of characters, etc. You have no need to declare a variable, just assigning a value to its reference will create it.\n\nExample:\n```bash\nstr=\"hello world\"\n```\n\nThe above line creates a variable `str` and assigns \"hello world\" to it. The value of variable is retrieved by putting the `$` in the beginning of variable name.\n\nExample:\n```bash\necho $str   # hello world\n```\n## 2.2. Array\nLike other languages bash has also arrays. An array is a variable containing multiple values. There's no maximum limit on the size of array. Arrays in bash are zero based. The first element is indexed with element 0. There are several ways for creating arrays in bash which are given below.\n\nExamples:\n```bash\narray[0]=val\narray[1]=val\narray[2]=val\narray=([2]=val [0]=val [1]=val)\narray=(val val val)\n```\nTo display a value at specific index use following syntax:\n\n```bash\n${array[i]}     # where i is the index\n```\n\nIf no index is supplied, array element 0 is assumed. To find out how many values there are in the array use the following syntax:\n\n```bash\n${#array[@]}\n```\n\nBash has also support for the ternary conditions. Check some examples below.\n\n```bash\n${varname:-word}    # if varname exists and isn't null, return its value; otherwise return word\n${varname:=word}    # if varname exists and isn't null, return its value; otherwise set it word and then return its value\n${varname:+word}    # if varname exists and isn't null, return word; otherwise return null\n${varname:offset:length}    # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters\n```\n\n## 2.3 String Substitution\n\nCheck some of the syntax on how to manipulate strings\n\n```bash\n${variable#pattern}         # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest\n${variable##pattern}        # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest\n${variable%pattern}         # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest\n${variable%%pattern}        # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest\n${variable/pattern/string}  # the longest match to pattern in variable is replaced by string. Only the first match is replaced\n${variable//pattern/string} # the longest match to pattern in variable is replaced by string. All matches are replaced\n${#varname}     # returns the length of the value of the variable as a character string\n```\n\n## 2.4. Other String Tricks\n\nBash has multiple shorthand tricks for doing various things to strings.\n\n```bash\n${variable,,}    #this converts every letter in the variable to lowercase\n${variable^^}    #this converts every letter in the variable to uppercase\n\n${variable:2:8}  #this returns a substring of a string, starting at the character at the 2 index(strings start at index 0, so this is the 3rd character),\n                 #the substring will be 8 characters long, so this would return a string made of the 3rd to the 11th characters.\n```\n\nHere are some handy pattern matching tricks\n```bash\nif [[ \"$variable\" == *subString* ]]  #this returns true if the provided substring is in the variable\nif [[ \"$variable\" != *subString* ]]  #this returns true if the provided substring is not in the variable\nif [[ \"$variable\" == subString* ]]   #this returns true if the variable starts with the given subString\nif [[ \"$variable\" == *subString ]]   #this returns true if the variable ends with the given subString\n```\n\n\nThe above can be shortened using a case statement and the IN keyword\n```bash\ncase \"$var\" in\n\tbegin*)\n\t\t#variable begins with \"begin\"\n\t;;\n\t*subString*)\n\t\t#subString is in variable\n\t;;\n\n\t*otherSubString*)\n\t\t#otherSubString is in variable\n\t;;\nesac\n```\n\n## 2.5. Functions\nAs in almost any programming language, you can use functions to group pieces of code in a more logical way or practice the divine art of recursion. Declaring a function is just a matter of writing function my_func { my_code }. Calling a function is just like calling another program, you just write its name.\n\n```bash\nfunction name() {\n    shell commands\n}\n```\n\nExample:\n```bash\n#!/bin/bash\nfunction hello {\n   echo world!\n}\nhello\n\nfunction say {\n    echo $1\n}\nsay \"hello world!\"\n```\n\nWhen you run the above example the `hello` function will output \"world!\". The above two functions `hello` and `say` are identical. The main difference is function `say`. This function, prints the first argument it receives. Arguments, within functions, are treated in the same manner as arguments given to the script.\n\n## 2.6. Conditionals\n\nThe conditional statement in bash is similar to other programming languages. Conditions have many form like the most basic form is `if` expression `then` statement where statement is only executed if expression is true.\n\n```bash\nif [ expression ]; then\n    will execute only if expression is true\nelse\n    will execute if expression is false\nfi\n```\n\nSometime if conditions becoming confusing so you can write the same condition using the `case statements`.\n\n```bash\ncase expression in\n    pattern1 )\n        statements ;;\n    pattern2 )\n        statements ;;\n    ...\nesac\n```\n\nExpression Examples:\n\n```bash\nstatement1 && statement2  # both statements are true\nstatement1 || statement2  # at least one of the statements is true\n\nstr1=str2       # str1 matches str2\nstr1!=str2      # str1 does not match str2\nstr1<str2       # str1 is less than str2\nstr1>str2       # str1 is greater than str2\n-n str1         # str1 is not null (has length greater than 0)\n-z str1         # str1 is null (has length 0)\n\n-a file         # file exists\n-d file         # file exists and is a directory\n-e file         # file exists; same -a\n-f file         # file exists and is a regular file (i.e., not a directory or other special type of file)\n-r file         # you have read permission\n-s file         # file exists and is not empty\n-w file         # you have write permission\n-x file         # you have execute permission on file, or directory search permission if it is a directory\n-N file         # file was modified since it was last read\n-O file         # you own file\n-G file         # file's group ID matches yours (or one of yours, if you are in multiple groups)\n\nfile1 -nt file2     # file1 is newer than file2\nfile1 -ot file2     # file1 is older than file2\n\n-lt     # less than\n-le     # less than or equal\n-eq     # equal\n-ge     # greater than or equal\n-gt     # greater than\n-ne     # not equal\n```\n\n## 2.7. Loops\n\nThere are three types of loops in bash. `for`, `while` and `until`.\n\nDifferent `for` Syntax:\n```bash\nfor name [in list]\ndo\n  statements that can use $name\ndone\n\nfor (( initialisation ; ending condition ; update ))\ndo\n  statements...\ndone\n```\n\n`while` Syntax:\n```bash\nwhile condition; do\n  statements\ndone\n```\n\n`until` Syntax:\n```bash\nuntil condition; do\n  statements\ndone\n```\n\n# 2.8. Regex\n\nThey are a powerful tool for manipulating and searching text. Here are some examples of regular expressions that use each `metacharacter`:\n\n<table>\n   <tr>\n      <td><a href=\"#a-dot\">`.`(dot)</a></td>\n      <td><a href=\"#b-asterisk\">`*`(asterisk)</a></td>\n      <td><a href=\"#c-plus\">`+`(plus)</a></td>\n      <td><a href=\"#d-question_mark\">`?`(question mark)</a></td>\n      <td><a href=\"#c-plus\">`|`(pipe)</a></td>\n      <td><a href=\"#c-plus\">`[]`(character class)</a></td>\n      <td><a href=\"#c-plus\">`[^]`(negated character class)</a></td>\n      <td><a href=\"#c-plus\">`()`(grouping)</a></td>\n      <td><a href=\"#c-plus\">`{}`(quantifiers)</a></td>\n      <td><a href=\"#c-plus\">`\\`(escape)</a></td>\n   </tr>\n</table>\n\n### a. `.` (dot)\nMatches any single character except newline.  \n```bash\ngrep h.t file.txt\n```\nOutput:\n```bash\nhat\nhot\nhit\n```\n\n### b. `*` (asterisk)\nMatches zero or more occurrences of the preceding character or group.\n```bash\ngrep ab*c file.txt\n```\nOutput:\n```bash\nac\nabc\nabbc\nabbbc\n```\n\n### c. `+` (plus)\nMatches one or more occurrences of the preceding character or group.\n```bash\ngrep ab+c file.txt\n```\nOutput:\n```bash\nabc\nabbc\nabbbc\nabbbbc\n```\n\n### d. `?` (question mark)\nMatches zero or one occurrence of the preceding character or group.\n```bash\ngrep ab?c file.txt\n```\nOutput:\n```bash\nac\nabc\n```\n\n### e. `|` (pipe)\nMatches either the pattern to the left or the pattern to the right.\n```bash\negrep \"cat|dog\" file.txt\n```\nOutput:\n```bash\ncat\ndog\n```\n\n### f. `[]` (character class)\nMatches any character inside the brackets.\n```bash\n[aeiou] will match any vowel\n[a-z] will match any lowercase letter\n```\n\n### g. `[]` (negated character class)\nMatches any character not inside the brackets.\n```bash\n[^aeiou] will match any consonant\n[^a-z] will match any non-lowercase letter\n```\n\n### h. `()` (grouping)\nGroups multiple tokens together and creates a capture group.\n```bash\negrep \"(ab)+\" file.txt\n```\n\nOutput:\n```bash\nab\nabab\nababab\n```\n\n### i. `{}` (quantifiers)\nMatches a specific number of occurrences of the preceding character or group.\n```bash\negrep \"a{3}\" file.txt\n```\n\nOutput:\n```bash\naaa\naaaa\naaaaa\n```\n\n### j. `\\` (escape)\nEscapes the next character to match it literally.\n```bash\negrep \"a\\+\" file.txt\n```\n\nOutput:\n```bash\na+\n```\n=======\n## 2.9. Pipes\n\nMultiple commands can be linked together with a pipe, `|`. A `|` will send the standard-output from command A to the standard-input of command B.\nPipes can also be constructed with the `|&` symbols. This will send the standard-output **and** standard-error from command A to the standard-input of command B.\n\n# 3. Tricks\n\n## Set an alias\n\nRun `nano ~/.bash_profile` and add the following line:\n\n```bash\nalias dockerlogin='ssh www-data@adnan.local -p2222'  # add your alias in .bash_profile\n```\n\n## To quickly go to a specific directory\n\nRun `nano ~/.bashrc` and add the following line:\n\n```bash\nexport hotellogs=\"/workspace/hotel-api/storage/logs\"\n```\n\nNow you can use the saved path:\n\n```bash\nsource ~/.bashrc\ncd $hotellogs\n```\n\n## Re-execute the previous command\n\nThis goes back to the days before you could rely on keyboards to have an \"up\" arrow key, but can still be useful. \nTo run the last command in your history\n```bash\n!!\n```\nA common error is to forget to use `sudo` to prefix a command requiring privileged execution. Instead of typing the whole command again, you can:\n```bash\nsudo !!\n```\nThis would change a `mkdir somedir` into `sudo mkdir somedir`.\n\n## Exit traps\n\nMake your bash scripts more robust by reliably performing cleanup.\n\n```bash\nfunction finish {\n  # your cleanup here. e.g. kill any forked processes\n  jobs -p | xargs kill\n}\ntrap finish EXIT\n```\n\n## Saving your environment variables\n\nWhen you do `export FOO = BAR`, your variable is only exported in this current shell and all its children, to persist in the future you can simply append in your `~/.bash_profile` file the command to export your variable\n```bash\necho export FOO=BAR >> ~/.bash_profile\n```\n\n## Accessing your scripts\n\nYou can easily access your scripts by creating a bin folder in your home with `mkdir ~/bin`, now all the scripts you put in this folder you can access in any directory.\n\nIf you can not access, try append the code below in your `~/.bash_profile` file and after do `source ~/.bash_profile`.\n```bash\n# set PATH so it includes user's private bin if it exists\nif [ -d \"$HOME/bin\" ] ; then\n    PATH=\"$HOME/bin:$PATH\"\nfi\n```\n\n# 4. Debugging\nYou can easily debug the bash script by passing different options to `bash` command. For example `-n` will not run commands and check for syntax errors only. `-v` echo commands before running them. `-x` echo commands after command-line processing.\n\n```bash\nbash -n scriptname\nbash -v scriptname\nbash -x scriptname\n```\n\n# 5. Multi-threading\nYou can easily multi-threading your jobs using `&`. All those jobs will then run in the background simultaneously and you can see the processes below are running using `jobs`.\n\n```bash\nsleep 15 & sleep 5 &\n```\n\nThe optional `wait` command will then wait for all the jobs to finish.\n\n```bash\nsleep 10 & sleep 5 &\nwait\n```\n\n## Contribution\n\n- Report issues [How to](https://help.github.com/articles/creating-an-issue/)\n- Open pull request with improvements [How to](https://help.github.com/articles/about-pull-requests/)\n- Spread the word\n\n## Translation\n- [Chinese | \u7b80\u4f53\u4e2d\u6587](https://github.com/vuuihc/bash-guide)\n- [Turkish | T\u00fcrk\u00e7e](https://github.com/omergulen/bash-guide)\n- [Japanese | \u65e5\u672c\u8a9e](https://github.com/itooww/bash-guide)\n- [Russian | \u0420\u0443\u0441\u0441\u043a\u0438\u0439](https://github.com/navinweb/bash-guide)\n- [Vietnamese | Ti\u1ebfng Vi\u1ec7t](https://github.com/nguyenvanhieuvn/hoc-bash)\n- [Spanish | Espa\u00f1ol](https://github.com/mariotristan/bash-guide)\n\n## License\n\n[![License: CC BY 4.0](https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg)](https://creativecommons.org/licenses/by/4.0/)\n",
        "releases": []
    }
}
{
    "https://api.github.com/repos/NVlabs/SPADE": {
        "forks": 983,
        "watchers": 7634,
        "stars": 7634,
        "languages": {
            "Python": 116030
        },
        "commits": [
            "2021-09-02T20:39:11Z",
            "2021-04-21T20:51:39Z",
            "2019-10-17T20:33:09Z",
            "2019-10-17T20:31:25Z",
            "2019-06-30T14:11:40Z",
            "2019-06-30T05:44:28Z",
            "2019-06-20T14:44:39Z",
            "2019-06-20T14:35:30Z",
            "2019-06-18T15:10:44Z",
            "2019-06-18T14:46:28Z",
            "2019-06-14T05:02:53Z",
            "2019-06-14T05:01:10Z",
            "2019-06-14T04:54:51Z",
            "2019-06-13T17:56:27Z",
            "2019-06-13T16:33:51Z",
            "2019-06-12T00:13:59Z",
            "2019-05-21T02:36:13Z",
            "2019-05-21T02:25:11Z",
            "2019-05-21T02:23:12Z",
            "2019-04-25T01:41:34Z",
            "2019-04-19T06:18:13Z",
            "2019-04-19T06:14:56Z",
            "2019-04-14T06:55:48Z",
            "2019-04-14T01:39:41Z",
            "2019-04-14T01:39:41Z",
            "2019-04-14T01:39:29Z",
            "2019-04-14T01:39:29Z",
            "2019-04-14T01:34:46Z",
            "2019-04-14T01:34:46Z",
            "2019-04-14T00:14:23Z"
        ],
        "creation_date": "2019-03-14T03:08:27Z",
        "contributors": 3,
        "topics": [],
        "subscribers": 280,
        "readme": "[![License CC BY-NC-SA 4.0](https://img.shields.io/badge/license-CC4.0-blue.svg)](https://raw.githubusercontent.com/nvlabs/SPADE/master/LICENSE.md)\n![Python 3.6](https://img.shields.io/badge/python-3.6-green.svg)\n\n# Semantic Image Synthesis with SPADE\n![GauGAN demo](https://nvlabs.github.io/SPADE//images/ocean.gif)\n\n# New implementation available at imaginaire repository\n\nWe have a reimplementation of the SPADE method that is more performant. It is avaiable at [Imaginaire](https://github.com/NVlabs/imaginaire)\n\n### [Project page](https://nvlabs.github.io/SPADE/) |   [Paper](https://arxiv.org/abs/1903.07291) | [Online Interactive Demo of GauGAN](https://www.nvidia.com/en-us/research/ai-playground/) | [GTC 2019 demo](https://youtu.be/p5U4NgVGAwg) | [Youtube Demo of GauGAN](https://youtu.be/MXWm6w4E5q0)\n\nSemantic Image Synthesis with Spatially-Adaptive Normalization.<br>\n[Taesung Park](http://taesung.me/),  [Ming-Yu Liu](http://mingyuliu.net/), [Ting-Chun Wang](https://tcwang0509.github.io/),  and [Jun-Yan Zhu](http://people.csail.mit.edu/junyanz/).<br>\nIn CVPR 2019 (Oral).\n\n### [License](https://raw.githubusercontent.com/nvlabs/SPADE/master/LICENSE.md)\n\nCopyright (C) 2019 NVIDIA Corporation.\n\nAll rights reserved.\nLicensed under the [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode) (**Attribution-NonCommercial-ShareAlike 4.0 International**)\n\nThe code is released for academic research use only. For commercial use or business inquiries, please contact [researchinquiries@nvidia.com](researchinquiries@nvidia.com).\n\nFor press and other inquiries, please contact [Hector Marinez](hmarinez@nvidia.com)\n\n## Installation\n\nClone this repo.\n```bash\ngit clone https://github.com/NVlabs/SPADE.git\ncd SPADE/\n```\n\nThis code requires PyTorch 1.0 and python 3+. Please install dependencies by\n```bash\npip install -r requirements.txt\n```\n\nThis code also requires the Synchronized-BatchNorm-PyTorch rep.\n```\ncd models/networks/\ngit clone https://github.com/vacancy/Synchronized-BatchNorm-PyTorch\ncp -rf Synchronized-BatchNorm-PyTorch/sync_batchnorm .\ncd ../../\n```\n\nTo reproduce the results reported in the paper, you would need an NVIDIA DGX1 machine with 8 V100 GPUs.\n\n## Dataset Preparation\n\nFor COCO-Stuff, Cityscapes or ADE20K, the datasets must be downloaded beforehand. Please download them on the respective webpages. In the case of COCO-stuff, we put a few sample images in this code repo.\n\n**Preparing COCO-Stuff Dataset**. The dataset can be downloaded [here](https://github.com/nightrome/cocostuff). In particular, you will need to download train2017.zip, val2017.zip, stuffthingmaps_trainval2017.zip, and annotations_trainval2017.zip. The images, labels, and instance maps should be arranged in the same directory structure as in `datasets/coco_stuff/`. In particular, we used an instance map that combines both the boundaries of \"things instance map\" and \"stuff label map\". To do this, we used a simple script `datasets/coco_generate_instance_map.py`. Please install `pycocotools` using `pip install pycocotools` and refer to the script to generate instance maps.\n\n**Preparing ADE20K Dataset**. The dataset can be downloaded [here](http://data.csail.mit.edu/places/ADEchallenge/ADEChallengeData2016.zip), which is from [MIT Scene Parsing BenchMark](http://sceneparsing.csail.mit.edu/). After unzipping the datgaset, put the jpg image files `ADEChallengeData2016/images/` and png label files `ADEChallengeData2016/annotatoins/` in the same directory. \n\nThere are different modes to load images by specifying `--preprocess_mode` along with `--load_size`. `--crop_size`. There are options such as `resize_and_crop`, which resizes the images into square images of side length `load_size` and randomly crops to `crop_size`. `scale_shortside_and_crop` scales the image to have a short side of length `load_size` and crops to `crop_size` x `crop_size` square. To see all modes, please use `python train.py --help` and take a look at `data/base_dataset.py`. By default at the training phase, the images are randomly flipped horizontally. To prevent this use `--no_flip`.\n\n## Generating Images Using Pretrained Model\n\nOnce the dataset is ready, the result images can be generated using pretrained models.\n\n1. Download the tar of the pretrained models from the [Google Drive Folder](https://drive.google.com/file/d/12gvlTbMvUcJewQlSEaZdeb2CdOB-b8kQ/view?usp=sharing), save it in 'checkpoints/', and run\n\n    ```\n    cd checkpoints\n    tar xvf checkpoints.tar.gz\n    cd ../\n    ```\n\n2. Generate images using the pretrained model.\n    ```bash\n    python test.py --name [type]_pretrained --dataset_mode [dataset] --dataroot [path_to_dataset]\n    ```\n    `[type]_pretrained` is the directory name of the checkpoint file downloaded in Step 1, which should be one of `coco_pretrained`, `ade20k_pretrained`, and `cityscapes_pretrained`. `[dataset]` can be one of `coco`, `ade20k`, and `cityscapes`, and `[path_to_dataset]`, is the path to the dataset. If you are running on CPU mode, append `--gpu_ids -1`.\n\n3. The outputs images are stored at `./results/[type]_pretrained/` by default. You can view them using the autogenerated HTML file in the directory.\n\n## Generating Landscape Image using GauGAN\n\nIn the paper and the demo video, we showed GauGAN, our interactive app that generates realistic landscape images from the layout users draw. The model was trained on landscape images scraped from Flickr.com. We released an online demo that has the same features. Please visit [https://www.nvidia.com/en-us/research/ai-playground/](https://www.nvidia.com/en-us/research/ai-playground/). The model weights are not released. \n\n## Training New Models\n\nNew models can be trained with the following commands.\n\n1. Prepare dataset. To train on the datasets shown in the paper, you can download the datasets and use `--dataset_mode` option, which will choose which subclass of `BaseDataset` is loaded. For custom datasets, the easiest way is to use `./data/custom_dataset.py` by specifying the option `--dataset_mode custom`, along with `--label_dir [path_to_labels] --image_dir [path_to_images]`. You also need to specify options such as `--label_nc` for the number of label classes in the dataset, `--contain_dontcare_label` to specify whether it has an unknown label, or `--no_instance` to denote the dataset doesn't have instance maps.\n\n2. Train.\n\n```bash\n# To train on the Facades or COCO dataset, for example.\npython train.py --name [experiment_name] --dataset_mode facades --dataroot [path_to_facades_dataset]\npython train.py --name [experiment_name] --dataset_mode coco --dataroot [path_to_coco_dataset]\n\n# To train on your own custom dataset\npython train.py --name [experiment_name] --dataset_mode custom --label_dir [path_to_labels] -- image_dir [path_to_images] --label_nc [num_labels]\n```\n\nThere are many options you can specify. Please use `python train.py --help`. The specified options are printed to the console. To specify the number of GPUs to utilize, use `--gpu_ids`. If you want to use the second and third GPUs for example, use `--gpu_ids 1,2`.\n\nTo log training, use `--tf_log` for Tensorboard. The logs are stored at `[checkpoints_dir]/[name]/logs`.\n\n## Testing\n\nTesting is similar to testing pretrained models.\n\n```bash\npython test.py --name [name_of_experiment] --dataset_mode [dataset_mode] --dataroot [path_to_dataset]\n```\n\nUse `--results_dir` to specify the output directory. `--how_many` will specify the maximum number of images to generate. By default, it loads the latest checkpoint. It can be changed using `--which_epoch`.\n\n## Code Structure\n\n- `train.py`, `test.py`: the entry point for training and testing.\n- `trainers/pix2pix_trainer.py`: harnesses and reports the progress of training.\n- `models/pix2pix_model.py`: creates the networks, and compute the losses\n- `models/networks/`: defines the architecture of all models\n- `options/`: creates option lists using `argparse` package. More individuals are dynamically added in other files as well. Please see the section below.\n- `data/`: defines the class for loading images and label maps.\n\n## Options\n\nThis code repo contains many options. Some options belong to only one specific model, and some options have different default values depending on other options. To address this, the `BaseOption` class dynamically loads and sets options depending on what model, network, and datasets are used. This is done by calling the static method `modify_commandline_options` of various classes. It takes in the`parser` of `argparse` package and modifies the list of options. For example, since COCO-stuff dataset contains a special label \"unknown\", when COCO-stuff dataset is used, it sets `--contain_dontcare_label` automatically at `data/coco_dataset.py`. You can take a look at `def gather_options()` of `options/base_options.py`, or `models/network/__init__.py` to get a sense of how this works.\n\n## VAE-Style Training with an Encoder For Style Control and Multi-Modal Outputs\n\nTo train our model along with an image encoder to enable multi-modal outputs as in Figure 15 of the [paper](https://arxiv.org/pdf/1903.07291.pdf), please use `--use_vae`. The model will create `netE` in addition to `netG` and `netD` and train with KL-Divergence loss.\n\n### Citation\nIf you use this code for your research, please cite our papers.\n```\n@inproceedings{park2019SPADE,\n  title={Semantic Image Synthesis with Spatially-Adaptive Normalization},\n  author={Park, Taesung and Liu, Ming-Yu and Wang, Ting-Chun and Zhu, Jun-Yan},\n  booktitle={Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition},\n  year={2019}\n}\n```\n\n## Acknowledgments\nThis code borrows heavily from pix2pixHD. We thank Jiayuan Mao for his Synchronized Batch Normalization code.\n",
        "releases": []
    }
}
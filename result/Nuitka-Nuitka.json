{
    "https://api.github.com/repos/Nuitka/Nuitka": {
        "forks": 658,
        "watchers": 12401,
        "stars": 12401,
        "languages": {
            "Python": 14855353,
            "C": 9002924,
            "Jinja": 331808,
            "C++": 95464,
            "Dockerfile": 4517,
            "Batchfile": 1985,
            "Shell": 1547
        },
        "commits": [
            "2025-01-20T08:37:43Z",
            "2025-01-20T08:37:24Z",
            "2025-01-20T08:37:17Z",
            "2025-01-20T07:29:38Z",
            "2025-01-20T07:12:45Z",
            "2025-01-18T18:34:33Z",
            "2025-01-18T17:50:25Z",
            "2025-01-18T17:14:48Z",
            "2025-01-18T15:50:43Z",
            "2025-01-18T15:50:02Z",
            "2025-01-18T10:16:56Z",
            "2025-01-18T10:09:36Z",
            "2025-01-18T10:09:11Z",
            "2025-01-20T07:10:37Z",
            "2025-01-18T09:56:34Z",
            "2025-01-15T13:11:30Z",
            "2025-01-13T11:00:34Z",
            "2025-01-13T08:43:15Z",
            "2025-01-13T08:21:02Z",
            "2025-01-07T07:57:04Z",
            "2025-01-07T07:54:42Z",
            "2025-01-06T10:06:07Z",
            "2025-01-06T09:15:12Z",
            "2025-01-06T09:13:21Z",
            "2025-01-06T09:12:42Z",
            "2025-01-06T08:13:36Z",
            "2025-01-06T08:12:44Z",
            "2025-01-05T15:31:41Z",
            "2025-01-05T15:26:08Z",
            "2025-01-03T09:35:59Z"
        ],
        "creation_date": "2013-04-23T15:40:33Z",
        "contributors": 30,
        "topics": [
            "compiler",
            "nuitka",
            "packaging-tool",
            "performance",
            "programming",
            "python",
            "python-compiler"
        ],
        "subscribers": 138,
        "readme": ".. image:: https://img.shields.io/pypi/pyversions/Nuitka.svg\n   :target: https://pypi.org/project/Nuitka\n\n.. image:: https://badge.fury.io/py/Nuitka.svg\n   :target: https://pypi.org/project/Nuitka\n\n.. image:: https://img.shields.io/badge/Contributor%20Covenant-v1.4%20adopted-ff69b4.svg\n   :target: CODE_OF_CONDUCT.md\n\n####################\n Nuitka User Manual\n####################\n\nThis document is the recommended first read when you start using\n**Nuitka**. On this page, you will learn more about **Nuitka**\nfundamentals, such as license type, use cases, requirements, and\ncredits.\n\n.. contents:: Table of Contents\n   :depth: 1\n   :local:\n   :class: page-toc\n\nNuitka is **the** Python compiler. It is written in Python. It is a\nseamless replacement or extension to the Python interpreter and compiles\n**every** construct that Python 2 (2.6, 2.7) and Python 3 (3.4 - 3.13)\nhave, when itself run with that Python version.\n\nIt then executes uncompiled code and compiled code together in an\nextremely compatible manner.\n\nYou can use all Python library modules and all extension modules freely.\n\nNuitka translates the Python modules into a C level program that then\nuses ``libpython`` and static C files of its own to execute in the same\nway as CPython does.\n\nAll optimization is aimed at avoiding overhead, where it's unnecessary.\nNone is aimed at removing compatibility, although slight improvements\nwill occasionally be done, where not every bug of standard Python is\nemulated, e.g. more complete error messages are given, but there is a\nfull compatibility mode to disable even that.\n\n**************\n Requirements\n**************\n\nTo ensure smooth operation of **Nuitka**, make sure to follow system\nrequirements, that include the following components:\n\n.. contents::\n   :depth: 1\n   :local:\n\nC Compiler\n==========\n\nYou need a C compiler with support for C11 or alternatively a C++\ncompiler for C++03 [#]_.\n\nCurrently, this means, you need to use one of these compilers:\n\n-  The MinGW64 C11 compiler, on Windows, must be based on gcc 11.2 or\n   higher. It will be *automatically* downloaded if no usable C compiler\n   is found, which is the recommended way of installing it, as Nuitka\n   will also upgrade it for you.\n\n-  Visual Studio 2022 or higher on Windows [#]_. English language pack\n   for best results (Nuitka filters away garbage outputs, but only for\n   English language). It will be used by default if installed.\n\n-  On all other platforms, the ``gcc`` compiler of at least version 5.1,\n   and below that the ``g++`` compiler of at least version 4.4 as an\n   alternative.\n\n-  The ``clang`` compiler on macOS X and most FreeBSD architectures.\n\n-  On Windows, the ``clang-cl`` compiler on Windows can be used if\n   provided by the Visual Studio installer.\n\n.. [#]\n\n   Support for this C11 is given with gcc 5.x or higher or any clang\n   version.\n\n   The older MSVC compilers don't do it yet. But as a workaround, with\n   Python 3.10 or older, the C++03 language standard is significantly\n   overlapping with C11, it is then used instead.\n\n.. [#]\n\n   Download for free from\n   https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx\n   (the community editions work just fine).\n\n   The latest version is recommended, but not required. On the other hand,\n   there is no need to except to support pre-Windows 10 versions, and they\n   might work for you, but support of these configurations is only\n   available to commercial users.\n\nPython\n======\n\n**Python 2** (2.6, 2.7) and **Python 3** (3.4 \u2014 3.13) are supported. If\nat any moment, there is a stable Python release that is not in this\nlist, rest assured it is being worked on and will be added.\n\n.. important::\n\n   For Python 3.4 and *only* that version, we need other Python version\n   as a *compile time* dependency.\n\n   Nuitka itself is fully compatible with all listed versions, but Scons\n   as an internally used tool is not.\n\n   For these versions, you *need* a Python2 or Python 3.5 or higher\n   installed as well, but only during the compile time. That is for use\n   with Scons (which orchestrates the C compilation), which does not\n   support the same Python versions as Nuitka.\n\n   In addition, on Windows, Python2 cannot be used because ``clcache``\n   does not work with it, there a Python 3.5 or higher needs to be\n   installed.\n\n   Nuitka finds these needed Python versions (e.g. on Windows via\n   registry) and you shouldn't notice it as long as they are installed.\n\n   Increasingly, other functionality is available when another Python\n   has a certain package installed. For example, onefile compression\n   will work for a Python 2.x when another Python is found that has the\n   ``zstandard`` package installed.\n\n.. admonition:: Moving binaries to other machines\n\n   The created binaries can be made executable independent of the Python\n   installation, with ``--standalone`` and ``--onefile`` options.\n\n.. admonition:: Binary filename suffix\n\n   The created binaries have an ``.exe`` suffix on Windows. On other\n   platforms they have no suffix for standalone mode, or ``.bin``\n   suffix, that you are free to remove or change, or specify with the\n   ``-o`` option.\n\n   The suffix for acceleration mode is added just to be sure that the\n   original script name and the binary name do not ever collide, so we\n   can safely overwrite the binary without destroying the original\n   source file.\n\n.. admonition:: It **has to** be CPython, Anaconda Python, or Homebrew\n\n   You need the standard Python implementation, called \"CPython\", to\n   execute Nuitka because it is closely tied to implementation details\n   of it.\n\n.. admonition:: It **cannot be** from the Windows app store\n\n   It is known that Windows app store Python definitely does not work,\n   it's checked against.\n\n.. admonition:: It **cannot be** pyenv on macOS\n\n   It is known that macOS \"pyenv\" does **not** work. Use Homebrew\n   instead for self compiled Python installations. But note that\n   standalone mode will be worse on these platforms and not be as\n   backward compatible with older macOS versions.\n\nOperating System\n================\n\nSupported Operating Systems: Linux, FreeBSD, NetBSD, macOS, and Windows\n(32 bits/64 bits/ARM).\n\nOthers will work as well. The portability is expected to be generally\ngood, but the e.g. Nuitka's internal Scons usage may have to be adapted\nor need flags passed. Make sure to match Python and C compiler\narchitecture, or else you will get cryptic error messages.\n\nArchitecture\n============\n\nSupported Architectures are x86, x86_64 (amd64), and arm, likely many,\nmany more.\n\nOther architectures are expected to also work, out of the box, as Nuitka\nis generally not using any hardware specifics. These are just the ones\ntested and known to be good. Feedback is welcome. Generally, the\narchitectures that Debian supports can be considered good and tested,\ntoo.\n\n*******\n Usage\n*******\n\nCommand Line\n============\n\nThe recommended way of executing Nuitka is ``<the_right_python> -m\nnuitka`` to be absolutely certain which Python interpreter you are\nusing, so it is easier to match with what Nuitka has.\n\nThe next best way of executing Nuitka bare that is from a source\ncheckout or archive, with no environment variable changes, most\nnoteworthy, you do not have to mess with ``PYTHONPATH`` at all for\nNuitka. You just execute the ``nuitka`` and ``nuitka-run`` scripts\ndirectly without any changes to the environment. You may want to add the\n``bin`` directory to your ``PATH`` for your convenience, but that step\nis optional.\n\nMoreover, if you want to execute with the right interpreter, in that\ncase, be sure to execute ``<the_right_python> bin/nuitka`` and be good.\n\n.. admonition:: Pick the right Interpreter\n\n   If you encounter a ``SyntaxError`` you absolutely most certainly have\n   picked the wrong interpreter for the program you are compiling.\n\nNuitka has a ``--help`` option to output what it can do:\n\n.. code:: bash\n\n   nuitka --help\n\nThe ``nuitka-run`` command is the same as ``nuitka``, but with a\ndifferent default. It tries to compile *and* directly execute a Python\nscript:\n\n.. code:: bash\n\n   nuitka-run --help\n\nThis option that is different is ``--run``, and passing on arguments\nafter the first non-option to the created binary, so it is somewhat more\nsimilar to what plain ``python`` will do.\n\nInstallation\n============\n\nFor most systems, there will be packages on the `download page\n<https://nuitka.net/doc/download.html>`__ of Nuitka. But you can also\ninstall it from source code as described above, but also like any other\nPython program it can be installed via the normal ``python setup.py\ninstall`` routine.\n\nNotice for integration with GitHub workflows there is this\n`Nuitka-Action <https://github.com/Nuitka/Nuitka-Action>`__ that you\nshould use that makes it really easy to integrate. You ought to start\nwith a local compilation though, but this will be easiest for cross\nplatform compilation with Nuitka.\n\nLicense\n=======\n\nNuitka is licensed under the Apache License, Version 2.0; you may not\nuse it except in compliance with the License.\n\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*************************************\n Tutorial Setup and build on Windows\n*************************************\n\nThis is basic steps if you have nothing installed, of course if you have\nany of the parts, just skip it.\n\nSetup\n=====\n\nInstall Python\n--------------\n\n-  Download and install Python from\n   https://www.python.org/downloads/windows\n\n-  Select one of ``Windows x86-64 web-based installer`` (64 bits Python,\n   recommended) or ``x86 executable`` (32 bits Python) installer.\n\n-  Verify it's working using command ``python --version``.\n\nInstall Nuitka\n--------------\n\n-  ``python -m pip install nuitka``\n\n-  Verify using command ``python -m nuitka --version``\n\nWrite some code and test\n========================\n\nCreate a folder for the Python code\n-----------------------------------\n\n-  ``mkdir`` HelloWorld\n\n-  make a python file named **hello.py**\n\n.. code:: python\n\n   def talk(message):\n       return \"Talk \" + message\n\n\n   def main():\n       print(talk(\"Hello World\"))\n\n\n   if __name__ == \"__main__\":\n       main()\n\nTest your program\n-----------------\n\nDo as you normally would. Running Nuitka on code that works incorrectly\nis not easier to debug.\n\n.. code:: bash\n\n   python hello.py\n\n----\n\nBuild it using\n--------------\n\n.. code:: bash\n\n   python -m nuitka hello.py\n\n.. note::\n\n   This will prompt you to download a C caching tool (to speed up\n   repeated compilation of generated C code) and a MinGW64 based C\n   compiler, unless you have a suitable MSVC installed. Say ``yes`` to\n   both those questions.\n\nRun it\n------\n\nExecute the ``hello.exe`` created near ``hello.py``.\n\nDistribute\n----------\n\nTo distribute, build with ``--standalone`` option, which will not output\na single executable, but a whole folder. Copy the resulting\n``hello.dist`` folder to the other machine and run it.\n\nYou may also try ``--onefile`` which does create a single file, but make\nsure that the mere standalone is working, before turning to it, as it\nwill make the debugging only harder, e.g. in case of missing data files.\n\n***********\n Use Cases\n***********\n\nUse Case 1 \u2014 Program compilation with all modules embedded\n==========================================================\n\nIf you want to compile a whole program recursively, and not only the\nsingle file that is the main program, do it like this:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports program.py\n\n.. note::\n\n   There are more fine-grained controls than ``--follow-imports``\n   available. Consider the output of ``nuitka --help``. Including fewer\n   modules into the compilation, but instead using normal Python for it,\n   will make it faster to compile.\n\nIn case you have a source directory with dynamically loaded files, i.e.\none which cannot be found by recursing after normal import statements\nvia the ``PYTHONPATH`` (which would be the recommended way), you can\nalways require that a given directory shall also be included in the\nexecutable:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports --include-plugin-directory=plugin_dir program.py\n\n.. note::\n\n   If you don't do any dynamic imports, simply setting your\n   ``PYTHONPATH`` at compilation time is what you should do.\n\n   Use ``--include-plugin-directory`` only if you make ``__import__()``\n   calls that Nuitka cannot predict, and that come from a directory, for\n   everything from your Python installation, use ``--include-module`` or\n   ``--include-package``.\n\n.. note::\n\n   The resulting filename will be ``program.exe`` on Windows,\n   ``program.bin`` on other platforms, but ``--output-filename`` allows\n   changing that.\n\n.. note::\n\n   The resulting binary still depends on CPython and used C extension\n   modules being installed.\n\n   If you want to be able to copy it to another machine, use\n   ``--standalone`` and copy the created ``program.dist`` directory and\n   execute the ``program.exe`` (Windows) or ``program`` (other\n   platforms) put inside.\n\nUse Case 2 \u2014 Extension Module compilation\n=========================================\n\nIf you want to compile a single extension module, all you have to do is\nthis:\n\n.. code:: bash\n\n   python -m nuitka --mode=module some_module.py\n\nThe resulting file ``some_module.so`` can then be used instead of\n``some_module.py``.\n\n.. important::\n\n   The filename of the produced extension module must not be changed as\n   Python insists on a module name derived function as an entry point,\n   in this case ``PyInit_some_module`` and renaming the file will not\n   change that. Match the filename of the source code to what the binary\n   name should be.\n\n.. note::\n\n   If both the extension module and the source code of it are in the\n   same directory, the extension module is loaded. Changes to the source\n   code only have effect once you recompile.\n\n.. note::\n\n   The option ``--follow-import-to`` works as well, but the included\n   modules will only become importable *after* you imported the\n   ``some_module`` name. If these kinds of imports are invisible to\n   Nuitka, e.g. dynamically created, you can use ``--include-module`` or\n   ``--include-package`` in that case, but for static imports it should\n   not be needed.\n\n.. note::\n\n   An extension module can never include other extension modules. You\n   will have to create a wheel for this to be doable.\n\n.. note::\n\n   The resulting extension module can only be loaded into a CPython of\n   the same version and doesn't include other extension modules.\n\nUse Case 3 \u2014 Package compilation\n================================\n\nIf you need to compile a whole package and embed all modules, that is\nalso feasible, use Nuitka like this:\n\n.. code:: bash\n\n   python -m nuitka --mode=module some_package --include-package=some_package\n\n.. note::\n\n   The inclusion of the package contents needs to be provided manually;\n   otherwise, the package is mostly empty. You can be more specific if\n   you like, and only include part of it, or exclude part of it, e.g.\n   with ``--nofollow-import-to='*.tests'`` you would not include the\n   unused test part of your code.\n\n.. note::\n\n   Data files located inside the package will not be embedded by this\n   process, you need to copy them yourself with this approach.\n   Alternatively, you can use the `file embedding of Nuitka commercial\n   <https://nuitka.net/doc/commercial/protect-data-files.html>`__.\n\nUse Case 4 \u2014 Program Distribution\n=================================\n\nFor distribution to other systems, there is the standalone mode, which\nproduces a folder for which you can specify ``--standalone``.\n\n.. code:: bash\n\n   python -m nuitka --standalone program.py\n\nFollowing all imports is default in this mode. You can selectively\nexclude modules by specifically saying ``--nofollow-import-to``, but\nthen an ``ImportError`` will be raised when import of it is attempted at\nprogram run time. This may cause different behavior, but it may also\nimprove your compile time if done wisely.\n\nFor data files to be included, use the option\n``--include-data-files=<source>=<target>`` where the source is a file\nsystem path, but the target has to be specified relative. For the\nstandalone mode, you can also copy them manually, but this can do extra\nchecks, and for the onefile mode, there is no manual copying possible.\n\nTo copy some or all file in a directory, use the option\n``--include-data-files=/etc/*.txt=etc/`` where you get to specify shell\npatterns for the files, and a subdirectory where to put them, indicated\nby the trailing slash.\n\n.. important::\n\n   Nuitka does not consider data files code, do not include DLLs, or\n   Python files as data files, and expect them to work, they will not,\n   unless you really know what you are doing.\n\nIn the following, non-code data files are all files, not matching on of\nthese criterions.\n\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| Suffix     | Rationale                                                                              | Solution                                                                                               |\n+============+========================================================================================+========================================================================================================+\n| ``.py``    | Nuitka trims even the stdlib modules to be included. If it doesn't see Python code,    | Use ``--include-module`` on them instead                                                               |\n|            | there is no dependencies analyzed, and as a result it will just not work.              |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyc``   | Same as ``.py``.                                                                       | Use ``--include-module`` on them from their source code instead.                                       |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyo``   | Same as ``.pyc``.                                                                      | Use ``--include-module`` on them from their source code instead.                                       |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyw``   | Same as ``.py``.                                                                       | For including multiple programs, use multiple ``--main`` arguments instead.                            |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyi``   | These are ignored, because they are code-like and not needed at run time. For the      | Raise an issue if 3rd part software needs it.                                                          |\n|            | ``lazy`` package that actually would depend on them, we made a compile time solution   |                                                                                                        |\n|            | that removes the need.                                                                 |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyx``   | These are ignored, because they are Cython source code not used at run time            |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.dll``   | These are ignored, since they **usually** are not data files. For the cases where 3rd  | Create Nuitka Package configuration for those, with ``dll`` section for the package that uses them.    |\n|            | party packages do actually used them as data, e.g. ``.NET`` packages, we solve that in | For rare cases, data-files section with special configuration might be the correct thing to do.        |\n|            | package configuration for it.                                                          |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.dylib`` | These are ignored, since they macOS extension modules or DLLs.                         | Need to add configuration with ``dll`` section or ``depends`` that are missing                         |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.so``    | These are ignored, since they Linux, BSD, etc. extension modules or DLLs.              | Need to add configuration with ``dll`` section or ``depends`` that are missing                         |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.exe``   | The are binaries to Windows.                                                           | You can add Nuitka Package configuration to include those as DLLs and mark them as ``executable: yes`` |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.bin``   | The are binaries to non-Windows, otherwise same as ``.exe``.                           |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n\nAlso folders are ignored, these are ``site-packages``, ``dist-packages``\nand ``vendor-packages`` which would otherwise include a full virtualenv,\nwhich is never a good thing to happen. And the ``__pycache__`` folder is\nalso always ignored. On non-MacOS the file ``.DS_Store`` is ignored too,\nand ``py.typed`` folders have only meaning to IDEs, and are ignored like\n``.pyi`` files .\n\nTo copy a whole folder with all non-code files, you can use\n``--include-data-dir=/path/to/images=images`` which will place those in\nthe destination, and if you want to use the ``--noinclude-data-files``\noption to remove them. Code files are as detailed above DLLs,\nexecutables, Python files, etc. and will be ignored. For those you can\nuse the ``--include-data-files=/binaries/*.exe=binary/`` form to force\nthem, but that is not recommended and known to cause issues at run-time.\n\nFor package data, there is a better way, namely using\n``--include-package-data``, which detects all non-code data files of\npackages automatically and copies them over. It even accepts patterns in\na shell style. It spares you the need to find the package directory\nyourself and should be preferred whenever available. Functionally it's\nvery similar to ``--include-data-dir`` but it has the benefit to locate\nthe correct folder for you.\n\nWith data files, you are largely on your own. Nuitka keeps track of ones\nthat are needed by popular packages, but it might be incomplete. Raise\nissues if you encounter something in these. Even better, raise PRs with\nenhancements to the Nuitka package configuration. We want 3rd party\nsoftware to just work out of the box.\n\nWhen that is working, you can use the onefile mode if you so desire.\n\n.. code:: bash\n\n   python -m nuitka --onefile program.py\n\nThis will create a single binary, that extracts itself on the target,\nbefore running the program. But notice, that accessing files relative to\nyour program is impacted, make sure to read the section `Onefile:\nFinding files`_ as well.\n\n.. code:: bash\n\n   # Create a binary that unpacks into a temporary folder\n   python -m nuitka --onefile program.py\n\n.. note::\n\n   There are more platform-specific options, e.g. related to icons,\n   splash screen, and version information, consider the ``--help``\n   output for the details of these and check the section Tweaks_.\n\nFor the unpacking, by default a unique user temporary path one is used,\nand then deleted, however this default\n``--onefile-tempdir-spec=\"{TEMP}/onefile_{PID}_{TIME}\"`` can be\noverridden with a path specification, then using a cached path, avoiding\nrepeated unpacking, e.g. with\n``--onefile-tempdir-spec=\"{CACHE_DIR}/{COMPANY}/{PRODUCT}/{VERSION}\"``\nwhich uses version information, and user-specific cache directory.\n\n.. note::\n\n   Using cached paths will be relevant, e.g. when Windows Firewall comes\n   into play because otherwise, the binary will be a different one to it\n   each time it is run.\n\nCurrently, these expanded tokens are available:\n\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| Token          | What this Expands to                                      | Example                               |\n+================+===========================================================+=======================================+\n| {TEMP}         | User temporary file directory                             | C:\\\\Users\\\\...\\\\AppData\\\\Locals\\\\Temp |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PID}          | Process ID                                                | 2772                                  |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {TIME}         | Time in seconds since the epoch.                          | 1299852985                            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PROGRAM}      | Full program run-time filename of executable.             | C:\\\\SomeWhere\\\\YourOnefile.exe        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PROGRAM_BASE} | No-suffix of run-time filename of executable.             | C:\\\\SomeWhere\\\\YourOnefile            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {CACHE_DIR}    | Cache directory for the user.                             | C:\\\\Users\\\\SomeBody\\\\AppData\\\\Local   |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {COMPANY}      | Value given as ``--company-name``                         | YourCompanyName                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PRODUCT}      | Value given as ``--product-name``                         | YourProductName                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {VERSION}      | Combination of ``--file-version`` & ``--product-version`` | 3.0.0.0-1.0.0.0                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {HOME}         | Home directory for the user.                              | /home/somebody                        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {NONE}         | When provided for file outputs, ``None`` is used          | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {NULL}         | When provided for file outputs, ``os.devnull`` is used    | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n\n.. important::\n\n   It is your responsibility to make the path provided unique, on\n   Windows a running program will be locked, and while using a fixed\n   folder name is possible, it can cause locking issues in that case,\n   where the program gets restarted.\n\n   Usually, you need to use ``{TIME}`` or at least ``{PID}`` to make a\n   path unique, and this is mainly intended for use cases, where e.g.\n   you want things to reside in a place you choose or abide your naming\n   conventions.\n\n.. important::\n\n   For disabling output and stderr with ``--force-stdout-spec`` and\n   ``--force-stderr-spec`` the values ``{NONE}`` and ``{NULL}`` achieve\n   it, but with different effect. With ``{NONE}``, the corresponding\n   handle becomes ``None``. As a result, e.g. ``sys.stdout`` will be\n   ``None``, which is different from ``{NULL}`` where it will be backed\n   by a file pointing to ``os.devnull``, i.e. you can write to it.\n\n   With ``{NONE}``, you may e.g. get ``RuntimeError: lost sys.stdout``\n   in case it does get used; with ``{NULL}`` that never happens.\n   However, some libraries handle this as input for their logging\n   mechanism, and on Windows this is how you are compatible with\n   ``pythonw.exe`` which is behaving like ``{NONE}``.\n\nUse Case 5 \u2014 Setuptools Wheels\n==============================\n\nIf you have a ``setup.py``, ``setup.cfg`` or ``pyproject.toml`` driven\ncreation of wheels for your software in place, putting Nuitka to use is\nextremely easy.\n\nLet's start with the most common ``setuptools`` approach, you can,\nhaving Nuitka installed of course, simply execute the target\n``bdist_nuitka`` rather than the ``bdist_wheel``. It takes all the\noptions and allows you to specify some more, that are specific to\nNuitka.\n\n.. code:: python\n\n   # For setup.py if you don't use other build systems:\n   setup(\n      # Data files are to be handled by setuptools and not Nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # This is to pass Nuitka options.\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': True,\n            # options without value, e.g. enforce using Clang\n            '--clang': None,\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': \"pyside2\",\n            # options with several values, e.g. avoid including modules\n            '--nofollow-import-to' : [\"*.tests\", \"*.distutils\"],\n         },\n      },\n   )\n\n   # For setup.py with other build systems:\n   # The tuple nature of the arguments is required by the dark nature of\n   # \"setuptools\" and plugins to it, that insist on full compatibility,\n   # e.g. \"setuptools_rust\"\n\n   setup(\n      # Data files are to be handled by setuptools and not Nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # This is to pass Nuitka options.\n      ...,\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': (\"setup.py\", True),\n            # options without value, e.g. enforce using Clang\n            '--clang': (\"setup.py\", None),\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': (\"setup.py\", \"pyside2\"),\n            # options with several values, e.g. avoid including modules\n            '--nofollow-import-to' : (\"setup.py\", [\"*.tests\", \"*.distutils\"]),\n         }\n      },\n   )\n\nIf for some reason, you cannot or do not want to change the target, you\ncan add this to your ``setup.py``.\n\n.. code:: python\n\n   # For setup.py\n   setup(\n      ...,\n      build_with_nuitka=True\n   )\n\n.. note::\n\n   To temporarily disable the compilation, you could the remove above\n   line, or edit the value to ``False`` by or take its value from an\n   environment variable if you so choose, e.g.\n   ``bool(os.getenv(\"USE_NUITKA\", \"True\"))``. This is up to you.\n\nOr you could put it in your ``setup.cfg``\n\n.. code:: toml\n\n   [metadata]\n   build_with_nuitka = true\n\nAnd last, but not least, Nuitka also supports the new ``build`` meta, so\nwhen you have a ``pyproject.toml`` already, simple replace or add this\nvalue:\n\n.. code:: toml\n\n   [build-system]\n   requires = [\"setuptools>=42\", \"wheel\", \"nuitka\", \"toml\"]\n   build-backend = \"nuitka.distutils.Build\"\n\n   # Data files are to be handled by setuptools and not Nuitka\n   [tool.setuptools.package-data]\n   some_package = ['data_file.txt']\n\n   [tool.nuitka]\n   # These are not recommended, but they make it obvious to have effect.\n\n   # boolean option, e.g. if you cared for C compilation commands, leading\n   # dashes are omitted\n   show-scons = true\n\n   # options with single values, e.g. enable a plugin of Nuitka\n   enable-plugin = \"pyside2\"\n\n   # options with several values, e.g. avoid including modules, accepts\n   # list argument.\n   nofollow-import-to = [\"*.tests\", \"*.distutils\"]\n\n.. note::\n\n   For the ``nuitka`` requirement above absolute paths like\n   ``C:\\Users\\...\\Nuitka`` will also work on Linux, use an absolute path\n   with *two* leading slashes, e.g. ``//home/.../Nuitka``.\n\n.. note::\n\n   Whatever approach you take, data files in these wheels are not\n   handled by Nuitka at all, but by setuptools. You can, however, use\n   the data file embedding of Nuitka commercial. In that case, you\n   actually would embed the files inside the extension module itself,\n   and not as a file in the wheel.\n\nUse Case 6 \u2014 Multidist\n======================\n\nIf you have multiple programs, that each should be executable, in the\npast you had to compile multiple times, and deploy all of these. With\nstandalone mode, this, of course, meant that you were fairly wasteful,\nas sharing the folders could be done, but wasn't really supported by\nNuitka.\n\nEnter ``Multidist``. There is an option ``--main`` that replaces or adds\nto the positional argument given. And it can be given multiple times.\nWhen given multiple times, Nuitka will create a binary that contains the\ncode of all the programs given, but sharing modules used in them. They\ntherefore do not have to be distributed multiple times.\n\nLet's call the basename of the main path, and entry point. The names of\nthese must, of course, be different. Then the created binary can execute\neither entry point, and will react to what ``sys.argv[0]`` appears to\nit. So if executed in the right way (with something like ``subprocess``\nor OS API you can control this name), or by renaming or copying the\nbinary, or symlinking to it, you can then achieve the miracle.\n\nThis allows to combine very different programs into one.\n\n.. note::\n\n   This feature is still experimental. Use with care and report your\n   findings should you encounter anything that is undesirable behavior\n\nThis mode works with standalone, onefile, and mere acceleration. It does\nnot work with module mode.\n\nUse Case 7 \u2014 Building with GitHub Workflows\n===========================================\n\nFor integration with GitHub workflows there is this `Nuitka-Action\n<https://github.com/Nuitka/Nuitka-Action>`__ that you should use that\nmakes it really easy to integrate. You ought to start with a local\ncompilation though, but this will be easiest for cross platform\ncompilation with Nuitka.\n\nThis is an example workflow that builds on all 3 OSes\n\n.. code:: yaml\n\n   jobs:\n   build:\n      strategy:\n         matrix:\n         os: [macos-latest, ubuntu-latest, windows-latest]\n\n      runs-on: ${{ matrix.os }}\n\n      steps:\n         - name: Check-out repository\n         uses: actions/checkout@v4\n\n         - name: Setup Python\n         uses: actions/setup-python@v5\n         with:\n            python-version: '3.10'\n            cache: 'pip'\n            cache-dependency-path: |\n               **/requirements*.txt\n\n         - name: Install your Dependencies\n         run: |\n            pip install -r requirements.txt -r requirements-dev.txt\n\n         - name: Build Executable with Nuitka\n         uses: Nuitka/Nuitka-Action@main\n         with:\n            nuitka-version: main\n            script-name: your_main_program.py\n            # many more Nuitka options available, see action doc, but it's best\n            # to use nuitka-project: options in your code, so e.g. you can make\n            # a difference for macOS and create an app bundle there.\n            onefile: true\n\n         - name: Upload Artifacts\n         uses: actions/upload-artifact@v3\n         with:\n            name: ${{ runner.os }} Build\n            path: | # match what's created for the 3 OSes\n               build/*.exe\n               build/*.bin\n               build/*.app/**/*\n\nIf you app is a GUI, e.g. ``your_main_program.py`` should contain these\ncomments as explained in `Nuitka Options in the code`_ since on macOS\nthis should then be a bundle.\n\n.. code:: python\n\n   # Compilation mode, standalone everywhere, except on macOS there app bundle\n   # nuitka-project-if: {OS} in (\"Windows\", \"Linux\", \"FreeBSD\"):\n   #    nuitka-project: --onefile\n   # nuitka-project-if: {OS} == \"Darwin\":\n   #    nuitka-project: --standalone\n   #    nuitka-project: --macos-create-app-bundle\n   #\n\n.. note::\n\n   This is best expression with ``nuitka-project: --mode=app`` which\n   encapsulates these options.\n\n********\n Tweaks\n********\n\nIcons\n=====\n\nFor good looks, you may specify icons. On Windows, you can provide an\nicon file, a template executable, or a PNG file. All of these will work\nand may even be combined:\n\n.. code:: bash\n\n   # These create binaries with icons on Windows\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.png program.py\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.ico program.py\n   python -m nuitka --onefile --windows-icon-template-exe=your-icon.ico program.py\n\n   # These create application bundles with icons on macOS\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.png program.py\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.icns program.py\n\n.. note::\n\n   With Nuitka, you do not have to create platform-specific icons, but\n   instead it will convert e.g. PNG, but also other formats on the fly\n   during the build.\n\nMacOS Entitlements\n==================\n\nEntitlements for an macOS application bundle can be added with the\noption, ``--macos-app-protected-resource``, all values are listed on\n`this page from Apple\n<https://developer.apple.com/documentation/bundleresources/information_property_list/protected_resources>`__\n\nAn example value would be\n``--macos-app-protected-resource=NSMicrophoneUsageDescription:Microphone\naccess`` for requesting access to a Microphone. After the colon, the\ndescriptive text is to be given.\n\n.. note::\n\n   Beware that in the likely case of using spaces in the description\n   part, you need to quote it for your shell to get through to Nuitka\n   and not be interpreted as Nuitka arguments.\n\nConsole Window\n==============\n\nOn Windows, the console is not opened by programs unless you say so.\nNuitka defaults to not show it, you can force it by using\n``--console=force`` though, then the program will open a new terminal\nWindow when its executed.\n\nSplash screen\n=============\n\nSplash screens are useful when program startup is slow. Onefile startup\nitself is not slow, but your program may be, and you cannot really know\nhow fast the computer used will be, so it might be a good idea to have\nthem. Luckily, with Nuitka, they are easy to add for Windows.\n\nFor the splash screen, you need to specify it as a PNG file, and then\nmake sure to disable the splash screen when your program is ready, e.g.\nhas completed the imports, prepared the window, connected to the\ndatabase, and wants the splash screen to go away. Here we are using the\nproject syntax to combine the code with the creation, compile this:\n\n.. code:: python\n\n   # nuitka-project: --mode=onefile\n   # nuitka-project: --mode=onefile-windows-splash-screen-image={MAIN_DIRECTORY}/Splash-Screen.png\n\n   # Whatever this is, obviously\n   print(\"Delaying startup by 10s...\")\n   import time, tempfile, os\n   time.sleep(10)\n\n   # Use this code to signal the splash screen removal.\n   if \"NUITKA_ONEFILE_PARENT\" in os.environ:\n      splash_filename = os.path.join(\n         tempfile.gettempdir(),\n         \"onefile_%d_splash_feedback.tmp\" % int(os.environ[\"NUITKA_ONEFILE_PARENT\"]),\n      )\n\n      if os.path.exists(splash_filename):\n         os.unlink(splash_filename)\n\n   print(\"Done... splash should be gone.\")\n   ...\n\n   # Rest of your program goes here.\n\nReports\n=======\n\nFor analysis of your program and Nuitka packaging, there is the\n`Compilation Report`_ available. You can also make custom reports by\nproviding your template, with a few of them built-in to Nuitka. These\nreports carry all the detail information, e.g. when a module was\nattempted to be imported, but not found, you can see where that happens.\nFor bug reporting, it is very much recommended to provide the report.\n\nVersion Information\n===================\n\nYou can attach copyright and trademark information, company name,\nproduct name, and so on to your compilation. This is then used in\nversion information for the created binary on Windows, or application\nbundle on macOS. If you find something that is lacking, please let us\nknow.\n\n******************\n Typical Problems\n******************\n\nDeployment Mode\n===============\n\nBy default, Nuitka compiles without ``--deployment`` which leaves a set\nof safe guards and helpers on, that are aimed at debugging wrong uses of\nNuitka.\n\nThis is a new feature, and implements a bunch of protections and\nhelpers, that are documented here.\n\nFork bombs (self-execution)\n---------------------------\n\nSo after compilation, ``sys.executable`` is the compiled binary. In case\nof packages like ``multiprocessing``, ``joblib``, or ``loky`` what these\ntypically do is to expect to run from a full ``python`` with\n``sys.executable`` and then to be able to use its options like ``-c\ncommand`` or ``-m module_name`` and then be able to launch other code\ntemporarily or permanently as a service daemon.\n\nWith Nuitka however, this executes your program again, and puts these\narguments, in ``sys.argv`` where you maybe ignore them, and then you\nfork yourself again to launch the helper daemons. Sometimes this ends up\nspawning CPU count processes that spawn CPU count processes that... this\nis called a fork bomb, and with almost all systems, that freezes them\neasily to death.\n\nThat is why e.g. this happens with default Nuitka:\n\n.. code::\n\n   ./hello.dist/hello.bin -l fooL -m fooM -n fooN -o fooO -p\n   Error, the program tried to call itself with '-m' argument. Disable with '--no-deployment-flag=self-execution'.\n\nYour program may well have its own command line parsing, and not use an\nunsupported package that does attempt to re-execute. In this case, you\nneed at *compile time* to use ``--no-deployment-flag=self-execution``\nwhich disables this specific guard.\n\nMisleading Messages\n-------------------\n\nSome packages output what they think is helpful information about what\nthe reason of a failed import might mean. With compiled programs there\nare very often just plain wrong. We try and repair those in\nnon-deployment mode. Here is an example, where we change a message that\nasks to pip install (which is not the issue) to point the user to the\ninclude command that makes an ``imageio`` plugin work.\n\n.. code:: yaml\n\n   - module-name: 'imageio.core.imopen'\n     anti-bloat:\n       - replacements_plain:\n           '`pip install imageio[{config.install_name}]` to install it': '`--include-module={config.module_name}` with Nuitka to include it'\n           'err_type = ImportError': 'err_type = RuntimeError'\n         when: 'not deployment'\n\nAnd much more\n-------------\n\nThe deployment mode is relatively new and has constantly more features\nadded, e.g. something for ``FileNotFoundError`` should be coming soon.\n\nDisabling All\n-------------\n\nAll these helpers can of course be disabled at once with\n``--deployment`` but keep in mind that for debugging, you may want to\nre-enable it. You might want to use Nuitka Project options and an\nenvironment variable to make this conditional.\n\nShould you disable them all?\n\nWe believe, disabling should only happen selectively, but with PyPI\nupgrades, your code changes, all of these issues can sneak back in. The\nspace saving of deployment mode is currently negligible, so attempt to\nnot do it, but review what exists, and if you know that it cannot affect\nyou, or if it does, you will not need it. Some of the future ones, will\nclearly be geared at beginner level usage.\n\nWindows Virus scanners\n======================\n\nBinaries compiled on Windows with default settings of Nuitka and no\nfurther actions taken might be recognized by some AV vendors as malware.\nThis is avoidable, but only in Nuitka commercial there is actual support\nand instructions for how to do it, seeing this as a typical commercial\nonly need. https://nuitka.net/doc/commercial.html\n\nLinux Standalone\n================\n\nFor Linux standalone it is pretty difficult to build a binary that works\non other Linux versions. This is mainly because on Linux, much software\nis built specifically targeted to concrete DLLs. Things like glibc used,\nare then encoded into the binary built, and it will not run with an\nolder glibc, just to give one critical example.\n\nThe solution is to build on the oldest OS that you want to see\nsupported. Picking that and setting it up can be tedious, so can be\nlogin, and keeping it secure, as it's something you put your source code\non.\n\nTo aid that, Nuitka commercial has container based builds, that you can\nuse. This uses dedicated optimized Python builds, targets CentOS 7 and\nsupports even newest Pythons and very old OSes that way using recent C\ncompiler chains all turn key solution. The effort needs to be\ncompensated to support Nuitka development for Linux, there you need to\npurchase it https://nuitka.net/doc/commercial.html but even a sponsor\nlicense will be cheaper than doing it yourself.\n\nProgram crashes system (fork bombs)\n===================================\n\nA fork bomb is a program that starts itself over and over. This can\neasily happen, since ``sys.executable`` for compiled programs is not a\nPython interpreter, and packages that try to do multiprocessing in a\nbetter way, often relaunch themselves through this, and Nuitka needs and\ndoes have handling for these with known packages. However, you may\nencounter a situation where the detection of this fails. See deployment\noption above that is needed to disable this protection.\n\nWhen this fork bomb happens easily all memory, all CPU of the system\nthat is available to the user is being used, and even the most powerful\nbuild system will go down in flames sometimes needing a hard reboot.\n\nFor fork bombs, we can use ``--experimental=debug-self-forking`` and see\nwhat it does, and we have a trick, that prevents fork bombs from having\nany actual success in their bombing. Put this at the start of your\nprogram.\n\n.. code:: python\n\n   import os, sys\n\n   if \"NUITKA_LAUNCH_TOKEN\" not in os.environ:\n      sys.exit(\"Error, need launch token or else fork bomb suspected.\")\n   else:\n      del os.environ[\"NUITKA_LAUNCH_TOKEN\"]\n\nActually Nuitka is trying to get ahold of them without the deployment\noption already, finding \"-c\" and \"-m\" options, but it may not be perfect\nor not work well with a package (anymore).\n\nMemory issues and compiler bugs\n===============================\n\nIn some cases, the C compilers will crash saying they cannot allocate\nmemory or that some input was truncated, or similar error messages,\nclearly from it. These are example error messages, that are a sure sign\nof too low memory, there is no end to them.\n\n.. code::\n\n   # gcc\n   fatal error: error writing to -: Invalid argument\n   Killed signal terminated program\n   # MSVC\n   fatal error C1002: compiler is out of heap space in pass 2\n   fatal error C1001: Internal compiler error\n\nThere are several options you can explore here.\n\nAsk Nuitka to use less memory\n-----------------------------\n\nThere is a dedicated option ``--low-memory`` which influences decisions\nof Nuitka, such that it avoids high usage of memory during compilation\nat the cost of increased compile time.\n\nAvoid 32 bit C compiler/assembler memory limits\n-----------------------------------------------\n\nDo not use a 32 bit compiler, but a 64 bit one. If you are using Python\nwith 32 bits on Windows, you most definitely ought to use MSVC as the C\ncompiler, and not MinGW64. The MSVC is a cross-compiler, and can use\nmore memory than gcc on that platform. If you are not on Windows, that\nis not an option, of course. Also, using the 64 bit Python will work.\n\nUse a minimal virtualenv\n------------------------\n\nWhen you compile from a living installation, that may well have many\noptional dependencies of your software installed. Some software will\nthen have imports on these, and Nuitka will compile them as well. Not\nonly may these be just the troublemakers, they also require more memory,\nso get rid of that. Of course, you do have to check that your program\nhas all the needed dependencies before you attempt to compile, or else\nthe compiled program will equally not run.\n\nUse LTO compilation or not\n--------------------------\n\nWith ``--lto=yes`` or ``--lto=no`` you can switch the C compilation to\nonly produce bytecode, and not assembler code and machine code directly,\nbut make a whole program optimization at the end. This will change the\nmemory usage pretty dramatically, and if your error is coming from the\nassembler, using LTO will most definitely avoid that.\n\nSwitch the C compiler to clang\n------------------------------\n\nPeople have reported that programs that fail to compile with gcc due to\nits bugs or memory usage work fine with clang on Linux. On Windows, this\ncould still be an option, but it needs to be implemented first for the\nautomatic downloaded gcc, that would contain it. Since MSVC is known to\nbe more memory effective anyway, you should go there, and if you want to\nuse Clang, there is support for the one contained in MSVC.\n\nAdd a larger swap file to your embedded Linux\n---------------------------------------------\n\nOn systems with not enough RAM, you need to use swap space. Running out\nof it is possibly a cause, and adding more swap space, or one at all,\nmight solve the issue, but beware that it will make things extremely\nslow when the compilers swap back and forth, so consider the next tip\nfirst or on top of it.\n\nLimit the amount of compilation jobs\n------------------------------------\n\nWith the ``--jobs`` option of Nuitka, it will not start many C compiler\ninstances at once, each competing for the scarce resource of RAM. By\npicking a value of one, only one C compiler instance will be running,\nand on an 8 core system, that reduces the amount of memory by factor 8,\nso that's a natural choice right there.\n\nDynamic ``sys.path``\n====================\n\nIf your script modifies ``sys.path``, e.g. inserts directories with\nsource code relative to it, Nuitka will not be able to see those.\nHowever, if you set the ``PYTHONPATH`` to the resulting value, it will\nbe able to compile it and find the used modules from these paths as\nwell.\n\nManual Python File Loading\n==========================\n\nA very frequent pattern with private code is that it scans plugin\ndirectories of some kind, and e.g. uses ``os.listdir``, then considers\nPython filenames, and then opens a file and does ``exec`` on them. This\napproach works for Python code, but for compiled code, you should use\nthis much cleaner approach, that works for pure Python code and is a lot\nless vulnerable.\n\n.. code:: python\n\n   # Using a package name, to locate the plugins. This is also a sane\n   # way to organize them into a directory.\n   scan_path = scan_package.__path__\n\n   for item in pkgutil.iter_modules(scan_path):\n      importlib.import_module(scan_package.__name__ + \".\" + item.name)\n\n      # You may want to do it recursively, but we don't do this here in\n      # this example. If you'd like to, handle that in this kind of branch.\n      if item.ispkg:\n         ...\n\nMissing data files in standalone\n================================\n\nIf your program fails to find data file, it can cause all kinds of\ndifferent behavior, e.g. a package might complain it is not the right\nversion because a ``VERSION`` file check defaulted to an unknown. The\nabsence of icon files or help texts, may raise strange errors.\n\nOften the error paths for files not being present are even buggy and\nwill reveal programming errors like unbound local variables. Please look\ncarefully at these exceptions, keeping in mind that this can be the\ncause. If your program works without standalone, chances are data files\nmight be the cause.\n\nThe most common error indicating file absence is of course an uncaught\n``FileNotFoundError`` with a filename. You should figure out what\npackage is missing files and then use ``--include-package-data``\n(preferably), or ``--include-data-dir``/``--include-data-files`` to\ninclude them.\n\nMissing DLLs/EXEs in standalone\n===============================\n\nNuitka has plugins that deal with copying DLLs. For NumPy, SciPy,\nTkinter, etc.\n\nThese need special treatment to be able to run on other systems.\nManually copying them is not enough and will give strange errors.\nSometimes newer version of packages, esp. NumPy can be unsupported. In\nthis case, you will have to raise an issue, and use the older one.\n\nIf you want to manually add a DLL or an EXE because it is your project\nonly, you will have to use user Yaml files describing where they can be\nfound. This is described in detail with examples in the `Nuitka Package\nConfiguration <https://nuitka.net/doc/nuitka-package-config.html>`__\npage.\n\nDependency creep in standalone\n==============================\n\nSome packages are a single import, but to Nuitka mean that more than a\nthousand packages (literally) are to be included. The prime example of\nPandas, which does want to plug and use just about everything you can\nimagine. Multiple frameworks for syntax highlighting everything\nimaginable take time.\n\nNuitka will have to learn effective caching to deal with this in the\nfuture. Presently, you will have to deal with huge compilation times for\nthese.\n\nA major weapon in fighting dependency creep should be applied, namely\nthe ``anti-bloat`` plugin, which offers interesting abilities, that can\nbe put to use and block unneeded imports, giving an error for where they\noccur. Use it e.g. like this ``--noinclude-pytest-mode=nofollow\n--noinclude-setuptools-mode=nofollow`` and e.g. also\n``--noinclude-custom-mode=setuptools:error`` to get the compiler to\nerror out for a specific package. Make sure to check its help output. It\ncan take for each module of your choice, e.g. forcing also that e.g.\n``PyQt5`` is considered uninstalled for standalone mode.\n\nIt's also driven by a configuration file, ``anti-bloat.yml`` that you\ncan contribute to, removing typical bloat from packages. Please don't\nhesitate to enhance it and make PRs towards Nuitka with it.\n\nStandalone: Finding files\n=========================\n\nThe standard code that normally works, also works, you should refer to\n``os.path.dirname(__file__)`` or use all the packages like ``pkgutil``,\n``pkg_resources``, ``importlib.resources`` to locate data files near the\nstandalone binary.\n\n.. important::\n\n   What you should **not** do, is use the current directory\n   ``os.getcwd``, or assume that this is the script directory, e.g. with\n   paths like ``data/``.\n\n   If you did that, it was never good code. Links, to a program,\n   launching from another directory, etc. will all fail in bad ways. Do\n   not make assumptions about the directory your program is started\n   from.\n\nIn case you mean to refer to the location of the ``.dist`` folder for\nfiles that are to reside near the binary, there is\n``__compiled__.containing_dir`` that also abstracts all differences with\n``--macos-create-app-bundle`` and the ``.app`` folder a having more\nnested structure.\n\n.. code:: python\n\n   # This will find a file *near* your app or dist folder\n   try:\n      open(os.path.join(__compiled__.containing_dir, \"user-provided-file.txt\"))\n   except NameError:\n      open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n\nOnefile: Finding files\n======================\n\nThere is a difference between ``sys.argv[0]`` and ``__file__`` of the\nmain module for the onefile mode, that is caused by using a bootstrap to\na temporary location. The first one will be the original executable\npath, whereas the second one will be the temporary or permanent path the\nbootstrap executable unpacks to. Data files will be in the later\nlocation, your original environment files will be in the former\nlocation.\n\nGiven 2 files, one which you expect to be near your executable, and one\nwhich you expect to be inside the onefile binary, access them like this.\n\n.. code:: python\n\n   # This will find a file *near* your onefile.exe\n   open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n   # This will find a file *inside* your onefile.exe\n   open(os.path.join(os.path.dirname(__file__), \"user-provided-file.txt\"))\n\n   # This will find a file *near* your onefile binary and work for standalone too\n   try:\n      open(os.path.join(__compiled__.containing_dir, \"user-provided-file.txt\"))\n   except NameError:\n      open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n\n.. note::\n\n   When the program is launched from the executable, the original\n   ``sys.argv[0]`` from the invocation command line will not be\n   preserved, it will be made an absolute path.\n\n   For advanced use cases where one needs access to the original\n   ``sys.argv[0]``, it may be found at ``__compiled__.original_argv0``.\n   The field will read back as ``None`` if the program is not launched\n   from the onefile executable, thus not having gone through the onefile\n   bootstrap stage; the original ``sys.argv[0]`` would be preserved as\n   well in this case.\n\n.. code:: python\n\n   # Suppose the onefile binary is placed at /opt/abc/bin/foo, and it was\n   # symlinked to /usr/local/bin/bar, and invoked as `bar ...`:\n   assert sys.argv[0] == \"/usr/local/bin/bar\"\n   assert __compiled__.original_argv0 == \"bar\"\n\n   # If the onefile tempdir is overridden and the program is invoked\n   # directly from the unpacked location, sys.argv[0] would not be touched.\n   #\n   # Suppose the onefile tempdir is /home/xx/.cache/abc/0.1.2, and the\n   # foo.bin executable inside is symlinked to /usr/local/bin/baz, and\n   # invoked as `baz ...`:\n   assert sys.argv[0] == \"baz\"\n   assert __compiled__.original_argv0 is None\n\nWindows Programs without console give no errors\n===============================================\n\nFor debugging purposes, use the options ``--force-stdout-spec`` and\n``--force-stderr-spec`` with paths as documented for\n``--onefile-tempdir-spec`` above. These can be relative to the program\nor absolute, so you can see the outputs given. Also you can run the\nprogram on a terminal prompt like ``CMD.exe`` to see its outputs.\n\nDeep copying uncompiled functions\n=================================\n\nSometimes people use this kind of code, which for packages on PyPI, we\ndeal with by doing source code patches on the fly. If this is in your\nown code, here is what you can do:\n\n.. code:: python\n\n   def binder(func, name):\n      result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n      result = functools.update_wrapper(result, func)\n      result.__kwdefaults__ = func.__kwdefaults__\n      result.__name__ = name\n      return result\n\nCompiled functions cannot be used to create uncompiled ones from, so the\nabove code will not work. However, there is a dedicated ``clone``\nmethod, that is specific to them, so use this instead.\n\n.. code:: python\n\n   def binder(func, name):\n      try:\n         result = func.clone()\n      except AttributeError:\n         result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n         result = functools.update_wrapper(result, func)\n         result.__kwdefaults__ = func.__kwdefaults__\n\n      result.__name__ = name\n      return result\n\nModules: Extension modules are not executable directly\n======================================================\n\nA package can be compiled with Nuitka, no problem, but when it comes to\nexecuting it, ``python -m compiled_module`` is not going to work and\ngive the error ``No code object available for AssertsTest`` because the\ncompiled module is not source code, and Python will not just load it.\nThe closest would be ``python -c \"import compile_module\"`` and you might\nhave to call the main function yourself.\n\nTo support this, the CPython ``runpy`` and/or ``ExtensionFileLoader``\nwould need improving such that Nuitka could supply its compiled module\nobject for Python to use.\n\n******\n Tips\n******\n\nNuitka Options in the code\n==========================\n\nOne clean way of providing options to Nuitka, that you will always use\nfor your program, is to put them into the main file you compile. There\nis even support for conditional options, and options using pre-defined\nvariables, this is an example:\n\n.. code:: python\n\n   # Compilation mode, support OS-specific options\n   # nuitka-project-if: {OS} in (\"Windows\", \"Linux\", \"Darwin\", \"FreeBSD\"):\n   #    nuitka-project: --mode=app\n   # nuitka-project-else:\n   #    nuitka-project: --mode=standalone\n\n   # The PySide2 plugin covers qt-plugins\n   # nuitka-project: --enable-plugin=pyside2\n   # nuitka-project: --include-qt-plugins=qml\n\nThe comments must be at the start of lines, and indentation inside of\nthem is to be used, to end a conditional block, much like in Python.\nThere are currently no other keywords than the used ones demonstrated\nabove.\n\nYou can put arbitrary Python expressions there, and if you wanted to\ne.g. access a version information of a package, you could simply use\n``__import__(\"module_name\").__version__`` if that would be required to\ne.g. enable or disable certain Nuitka settings. The only thing Nuitka\ndoes that makes this not Python expressions, is expanding ``{variable}``\nfor a pre-defined set of variables:\n\nTable with supported variables:\n\n+------------------+--------------------------------+------------------------------------------+\n| Variable         | What this Expands to           | Example                                  |\n+==================+================================+==========================================+\n| {OS}             | Name of the OS used            | Linux, Windows, Darwin, FreeBSD, OpenBSD |\n+------------------+--------------------------------+------------------------------------------+\n| {Version}        | Version of Nuitka              | e.g. (1, 6, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {Commercial}     | Version of Nuitka Commercial   | e.g. (2, 1, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {Arch}           | Architecture used              | x86_64, arm64, etc.                      |\n+------------------+--------------------------------+------------------------------------------+\n| {MAIN_DIRECTORY} | Directory of the compiled file | some_dir/maybe_relative                  |\n+------------------+--------------------------------+------------------------------------------+\n| {Flavor}         | Variant of Python              | e.g. Debian Python, Anaconda Python      |\n+------------------+--------------------------------+------------------------------------------+\n\nThe use of ``{MAIN_DIRECTORY}`` is recommended when you want to specify\na filename relative to the main script, e.g. for use in data file\noptions or user package configuration yaml files,\n\n.. code:: python\n\n   # nuitka-project: --include-data-files={MAIN_DIRECTORY}/my_icon.png=my_icon.png\n   # nuitka-project: --user-package-configuration-file={MAIN_DIRECTORY}/user.nuitka-package.config.yml\n\nPython command line flags\n=========================\n\nFor passing things like ``-O`` or ``-S`` to Python, to your compiled\nprogram, there is a command line option name ``--python-flag=`` which\nmakes Nuitka emulate these options.\n\nThe most important ones are supported, more can certainly be added.\n\nCaching compilation results\n===========================\n\nThe C compiler, when invoked with the same input files, will take a long\ntime and much CPU to compile over and over. Make sure you are having\n``ccache`` installed and configured when using gcc (even on Windows). It\nwill make repeated compilations much faster, even if things are not yet\nperfect, i.e. changes to the program can cause many C files to change,\nrequiring a new compilation instead of using the cached result.\n\nOn Windows, with gcc, Nuitka supports using ``ccache.exe``, which it\nwill offer to download from an official source and install it\nautomatically. This is the recommended way of using it on Windows, as\nother versions may cause issues e.g. hanging.\n\nNuitka will pick up ``ccache`` if it's found in system ``PATH``, and it\nwill also be possible to provide if by setting ``NUITKA_CCACHE_BINARY``\nto the full path of the binary, this is for use in CI systems where\nenvironments might be non-standard.\n\nFor the MSVC compilers and ClangCL setups, using the ``clcache`` is\nautomatic and included in Nuitka.\n\nOn macOS and Intel, there is an automatic download of a ``ccache``\nbinary from our site, for arm64 arches, it's recommended to use this\nsetup, which installs Homebrew and ccache in there. Nuitka picks that\none up automatically if it on that kind of machine. You need and should\nnot use Homebrew with Nuitka otherwise, it's not the best for standalone\ndeployments, but we can take ``ccache`` from there.\n\n.. code:: bash\n\n   export HOMEBREW_INSTALL_FROM_API=1\n   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n   eval $(/opt/homebrew/bin/brew shellenv)\n   brew install ccache\n\nControl where Caches live\n=========================\n\nThe storage for cache results of all kinds, downloads, cached\ncompilation results from C and Nuitka, is done in a platform dependent\ndirectory as determined by the ``appdirs`` package. However, you can\noverride it with setting the environment variable ``NUITKA_CACHE_DIR``\nto a base directory. This is for use in environments where the home\ndirectory is not persisted, but other paths are.\n\nThere is also per cache control of these caches, here is a table of\nenvironment variables that you can set before starting the compilation,\nto make Nuitka store some of these caches in an entirely separate space.\n\n+------------------+-----------------------------------+----------------------------------------+\n| Cache name       | Environment Variable              | Data Put there                         |\n+==================+===================================+========================================+\n| downloads        | NUITKA_CACHE_DIR_DOWNLOADS        | Downloads made, e.g. dependency walker |\n+------------------+-----------------------------------+----------------------------------------+\n| ccache           | NUITKA_CACHE_DIR_CCACHE           | Object files created by gcc            |\n+------------------+-----------------------------------+----------------------------------------+\n| clcache          | NUITKA_CACHE_DIR_CLCACHE          | Object files created by MSVC           |\n+------------------+-----------------------------------+----------------------------------------+\n| bytecode         | NUITKA_CACHE_DIR_BYTECODE         | Bytecode of demoted modules            |\n+------------------+-----------------------------------+----------------------------------------+\n| dll-dependencies | NUITKA_CACHE_DIR_DLL_DEPENDENCIES | DLL dependencies                       |\n+------------------+-----------------------------------+----------------------------------------+\n\nRunners\n=======\n\nAvoid running the ``nuitka`` binary, doing ``python -m nuitka`` will\nmake a 100% sure you are using what you think you are. Using the wrong\nPython will make it give you ``SyntaxError`` for good code or\n``ImportError`` for installed modules. That is happening, when you run\nNuitka with Python2 on Python3 code and vice versa. By explicitly\ncalling the same Python interpreter binary, you avoid that issue\nentirely.\n\nFastest C Compilers\n===================\n\nThe fastest binaries of ``pystone.exe`` on Windows with 64 bits Python\nproved to be significantly faster with MinGW64, roughly 20% better\nscore. So it is recommended for use over MSVC. Using ``clang-cl.exe`` of\nClang7 was faster than MSVC, but still significantly slower than\nMinGW64, and it will be harder to use, so it is not recommended.\n\nOn Linux, for ``pystone.bin``, the binary produced by ``clang6`` was\nfaster than ``gcc-6.3``, but not by a significant margin. Since gcc is\nmore often already installed, that is recommended to use for now.\n\nDifferences in C compilation times have not yet been examined.\n\nUnexpected Slowdowns\n====================\n\nUsing the Python DLL, like standard CPython does, can lead to unexpected\nslowdowns, e.g. in uncompiled code that works with Unicode strings. This\nis because calling to the DLL rather than residing in the DLL causes\noverhead, and this even happens to the DLL with itself, being slower,\nthan a Python all contained in one binary.\n\nSo if feasible, aim at static linking, which is currently only possible\nwith Anaconda Python on non-Windows, Debian Python2, self compiled\nPythons (do not activate ``--enable-shared``, not needed), and installs\ncreated with ``pyenv``.\n\n.. note::\n\n   On Anaconda, you may need to execute ``conda install\n   libpython-static``\n\nStandalone executables and dependencies\n=======================================\n\nThe process of making standalone executables for Windows traditionally\ninvolves using an external dependency walker to copy necessary libraries\nalong with the compiled executables to the distribution folder.\n\nThere are plenty of ways to find that something is missing. Do not\nmanually copy things into the folder, esp. not DLLs, as that's not going\nto work. Instead, make bug reports to get these handled by Nuitka\nproperly.\n\nWindows errors with resources\n=============================\n\nOn Windows, the Windows Defender tool and the Windows Indexing Service\nboth scan the freshly created binaries, while Nuitka wants to work with\nit, e.g. adding more resources, and then preventing operations randomly\ndue to holding locks. Make sure to exclude your compilation stage from\nthese services.\n\nWindows standalone program redistribution\n=========================================\n\nWhether compiling with MingW or MSVC, the standalone programs have\nexternal dependencies to Visual C Runtime libraries. Nuitka tries to\nship those dependent DLLs by copying them from your system.\n\nBeginning with Microsoft Windows 10, Microsoft ships ``ucrt.dll``\n(Universal C Runtime libraries) which handles calls to\n``api-ms-crt-*.dll``.\n\nWith earlier Windows platforms (and wine/ReactOS), you should consider\ninstalling Visual C runtime libraries before executing a Nuitka\nstandalone compiled program.\n\nDepending on the used C compiler, you'll need the following redist\nversions on the target machines. However, notice that compilation using\nthe 14.3 based version is always recommended, working and best\nsupported, unless you want to target Windows 7.\n\n+------------------+-------------+----------+\n| Visual C version | Redist Year | CPython  |\n+==================+=============+==========+\n| 14.3             | 2022        | 3.11     |\n+------------------+-------------+----------+\n| 14.2             | 2019        | 3.5-3.10 |\n+------------------+-------------+----------+\n| 14.1             | 2017        | 3.5-3.8  |\n+------------------+-------------+----------+\n| 14.0             | 2015        | 3.5-3.8  |\n+------------------+-------------+----------+\n| 10.0             | 2010        | 3.4      |\n+------------------+-------------+----------+\n| 9.0              | 2008        | 2.6, 2.7 |\n+------------------+-------------+----------+\n\nWhen using MingGW64 as downloaded by Nuitka, you'll need the following\nredist versions:\n\n+----------------------------+-------------+---------------------+\n| MingGW64 version           | Redist Year | CPython             |\n+============================+=============+=====================+\n| WinLibs automatic download | 2015        | 2.6, 2.7, 3.4- 3.11 |\n+----------------------------+-------------+---------------------+\n\nOnce the corresponding runtime libraries are installed on the target\nsystem, you may remove all ``api-ms-crt-*.dll`` files from your Nuitka\ncompiled dist folder.\n\nDetecting Nuitka at run time\n============================\n\nNuitka does *not* ``sys.frozen`` unlike other tools because it usually\ntriggers inferior code for no reason. For Nuitka, we have the module\nattribute ``__compiled__`` to test if a specific module was compiled,\nand the function attribute ``__compiled__`` to test if a specific\nfunction was compiled.\n\nProviding extra Options to Nuitka C compilation\n===============================================\n\nNuitka will apply values from the environment variables ``CCFLAGS``,\n``LDFLAGS`` during the compilation on top of what it determines to be\nnecessary. Beware, of course, that this is only useful if you know what\nyou are doing, so should this pose issues, raise them only with perfect\ninformation.\n\nProducing a 32 bit binary on a 64 bit Windows system\n====================================================\n\nNuitka will automatically target the architecture of the Python you are\nusing. If this is 64 bit, it will create a 64 bit binary, if it is 32\nbit, it will create a 32 bit binary. You have the option to select the\nbits when you download the Python. In the output of ``python -m nuitka\n--version`` there is a line for the architecture. It's ``Arch: x86_64``\nfor 64 bits, and just ``Arch: x86`` for 32 bits.\n\nThe C compiler will be picked to match that more or less automatically.\nIf you specify it explicitly, and it mismatches, you will get a warning\nabout the mismatch and informed that your compiler choice was rejected.\n\n********************\n Compilation Report\n********************\n\nWhen you use ``--report=compilation-report.xml`` Nuitka will create an\nXML file with detailed information about the compilation and packaging\nprocess. This is growing in completeness with every release and exposes\nmodule usage attempts, timings of the compilation, plugin influences,\ndata file paths, DLLs, and reasons why things are included or not.\n\nAt this time, the report contains absolute paths in some places, with\nyour private information. The goal is to make this blended out by\ndefault because we also want to become able to compare compilation\nreports from different setups, e.g. with updated packages, and see the\nchanges to Nuitka. The report is, however, recommended for your bug\nreporting.\n\nAlso, another form is available, where the report is free form and\naccording to a Jinja2 template of yours, and one that is included in\nNuitka. The same information as used to produce the XML file is\naccessible. However, right now, this is not yet documented, but we plan\nto add a table with the data. For a reader of the source code that is\nfamiliar with Jinja2, however, it will be easy to do it now already.\n\nIf you have a template, you can use it like this\n``--report-template=your_template.rst.j2:your_report.rst`` and of\ncourse, the usage of restructured text, is only an example. You can use\nMarkdown, your own XML, or whatever you see fit. Nuitka will just expand\nthe template with the compilation report data.\n\nCurrently, the following reports are included in Nuitka. You just use\nthe name as a filename, and Nuitka will pick that one instead.\n\n+---------------+--------------+--------------------------------------------------------+\n| Report Name   | Status       | Purpose                                                |\n+===============+==============+========================================================+\n| LicenseReport | experimental | Distributions used in a compilation with license texts |\n+---------------+--------------+--------------------------------------------------------+\n\n.. note::\n\n   The community can and should contribute more report types and help\n   enhancing the existing ones for good looks.\n\n*************\n Performance\n*************\n\nThis chapter gives an overview, of what to currently expect in terms of\nperformance from Nuitka. It's a work in progress and is updated as we\ngo. The current focus for performance measurements is Python 2.7, but\n3.x is going to follow later.\n\npystone results\n===============\n\nThe results are the top value from this kind of output, running pystone\n1000 times and taking the minimal value. The idea is that the fastest\nrun is most meaningful, and eliminates usage spikes.\n\n.. code:: bash\n\n   echo \"Uncompiled Python2\"\n   for i in {1..100}; do BENCH=1 python2 tests/benchmarks/pystone.py ; done | sort -rn | head -n 1\n   python2 -m nuitka --lto=yes --pgo-c tests/benchmarks/pystone.py\n   echo \"Compiled Python2\"\n   for i in {1..100}; do BENCH=1 ./pystone.bin ; done | sort -n | head -rn 1\n\n   PYTHON3=python3.10\n\n   # Using a 100 gives semi-reliable values already, 1000 for best accuracy.\n   RUNS=1000\n\n   $PYTHON3 -m nuitka --lto=yes --pgo-c --static-libpython=yes tests/benchmarks/pystone3.py\n   echo \"Uncompiled $PYTHON3\"\n   for i in $(seq 1 $RUNS); do BENCH=1 $PYTHON3 tests/benchmarks/pystone3.py ; done | sort -rn | head -n 1\n   echo \"Compiled $PYTHON3\"\n   for i in $(seq 1 $RUNS); do BENCH=1 ./pystone3.bin ; done | sort -rn | head -n 1\n\n+-------------------+-------------------+----------------------+---------------------+\n| Python            | Uncompiled        | Compiled LTO         | Compiled PGO        |\n+===================+===================+======================+=====================+\n| Debian Python 2.7 | 137497.87 (1.000) | 460995.20 (3.353)    | 503681.91 (3.663)   |\n+-------------------+-------------------+----------------------+---------------------+\n| Nuitka Python 2.7 | 144074.78 (1.048) | 479271.51 (3.486)    | 511247.44 (3.718)   |\n+-------------------+-------------------+----------------------+---------------------+\n\nReport issues or bugs\n=====================\n\nShould you encounter any issues, bugs, or ideas, please visit the\n`Nuitka bug tracker <https://github.com/Nuitka/Nuitka/issues>`__ and\nreport them.\n\nBest practices for reporting bugs:\n\n-  Please always include the following information in your report, for\n   the underlying Python version. You can easily copy&paste this into\n   your report. It does contain more information than you think. Do not\n   write something manually. You may always add, of course,\n\n   .. code:: bash\n\n      python -m nuitka --version\n\n-  Try to make your example minimal. That is, try to remove code that\n   does not contribute to the issue as much as possible. Ideally, come\n   up with a small reproducing program that illustrates the issue, using\n   ``print`` with different results when the program runs compiled or\n   native.\n\n-  If the problem occurs spuriously (i.e. not each time), try to set the\n   environment variable ``PYTHONHASHSEED`` to ``0``, disabling hash\n   randomization. If that makes the problem go away, try increasing in\n   steps of 1 to a hash seed value that makes it happen every time,\n   include it in your report.\n\n-  Do not include the created code in your report. Given proper input,\n   it's redundant, and it's not likely that I will look at it without\n   the ability to change the Python or Nuitka source and re-run it.\n\n-  Do not send screenshots of text, that is bad and lazy. Instead,\n   capture text outputs from the console.\n\n***************************\n Unsupported functionality\n***************************\n\nThe ``co_code`` attribute of code objects\n=========================================\n\nThe code objects are empty for native compiled functions. There is no\nbytecode with Nuitka's compiled function objects, so there is no way to\nprovide it.\n\nPDB\n===\n\nThere is no tracing of compiled functions to attach a debugger to.\n",
        "releases": []
    }
}
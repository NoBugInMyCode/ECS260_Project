{
    "https://api.github.com/repos/cloudflare/quiche": {
        "forks": 756,
        "watchers": 9803,
        "stars": 9803,
        "languages": {
            "Rust": 2582978,
            "C": 107023,
            "Shell": 6158,
            "Makefile": 2950,
            "Dockerfile": 2067
        },
        "commits": [
            "2025-01-10T16:56:08Z",
            "2025-01-16T12:10:16Z",
            "2025-01-14T16:41:02Z",
            "2025-01-14T16:04:27Z",
            "2025-01-14T16:02:43Z",
            "2025-01-16T11:28:51Z",
            "2025-01-15T09:11:15Z",
            "2025-01-14T18:02:38Z",
            "2025-01-14T15:24:18Z",
            "2024-12-15T18:07:09Z",
            "2025-01-13T17:44:11Z",
            "2024-07-12T02:05:45Z",
            "2024-07-12T02:03:30Z",
            "2025-01-13T14:59:37Z",
            "2025-01-13T16:58:10Z",
            "2025-01-11T19:08:54Z",
            "2025-01-10T11:44:13Z",
            "2025-01-10T14:53:28Z",
            "2024-05-03T09:38:38Z",
            "2025-01-09T22:51:55Z",
            "2025-01-09T19:46:39Z",
            "2025-01-07T17:28:28Z",
            "2024-12-13T00:52:18Z",
            "2025-01-06T16:15:38Z",
            "2025-01-06T16:56:36Z",
            "2024-12-17T22:28:31Z",
            "2024-12-17T02:20:27Z",
            "2024-12-15T17:19:46Z",
            "2024-12-14T19:42:07Z",
            "2024-12-10T16:45:07Z"
        ],
        "creation_date": "2018-09-29T18:22:05Z",
        "contributors": 30,
        "topics": [
            "http3",
            "network-programming",
            "protocol",
            "quic",
            "rust"
        ],
        "subscribers": 160,
        "readme": "![quiche](quiche.svg)\n\n[![crates.io](https://img.shields.io/crates/v/quiche.svg)](https://crates.io/crates/quiche)\n[![docs.rs](https://docs.rs/quiche/badge.svg)](https://docs.rs/quiche)\n[![license](https://img.shields.io/github/license/cloudflare/quiche.svg)](https://opensource.org/licenses/BSD-2-Clause)\n![build](https://img.shields.io/github/actions/workflow/status/cloudflare/quiche/stable.yml?branch=master)\n\n[quiche] is an implementation of the QUIC transport protocol and HTTP/3 as\nspecified by the [IETF]. It provides a low level API for processing QUIC packets\nand handling connection state. The application is responsible for providing I/O\n(e.g. sockets handling) as well as an event loop with support for timers.\n\nFor more information on how quiche came about and some insights into its design\nyou can read a [post] on Cloudflare's blog that goes into some more detail.\n\n[quiche]: https://docs.quic.tech/quiche/\n[ietf]: https://quicwg.org/\n[post]: https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/\n\nWho uses quiche?\n----------------\n\n### Cloudflare\n\nquiche powers Cloudflare edge network's [HTTP/3 support][cloudflare-http3]. The\n[cloudflare-quic.com](https://cloudflare-quic.com) website can be used for\ntesting and experimentation.\n\n### Android\n\nAndroid's DNS resolver uses quiche to [implement DNS over HTTP/3][android-http3].\n\n### curl\n\nquiche can be [integrated into curl][curl-http3] to provide support for HTTP/3.\n\n[cloudflare-http3]: https://blog.cloudflare.com/http3-the-past-present-and-future/\n[android-http3]: https://security.googleblog.com/2022/07/dns-over-http3-in-android.html\n[curl-http3]: https://github.com/curl/curl/blob/master/docs/HTTP3.md#quiche-version\n\nGetting Started\n---------------\n\n### Command-line apps\n\nBefore diving into the quiche API, here are a few examples on how to use the\nquiche tools provided as part of the [quiche-apps](apps/) crate.\n\nAfter cloning the project according to the command mentioned in the [building](#building) section, the client can be run as follows:\n\n```bash\n $ cargo run --bin quiche-client -- https://cloudflare-quic.com/\n```\n\nwhile the server can be run as follows:\n\n```bash\n $ cargo run --bin quiche-server -- --cert apps/src/bin/cert.crt --key apps/src/bin/cert.key\n```\n\n(note that the certificate provided is self-signed and should not be used in\nproduction)\n\nUse the `--help` command-line flag to get a more detailed description of each\ntool's options.\n\n### Configuring connections\n\nThe first step in establishing a QUIC connection using quiche is creating a\n[`Config`] object:\n\n```rust\nlet mut config = quiche::Config::new(quiche::PROTOCOL_VERSION)?;\nconfig.set_application_protos(&[b\"example-proto\"]);\n\n// Additional configuration specific to application and use case...\n```\n\nThe [`Config`] object controls important aspects of the QUIC connection such\nas QUIC version, ALPN IDs, flow control, congestion control, idle timeout\nand other properties or features.\n\nQUIC is a general-purpose transport protocol and there are several\nconfiguration properties where there is no reasonable default value. For\nexample, the permitted number of concurrent streams of any particular type\nis dependent on the application running over QUIC, and other use-case\nspecific concerns.\n\nquiche defaults several properties to zero, applications most likely need\nto set these to something else to satisfy their needs using the following:\n\n- [`set_initial_max_streams_bidi()`]\n- [`set_initial_max_streams_uni()`]\n- [`set_initial_max_data()`]\n- [`set_initial_max_stream_data_bidi_local()`]\n- [`set_initial_max_stream_data_bidi_remote()`]\n- [`set_initial_max_stream_data_uni()`]\n\n[`Config`] also holds TLS configuration. This can be changed by mutators on\nthe an existing object, or by constructing a TLS context manually and\ncreating a configuration using [`with_boring_ssl_ctx_builder()`].\n\nA configuration object can be shared among multiple connections.\n\n### Connection setup\n\nOn the client-side the [`connect()`] utility function can be used to create\na new connection, while [`accept()`] is for servers:\n\n```rust\n// Client connection.\nlet conn = quiche::connect(Some(&server_name), &scid, local, peer, &mut config)?;\n\n// Server connection.\nlet conn = quiche::accept(&scid, None, local, peer, &mut config)?;\n```\n\n### Handling incoming packets\n\nUsing the connection's [`recv()`] method the application can process\nincoming packets that belong to that connection from the network:\n\n```rust\nlet to = socket.local_addr().unwrap();\n\nloop {\n    let (read, from) = socket.recv_from(&mut buf).unwrap();\n\n    let recv_info = quiche::RecvInfo { from, to };\n\n    let read = match conn.recv(&mut buf[..read], recv_info) {\n        Ok(v) => v,\n\n        Err(e) => {\n            // An error occurred, handle it.\n            break;\n        },\n    };\n}\n```\n\n### Generating outgoing packets\n\nOutgoing packet are generated using the connection's [`send()`] method\ninstead:\n\n```rust\nloop {\n    let (write, send_info) = match conn.send(&mut out) {\n        Ok(v) => v,\n\n        Err(quiche::Error::Done) => {\n            // Done writing.\n            break;\n        },\n\n        Err(e) => {\n            // An error occurred, handle it.\n            break;\n        },\n    };\n\n    socket.send_to(&out[..write], &send_info.to).unwrap();\n}\n```\n\nWhen packets are sent, the application is responsible for maintaining a\ntimer to react to time-based connection events. The timer expiration can be\nobtained using the connection's [`timeout()`] method.\n\n```rust\nlet timeout = conn.timeout();\n```\n\nThe application is responsible for providing a timer implementation, which\ncan be specific to the operating system or networking framework used. When\na timer expires, the connection's [`on_timeout()`] method should be called,\nafter which additional packets might need to be sent on the network:\n\n```rust\n// Timeout expired, handle it.\nconn.on_timeout();\n\n// Send more packets as needed after timeout.\nloop {\n    let (write, send_info) = match conn.send(&mut out) {\n        Ok(v) => v,\n\n        Err(quiche::Error::Done) => {\n            // Done writing.\n            break;\n        },\n\n        Err(e) => {\n            // An error occurred, handle it.\n            break;\n        },\n    };\n\n    socket.send_to(&out[..write], &send_info.to).unwrap();\n}\n```\n\n#### Pacing\n\nIt is recommended that applications [pace] sending of outgoing packets to\navoid creating packet bursts that could cause short-term congestion and\nlosses in the network.\n\nquiche exposes pacing hints for outgoing packets through the [`at`] field\nof the [`SendInfo`] structure that is returned by the [`send()`] method.\nThis field represents the time when a specific packet should be sent into\nthe network.\n\nApplications can use these hints by artificially delaying the sending of\npackets through platform-specific mechanisms (such as the [`SO_TXTIME`]\nsocket option on Linux), or custom methods (for example by using user-space\ntimers).\n\n[pace]: https://datatracker.ietf.org/doc/html/rfc9002#section-7.7\n[`SO_TXTIME`]: https://man7.org/linux/man-pages/man8/tc-etf.8.html\n\n### Sending and receiving stream data\n\nAfter some back and forth, the connection will complete its handshake and\nwill be ready for sending or receiving application data.\n\nData can be sent on a stream by using the [`stream_send()`] method:\n\n```rust\nif conn.is_established() {\n    // Handshake completed, send some data on stream 0.\n    conn.stream_send(0, b\"hello\", true)?;\n}\n```\n\nThe application can check whether there are any readable streams by using\nthe connection's [`readable()`] method, which returns an iterator over all\nthe streams that have outstanding data to read.\n\nThe [`stream_recv()`] method can then be used to retrieve the application\ndata from the readable stream:\n\n```rust\nif conn.is_established() {\n    // Iterate over readable streams.\n    for stream_id in conn.readable() {\n        // Stream is readable, read until there's no more data.\n        while let Ok((read, fin)) = conn.stream_recv(stream_id, &mut buf) {\n            println!(\"Got {} bytes on stream {}\", read, stream_id);\n        }\n    }\n}\n```\n\n### HTTP/3\n\nThe quiche [HTTP/3 module] provides a high level API for sending and\nreceiving HTTP requests and responses on top of the QUIC transport protocol.\n\n[`Config`]: https://docs.quic.tech/quiche/struct.Config.html\n[`set_initial_max_streams_bidi()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_bidi\n[`set_initial_max_streams_uni()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_uni\n[`set_initial_max_data()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_data\n[`set_initial_max_stream_data_bidi_local()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_local\n[`set_initial_max_stream_data_bidi_remote()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_remote\n[`set_initial_max_stream_data_uni()`]: https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_uni\n[`with_boring_ssl_ctx_builder()`]: https://docs.quic.tech/quiche/struct.Config.html#method.with_boring_ssl_ctx_builder\n[`connect()`]: https://docs.quic.tech/quiche/fn.connect.html\n[`accept()`]: https://docs.quic.tech/quiche/fn.accept.html\n[`recv()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.recv\n[`send()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.send\n[`timeout()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.timeout\n[`on_timeout()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.on_timeout\n[`stream_send()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.stream_send\n[`readable()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.readable\n[`stream_recv()`]: https://docs.quic.tech/quiche/struct.Connection.html#method.stream_recv\n[HTTP/3 module]: https://docs.quic.tech/quiche/h3/index.html\n\nHave a look at the [quiche/examples/] directory for more complete examples on\nhow to use the quiche API, including examples on how to use quiche in C/C++\napplications (see below for more information).\n\n[examples/]: quiche/examples/\n\nCalling quiche from C/C++\n-------------------------\n\nquiche exposes a [thin C API] on top of the Rust API that can be used to more\neasily integrate quiche into C/C++ applications (as well as in other languages\nthat allow calling C APIs via some form of FFI). The C API follows the same\ndesign of the Rust one, modulo the constraints imposed by the C language itself.\n\nWhen running ``cargo build``, a static library called ``libquiche.a`` will be\nbuilt automatically alongside the Rust one. This is fully stand-alone and can\nbe linked directly into C/C++ applications.\n\nNote that in order to enable the FFI API, the ``ffi`` feature must be enabled (it\nis disabled by default), by passing ``--features ffi`` to ``cargo``.\n\n[thin C API]: https://github.com/cloudflare/quiche/blob/master/quiche/include/quiche.h\n\nBuilding\n--------\n\nquiche requires Rust 1.70 or later to build. The latest stable Rust release can\nbe installed using [rustup](https://rustup.rs/).\n\nOnce the Rust build environment is setup, the quiche source code can be fetched\nusing git:\n\n```bash\n $ git clone --recursive https://github.com/cloudflare/quiche\n```\n\nand then built using cargo:\n\n```bash\n $ cargo build --examples\n```\n\ncargo can also be used to run the testsuite:\n\n```bash\n $ cargo test\n```\n\nNote that [BoringSSL], which is used to implement QUIC's cryptographic handshake\nbased on TLS, needs to be built and linked to quiche. This is done automatically\nwhen building quiche using cargo, but requires the `cmake` command to be\navailable during the build process. On Windows you also need\n[NASM](https://www.nasm.us/). The [official BoringSSL\ndocumentation](https://github.com/google/boringssl/blob/master/BUILDING.md) has\nmore details.\n\nIn alternative you can use your own custom build of BoringSSL by configuring\nthe BoringSSL directory with the ``QUICHE_BSSL_PATH`` environment variable:\n\n```bash\n $ QUICHE_BSSL_PATH=\"/path/to/boringssl\" cargo build --examples\n```\n\nAlternatively you can use [OpenSSL/quictls]. To enable quiche to use this vendor\nthe ``openssl`` feature can be added to the ``--feature`` list. Be aware that\n``0-RTT`` is not supported if this vendor is used.\n\n[BoringSSL]: https://boringssl.googlesource.com/boringssl/\n\n[OpenSSL/quictls]: https://github.com/quictls/openssl\n\n### Building for Android\n\nBuilding quiche for Android (NDK version 19 or higher, 21 recommended), can be\ndone using [cargo-ndk] (v2.0 or later).\n\nFirst the [Android NDK] needs to be installed, either using Android Studio or\ndirectly, and the `ANDROID_NDK_HOME` environment variable needs to be set to the\nNDK installation path, e.g.:\n\n```bash\n $ export ANDROID_NDK_HOME=/usr/local/share/android-ndk\n```\n\nThen the Rust toolchain for the Android architectures needed can be installed as\nfollows:\n\n```bash\n $ rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android\n```\n\nNote that the minimum API level is 21 for all target architectures.\n\n[cargo-ndk] (v2.0 or later) also needs to be installed:\n\n```bash\n $ cargo install cargo-ndk\n```\n\nFinally the quiche library can be built using the following procedure. Note that\nthe `-t <architecture>` and `-p <NDK version>` options are mandatory.\n\n```bash\n $ cargo ndk -t arm64-v8a -p 21 -- build --features ffi\n```\n\nSee [build_android_ndk19.sh] for more information.\n\n[Android NDK]: https://developer.android.com/ndk\n[cargo-ndk]: https://docs.rs/crate/cargo-ndk\n[build_android_ndk19.sh]: https://github.com/cloudflare/quiche/blob/master/tools/android/build_android_ndk19.sh\n\n### Building for iOS\n\nTo build quiche for iOS, you need the following:\n\n- Install Xcode command-line tools. You can install them with Xcode or with the\n  following command:\n\n```bash\n $ xcode-select --install\n```\n\n- Install the Rust toolchain for iOS architectures:\n\n```bash\n $ rustup target add aarch64-apple-ios x86_64-apple-ios\n```\n\n- Install `cargo-lipo`:\n\n```bash\n $ cargo install cargo-lipo\n```\n\nTo build libquiche, run the following command:\n\n```bash\n $ cargo lipo --features ffi\n```\n\nor\n\n```bash\n $ cargo lipo --features ffi --release\n```\n\niOS build is tested in Xcode 10.1 and Xcode 11.2.\n\n### Building Docker images\n\nIn order to build the Docker images, simply run the following command:\n\n```bash\n $ make docker-build\n```\n\nYou can find the quiche Docker images on the following Docker Hub repositories:\n\n- [cloudflare/quiche](https://hub.docker.com/repository/docker/cloudflare/quiche)\n- [cloudflare/quiche-qns](https://hub.docker.com/repository/docker/cloudflare/quiche-qns)\n\nThe `latest` tag will be updated whenever quiche master branch updates.\n\n**cloudflare/quiche**\n\nProvides a server and client installed in /usr/local/bin.\n\n**cloudflare/quiche-qns**\n\nProvides the script to test quiche within the [quic-interop-runner](https://github.com/marten-seemann/quic-interop-runner).\n\nCopyright\n---------\n\nCopyright (C) 2018-2019, Cloudflare, Inc.\n\nSee [COPYING] for the license.\n\n[COPYING]: https://github.com/cloudflare/quiche/tree/master/COPYING\n",
        "releases": [
            {
                "name": "\ud83d\udd27 0.22.0",
                "date": "2024-06-26T17:21:20Z"
            },
            {
                "name": "\ud83d\udef0\ufe0f 0.21.0",
                "date": "2024-04-15T14:08:40Z"
            },
            {
                "name": "\ud83d\udd12 0.20.1",
                "date": "2024-03-12T18:02:54Z"
            },
            {
                "name": "\ud83e\udda6 0.19.2",
                "date": "2024-03-12T18:02:34Z"
            },
            {
                "name": "\ud83d\udd10 0.20.0",
                "date": "2023-12-12T13:39:42Z"
            },
            {
                "name": "\ud83d\udee1\ufe0f 0.19.1",
                "date": "2023-12-12T13:29:11Z"
            },
            {
                "name": "\ud83d\udee9\ufe0f 0.19.0",
                "date": "2023-11-10T13:00:28Z"
            },
            {
                "name": "\ud83d\udd00 0.18.0",
                "date": "2023-08-22T14:49:08Z"
            },
            {
                "name": "\ud83c\udfc3\u200d\u2640\ufe0f 0.17.2",
                "date": "2023-05-10T10:36:00Z"
            },
            {
                "name": "\ud83d\udddd\ufe0f 0.17.1",
                "date": "2023-03-30T08:51:51Z"
            },
            {
                "name": "\ud83d\ude91 0.16.0",
                "date": "2022-10-13T10:39:52Z"
            },
            {
                "name": "\u23f1\ufe0f 0.15.0",
                "date": "2022-10-07T08:28:50Z"
            },
            {
                "name": "\ud83d\udccc 0.14.0",
                "date": "2022-05-23T11:05:04Z"
            },
            {
                "name": "\ud83d\udcef 0.13.0",
                "date": "2022-05-16T09:42:50Z"
            },
            {
                "name": "\ud83d\udd28 0.12.0",
                "date": "2022-02-04T10:22:59Z"
            },
            {
                "name": "\ud83d\udd27 0.11.0",
                "date": "2022-01-27T17:21:27Z"
            },
            {
                "name": "\ud83d\udea4 0.10.0",
                "date": "2021-09-23T14:59:07Z"
            },
            {
                "name": "\u2728 0.9.0",
                "date": "2021-06-08T11:52:26Z"
            },
            {
                "name": "\ud83e\udd15 0.8.1",
                "date": "2021-04-15T12:42:54Z"
            },
            {
                "name": "\ud83d\udd25 0.8.0",
                "date": "2021-04-13T12:44:09Z"
            },
            {
                "name": "\u2603\ufe0f 0.7.0",
                "date": "2021-02-01T12:54:57Z"
            },
            {
                "name": "\ud83c\udf83 0.6.0",
                "date": "2020-10-26T00:40:02Z"
            },
            {
                "name": "\ud83e\ude79 0.5.1",
                "date": "2020-07-17T09:25:22Z"
            },
            {
                "name": "\ud83c\udf34 0.5.0",
                "date": "2020-07-14T12:55:59Z"
            },
            {
                "name": "\ud83d\ude86 0.4.0",
                "date": "2020-05-15T13:55:26Z"
            },
            {
                "name": "\ud83d\udea2 0.3.0",
                "date": "2020-03-13T12:01:00Z"
            },
            {
                "name": "\ud83d\ude80 0.2.0",
                "date": "2020-01-08T15:39:27Z"
            },
            {
                "name": "\ud83e\udd67 0.1.0",
                "date": "2019-10-01T11:56:50Z"
            }
        ]
    }
}
{
    "https://api.github.com/repos/cloudflare/cfssl": {
        "forks": 1119,
        "watchers": 8865,
        "stars": 8865,
        "languages": {
            "Go": 1786571,
            "Assembly": 72900,
            "JavaScript": 22995,
            "Makefile": 2865,
            "Shell": 781,
            "HTML": 639,
            "Dockerfile": 585
        },
        "commits": [
            "2024-10-15T19:24:44Z",
            "2024-09-25T04:02:50Z",
            "2024-09-22T17:00:00Z",
            "2024-07-11T16:28:33Z",
            "2024-03-19T18:43:35Z",
            "2024-03-18T03:38:58Z",
            "2024-03-11T17:35:09Z",
            "2024-03-11T17:35:00Z",
            "2024-03-11T03:46:25Z",
            "2024-03-05T16:55:36Z",
            "2024-03-05T16:54:51Z",
            "2024-03-05T16:54:40Z",
            "2024-03-04T03:02:14Z",
            "2024-02-22T15:37:36Z",
            "2024-02-21T21:46:13Z",
            "2024-02-21T21:23:47Z",
            "2024-02-21T21:23:41Z",
            "2024-02-12T03:50:50Z",
            "2024-02-12T03:05:34Z",
            "2024-02-11T18:27:56Z",
            "2024-02-08T16:13:47Z",
            "2024-02-08T16:13:11Z",
            "2024-02-05T03:41:17Z",
            "2024-02-05T03:03:30Z",
            "2024-01-31T23:43:36Z",
            "2024-01-31T23:43:23Z",
            "2024-01-29T03:19:17Z",
            "2024-01-15T03:23:53Z",
            "2024-01-02T18:25:33Z",
            "2024-01-01T03:58:16Z"
        ],
        "creation_date": "2014-07-07T23:49:12Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 217,
        "readme": "# CFSSL\n\n[![Build Status](https://travis-ci.org/cloudflare/cfssl.svg?branch=master)](https://travis-ci.org/cloudflare/cfssl)\n[![Coverage Status](http://codecov.io/github/cloudflare/cfssl/coverage.svg?branch=master)](http://codecov.io/github/cloudflare/cfssl?branch=master)\n[![GoDoc](https://godoc.org/github.com/cloudflare/cfssl?status.svg)](https://godoc.org/github.com/cloudflare/cfssl)\n\n## CloudFlare's PKI/TLS toolkit\n\nCFSSL is CloudFlare's PKI/TLS swiss army knife. It is both a command line\ntool and an HTTP API server for signing, verifying, and bundling TLS\ncertificates. It requires Go 1.16+ to build.\n\nNote that certain linux distributions have certain algorithms removed\n(RHEL-based distributions in particular), so the golang from the\nofficial repositories will not work. Users of these distributions should\n[install go manually](//golang.org/dl) to install CFSSL.\n\nCFSSL consists of:\n\n* a set of packages useful for building custom TLS PKI tools\n* the `cfssl` program, which is the canonical command line utility\n  using the CFSSL packages.\n* the `multirootca` program, which is a certificate authority server\n  that can use multiple signing keys.\n* the `mkbundle` program is used to build certificate pool bundles.\n* the `cfssljson` program, which takes the JSON output from the\n  `cfssl` and `multirootca` programs and writes certificates, keys,\n  CSRs, and bundles to disk.\n\n### Building\n\nBuilding cfssl requires a\n[working Go 1.16+ installation](http://golang.org/doc/install).\n\n```\n$ git clone git@github.com:cloudflare/cfssl.git\n$ cd cfssl\n$ make\n$ make install\n```\n\nThe resulting binaries will be in the bin folder:\n```\n$ tree bin\nbin\n\u251c\u2500\u2500 cfssl\n\u251c\u2500\u2500 cfssl-bundle\n\u251c\u2500\u2500 cfssl-certinfo\n\u251c\u2500\u2500 cfssl-newkey\n\u251c\u2500\u2500 cfssl-scan\n\u251c\u2500\u2500 cfssljson\n\u251c\u2500\u2500 mkbundle\n\u2514\u2500\u2500 multirootca\n\n0 directories, 8 files\n```\n\n#### Cross Compilation\n\nYou can set the `GOOS` and `GOARCH` environment variables to have Go cross compile for alternative platforms; however, cfssl requires cgo, and cgo requires a working compiler toolchain for the target platform.\n\n### Installation\n\nInstallation requires a [working Go 1.16+ installation](http://golang.org/doc/install).\nAlternatively, [prebuilt binaries are available](https://github.com/cloudflare/cfssl/releases)\n\n```\n$ go get github.com/cloudflare/cfssl/cmd/cfssl\n```\n\nwill download, build, and install the CFSSL tool.\n\nTo install any of the other utility programs that are\nin this repo (for instance `cfssljson` in this case):\n\n```\n$ go get github.com/cloudflare/cfssl/cmd/cfssljson\n```\n\nThis will download, build, and install the CFSSLJSON tool.\n\nAnd to simply install __all__ of the programs in this repo:\n\n```\n$ go get github.com/cloudflare/cfssl/cmd/...\n```\n\nif you are above go 1.18:\n\n```\n$ go install github.com/cloudflare/cfssl/cmd/...@latest\n```\n\nThis will download, build, and install all of the utility programs\n(including `cfssl`, `cfssljson`, and `mkbundle` among others).\n\n### Using the Command Line Tool\n\nThe `cfssl` command line tool takes a command to specify what\noperation it should carry out:\n\n       sign             signs a certificate\n       bundle           build a certificate bundle\n       genkey           generate a private key and a certificate request\n       gencert          generate a private key and a certificate\n       serve            start the API server\n       version          prints out the current version\n       selfsign         generates a self-signed certificate\n       print-defaults   print default configurations\n\nUse `cfssl [command] -help` to find out more about a command.\nThe `version` command takes no arguments.\n\n#### Signing\n\n```\ncfssl sign [-ca cert] [-ca-key key] [-hostname comma,separated,hostnames] csr [subject]\n```\n\nThe `csr` is the client's certificate request. The `-ca` and `-ca-key`\nflags are the CA's certificate and private key, respectively. By\ndefault, they are `ca.pem` and `ca_key.pem`. The `-hostname` is\na comma separated hostname list that overrides the DNS names and\nIP address in the certificate SAN extension.\nFor example, assuming the CA's private key is in\n`/etc/ssl/private/cfssl_key.pem` and the CA's certificate is in\n`/etc/ssl/certs/cfssl.pem`, to sign the `cloudflare.pem` certificate\nfor cloudflare.com:\n\n```\ncfssl sign -ca     /etc/ssl/certs/cfssl.pem       \\\n           -ca-key /etc/ssl/private/cfssl_key.pem \\\n           -hostname cloudflare.com               \\\n           ./cloudflare.pem\n```\n\nIt is also possible to specify CSR with the `-csr` flag. By doing so,\nflag values take precedence and will overwrite the argument.\n\nThe subject is an optional file that contains subject information that\nshould be used in place of the information from the CSR. It should be\na JSON file as follows:\n\n```json\n{\n    \"CN\": \"example.com\",\n    \"names\": [\n        {\n            \"C\":  \"US\",\n            \"L\":  \"San Francisco\",\n            \"O\":  \"Internet Widgets, Inc.\",\n            \"OU\": \"WWW\",\n            \"ST\": \"California\"\n        }\n    ]\n}\n```\n\n**N.B.** As of Go 1.7, self-signed certificates will not include\n[the AKI](https://go.googlesource.com/go/+/b623b71509b2d24df915d5bc68602e1c6edf38ca).\n\n#### Bundling\n\n```\ncfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \\\n             [-metadata metadata_file] [-flavor bundle_flavor] \\\n             -cert certificate_file [-key key_file]\n```\n\nThe bundles are used for the root and intermediate certificate\npools. In addition, platform metadata is specified through `-metadata`.\nThe bundle files, metadata file (and auxiliary files) can be\nfound at:\n\n        https://github.com/cloudflare/cfssl_trust\n\nSpecify PEM-encoded client certificate and key through `-cert` and\n`-key` respectively. If key is specified, the bundle will be built\nand verified with the key. Otherwise the bundle will be built\nwithout a private key. Instead of file path, use `-` for reading\ncertificate PEM from stdin. It is also acceptable that the certificate\nfile should contain a (partial) certificate bundle.\n\nSpecify bundling flavor through `-flavor`. There are three flavors:\n`optimal` to generate a bundle of shortest chain and most advanced\ncryptographic algorithms, `ubiquitous` to generate a bundle of most\nwidely acceptance across different browsers and OS platforms, and\n`force` to find an acceptable bundle which is identical to the\ncontent of the input certificate file.\n\nAlternatively, the client certificate can be pulled directly from\na domain. It is also possible to connect to the remote address\nthrough `-ip`.\n\n```\ncfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \\\n             [-metadata metadata_file] [-flavor bundle_flavor] \\\n             -domain domain_name [-ip ip_address]\n```\n\nThe bundle output form should follow the example:\n\n```json\n{\n    \"bundle\": \"CERT_BUNDLE_IN_PEM\",\n    \"crt\": \"LEAF_CERT_IN_PEM\",\n    \"crl_support\": true,\n    \"expires\": \"2015-12-31T23:59:59Z\",\n    \"hostnames\": [\"example.com\"],\n    \"issuer\": \"ISSUER CERT SUBJECT\",\n    \"key\": \"KEY_IN_PEM\",\n    \"key_size\": 2048,\n    \"key_type\": \"2048-bit RSA\",\n    \"ocsp\": [\"http://ocsp.example-ca.com\"],\n    \"ocsp_support\": true,\n    \"root\": \"ROOT_CA_CERT_IN_PEM\",\n    \"signature\": \"SHA1WithRSA\",\n    \"subject\": \"LEAF CERT SUBJECT\",\n    \"status\": {\n        \"rebundled\": false,\n        \"expiring_SKIs\": [],\n        \"untrusted_root_stores\": [],\n        \"messages\": [],\n        \"code\": 0\n    }\n}\n```\n\n\n#### Generating certificate signing request and private key\n\n```\ncfssl genkey csr.json\n```\n\nTo generate a private key and corresponding certificate request, specify\nthe key request as a JSON file. This file should follow the form:\n\n```json\n{\n    \"hosts\": [\n        \"example.com\",\n        \"www.example.com\",\n        \"https://www.example.com\",\n        \"jdoe@example.com\",\n        \"127.0.0.1\"\n    ],\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n        {\n            \"C\":  \"US\",\n            \"L\":  \"San Francisco\",\n            \"O\":  \"Internet Widgets, Inc.\",\n            \"OU\": \"WWW\",\n            \"ST\": \"California\"\n        }\n    ]\n}\n```\n\n#### Generating self-signed root CA certificate and private key\n\n```\ncfssl genkey -initca csr.json | cfssljson -bare ca\n```\n\nTo generate a self-signed root CA certificate, specify the key request as\na JSON file in the same format as in 'genkey'. Three PEM-encoded entities\nwill appear in the output: the private key, the csr, and the self-signed\ncertificate.\n\n#### Generating a remote-issued certificate and private key.\n\n```\ncfssl gencert -remote=remote_server [-hostname=comma,separated,hostnames] csr.json\n```\n\nThis calls `genkey` but has a remote CFSSL server sign and issue\nthe certificate. You may use `-hostname` to override certificate SANs.\n\n#### Generating a local-issued certificate and private key.\n\n```\ncfssl gencert -ca cert -ca-key key [-hostname=comma,separated,hostnames] csr.json\n```\n\nThis generates and issues a certificate and private key from a local CA\nvia a JSON request. You may use `-hostname` to override certificate SANs.\n\n\n#### Updating an OCSP responses file with a newly issued certificate\n\n```\ncfssl ocspsign -ca cert -responder key -responder-key key -cert cert \\\n | cfssljson -bare -stdout >> responses\n```\n\nThis will generate an OCSP response for the `cert` and add it to the\n`responses` file. You can then pass `responses` to `ocspserve` to start an\nOCSP server.\n\n### Starting the API Server\n\nCFSSL comes with an HTTP-based API server; the endpoints are\ndocumented in [`doc/api/intro.txt`](doc/api/intro.txt). The server is started with the `serve`\ncommand:\n\n```\ncfssl serve [-address address] [-ca cert] [-ca-bundle bundle] \\\n            [-ca-key key] [-int-bundle bundle] [-int-dir dir] [-port port] \\\n            [-metadata file] [-remote remote_host] [-config config] \\\n            [-responder cert] [-responder-key key] [-db-config db-config]\n```\n\nAddress and port default to \"127.0.0.1:8888\". The `-ca` and `-ca-key`\narguments should be the PEM-encoded certificate and private key to use\nfor signing; by default, they are `ca.pem` and `ca_key.pem`. The\n`-ca-bundle` and `-int-bundle` should be the certificate bundles used\nfor the root and intermediate certificate pools, respectively. These\ndefault to `ca-bundle.crt` and `int-bundle.crt` respectively. If the\n`-remote` option is specified, all signature operations will be forwarded\nto the remote CFSSL.\n\n`-int-dir` specifies an intermediates directory. `-metadata` is a file for\nroot certificate presence. The content of the file is a json dictionary \n(k,v) such that each key k is an SHA-1 digest of a root certificate while value v \nis a list of key store filenames. `-config` specifies a path to a configuration\nfile. `-responder` and  `-responder-key` are the certificate and the\nprivate key for the OCSP responder, respectively.\n\nThe amount of logging can be controlled with the `-loglevel` option. This\ncomes *after* the serve command:\n\n```\ncfssl serve -loglevel 2\n```\n\nThe levels are:\n\n* 0 - DEBUG\n* 1 - INFO (this is the default level)\n* 2 - WARNING\n* 3 - ERROR\n* 4 - CRITICAL\n\n### The multirootca\n\nThe `cfssl` program can act as an online certificate authority, but it\nonly uses a single key. If multiple signing keys are needed, the\n`multirootca` program can be used. It only provides the `sign`,\n`authsign` and `info` endpoints. The documentation contains instructions\nfor configuring and running the CA.\n\n### The mkbundle Utility\n\n`mkbundle` is used to build the root and intermediate bundles used in\nverifying certificates. It can be installed with\n\n```\ngo get github.com/cloudflare/cfssl/cmd/mkbundle\n```\n\nIt takes a collection of certificates, checks for CRL revocation (OCSP\nsupport is planned for the next release) and expired certificates, and\nbundles them into one file. It takes directories of certificates and\ncertificate files (which may contain multiple certificates). For example,\nif the directory `intermediates` contains a number of intermediate\ncertificates:\n\n```\nmkbundle -f int-bundle.crt intermediates\n```\n\nwill check those certificates and combine valid certificates into a single\n`int-bundle.crt` file.\n\nThe `-f` flag specifies an output name; `-loglevel` specifies the verbosity\nof the logging (using the same loglevels as above), and `-nw` controls the\nnumber of revocation-checking workers.\n\n### The cfssljson Utility\n\nMost of the output from `cfssl` is in JSON. The `cfssljson` utility can take\nthis output and split it out into separate `key`, `certificate`, `CSR`, and\n`bundle` files as appropriate. The tool takes a single flag, `-f`, that\nspecifies the input file, and an argument that specifies the base name for\nthe files produced. If the input filename is `-` (which is the default),\ncfssljson reads from standard input. It maps keys in the JSON file to\nfilenames in the following way:\n\n* if __cert__ or __certificate__ is specified,         __basename.pem__          will be produced.\n* if __key__  or __private_key__ is specified,         __basename-key.pem__      will be produced.\n* if __csr__  or __certificate_request__ is specified, __basename.csr__          will be produced.\n* if __bundle__       is specified,                    __basename-bundle.pem__   will be produced.\n* if __ocspResponse__ is specified,                    __basename-response.der__ will be produced.\n\nInstead of saving to a file, you can pass `-stdout` to output the encoded\ncontents to standard output.\n\n### Static Builds\n\nBy default, the web assets are accessed from disk, based on their\nrelative locations. If you wish to distribute a single,\nstatically-linked, `cfssl` binary, you\u2019ll want to embed these resources\nbefore building. This can by done with the\n[go.rice](https://github.com/GeertJohan/go.rice) tool.\n\n```\npushd cli/serve && rice embed-go && popd\n```\n\nThen building with `go build` will use the embedded resources.\n\n### Additional Documentation\n\nAdditional documentation can be found in the \"doc\" directory:\n\n* [doc/api/intro.txt](doc/api/intro.txt): documents the API endpoints\n",
        "releases": [
            {
                "name": "v1.6.5",
                "date": "2024-03-05T17:40:06Z"
            },
            {
                "name": "v1.6.4",
                "date": "2023-04-10T19:07:12Z"
            },
            {
                "name": "v1.6.3",
                "date": "2022-10-04T17:41:22Z"
            },
            {
                "name": "v1.6.2",
                "date": "2022-08-26T21:31:23Z"
            },
            {
                "name": "v1.6.1",
                "date": "2021-09-03T15:28:11Z"
            },
            {
                "name": "v1.6.0",
                "date": "2021-06-04T17:10:34Z"
            },
            {
                "name": "v1.5.0",
                "date": "2020-10-23T00:15:45Z"
            },
            {
                "name": "v1.4.1",
                "date": "2019-11-13T10:22:43Z"
            },
            {
                "name": "v1.4.0",
                "date": "2019-10-31T16:53:55Z"
            },
            {
                "name": "v1.4.0-rc1",
                "date": "2019-10-31T02:52:25Z"
            },
            {
                "name": "1.3.4",
                "date": "2019-07-16T00:53:06Z"
            },
            {
                "name": "1.3.3",
                "date": "2019-04-09T03:41:28Z"
            },
            {
                "name": "1.3.2",
                "date": "2018-05-10T05:52:27Z"
            },
            {
                "name": "1.3.1",
                "date": "2018-02-24T00:45:34Z"
            },
            {
                "name": "",
                "date": "2021-04-16T19:18:27Z"
            },
            {
                "name": "",
                "date": "2021-04-16T19:20:30Z"
            }
        ]
    }
}
{
    "https://api.github.com/repos/protobufjs/protobuf.js": {
        "forks": 1421,
        "watchers": 10034,
        "stars": 10034,
        "languages": {
            "JavaScript": 1745631,
            "TypeScript": 3929
        },
        "commits": [
            "2024-12-30T06:30:38Z",
            "2024-10-16T17:51:05Z",
            "2024-10-16T00:30:32Z",
            "2024-10-15T19:39:54Z",
            "2024-10-14T21:41:58Z",
            "2024-10-09T23:21:01Z",
            "2024-10-09T23:11:31Z",
            "2024-10-08T20:10:50Z",
            "2024-10-08T19:44:16Z",
            "2024-10-04T23:47:58Z",
            "2024-10-04T22:11:15Z",
            "2024-10-04T22:09:12Z",
            "2024-10-04T22:08:15Z",
            "2024-10-02T17:23:26Z",
            "2024-10-02T06:31:34Z",
            "2024-10-02T06:29:09Z",
            "2024-09-26T19:06:17Z",
            "2024-09-26T17:42:43Z",
            "2024-09-24T21:28:00Z",
            "2024-09-24T21:23:48Z",
            "2024-09-24T20:24:20Z",
            "2024-09-24T20:22:46Z",
            "2024-09-24T18:46:46Z",
            "2024-09-20T17:39:05Z",
            "2024-09-19T18:30:52Z",
            "2024-09-19T18:28:36Z",
            "2024-09-19T18:28:20Z",
            "2024-09-19T18:25:43Z",
            "2024-09-19T18:21:21Z",
            "2024-09-19T04:16:24Z"
        ],
        "creation_date": "2013-03-01T18:46:54Z",
        "contributors": 30,
        "topics": [
            "javascript",
            "protobuf",
            "protocol-buffers",
            "serialization",
            "typescript"
        ],
        "subscribers": 170,
        "readme": "<h1><p align=\"center\"><img alt=\"protobuf.js\" src=\"https://github.com/protobufjs/protobuf.js/raw/master/pbjs.svg\" height=\"100\" /><br/>protobuf.js</p></h1>\n<p align=\"center\">\n  <a href=\"https://github.com/protobufjs/protobuf.js/actions/workflows/test.yml\"><img src=\"https://img.shields.io/github/actions/workflow/status/protobufjs/protobuf.js/test.yml?branch=master&label=build&logo=github\" alt=\"\"></a>\n  <a href=\"https://github.com/protobufjs/protobuf.js/actions/workflows/release.yaml\"><img src=\"https://img.shields.io/github/actions/workflow/status/protobufjs/protobuf.js/release.yaml?branch=master&label=release&logo=github\" alt=\"\"></a>\n  <a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/v/protobufjs.svg?logo=npm\" alt=\"\"></a>\n  <a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/dm/protobufjs.svg?label=downloads&logo=npm\" alt=\"\"></a>\n  <a href=\"https://www.jsdelivr.com/package/npm/protobufjs\"><img src=\"https://img.shields.io/jsdelivr/npm/hm/protobufjs?label=requests&logo=jsdelivr\" alt=\"\"></a>\n</p>\n\n**Protocol Buffers** are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more, originally designed at Google ([see](https://protobuf.dev/)).\n\n**protobuf.js** is a pure JavaScript implementation with [TypeScript](https://www.typescriptlang.org) support for [Node.js](https://nodejs.org) and the browser. It's easy to use, does not sacrifice on performance, has good conformance and works out of the box with [.proto](https://protobuf.dev/programming-guides/proto3/) files!\n\nContents\n--------\n\n* [Installation](#installation)<br />\n  How to include protobuf.js in your project.\n\n* [Usage](#usage)<br />\n  A brief introduction to using the toolset.\n\n  * [Valid Message](#valid-message)\n  * [Toolset](#toolset)<br />\n\n* [Examples](#examples)<br />\n  A few examples to get you started.\n\n  * [Using .proto files](#using-proto-files)\n  * [Using JSON descriptors](#using-json-descriptors)\n  * [Using reflection only](#using-reflection-only)\n  * [Using custom classes](#using-custom-classes)\n  * [Using services](#using-services)\n  * [Usage with TypeScript](#usage-with-typescript)<br />\n\n* [Additional documentation](#additional-documentation)<br />\n  A list of available documentation resources.\n\n* [Performance](#performance)<br />\n  A few internals and a benchmark on performance.\n\n* [Compatibility](#compatibility)<br />\n  Notes on compatibility regarding browsers and optional libraries.\n\n* [Building](#building)<br />\n  How to build the library and its components yourself.\n\nInstallation\n---------------\n\n### Node.js\n\n```sh\nnpm install protobufjs --save\n```\n\n```js\n// Static code + Reflection + .proto parser\nvar protobuf = require(\"protobufjs\");\n\n// Static code + Reflection\nvar protobuf = require(\"protobufjs/light\");\n\n// Static code only\nvar protobuf = require(\"protobufjs/minimal\");\n```\n\nThe optional [command line utility](./cli/) to generate static code and reflection bundles lives in the `protobufjs-cli` package and can be installed separately:\n\n```sh\nnpm install protobufjs-cli --save-dev\n```\n\n### Browsers\n\nPick the variant matching your needs and replace the version tag with the exact [release](https://github.com/protobufjs/protobuf.js/tags) your project depends upon. For example, to use the minified full variant:\n\n```html\n<script src=\"//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.min.js\"></script>\n```\n\n| Distribution | Location\n|--------------|--------------------------------------------------------\n| Full         | <https://cdn.jsdelivr.net/npm/protobufjs/dist/>\n| Light        | <https://cdn.jsdelivr.net/npm/protobufjs/dist/light/>\n| Minimal      | <https://cdn.jsdelivr.net/npm/protobufjs/dist/minimal/>\n\nAll variants support CommonJS and AMD loaders and export globally as `window.protobuf`.\n\nUsage\n-----\n\nBecause JavaScript is a dynamically typed language, protobuf.js utilizes the concept of a **valid message** in order to provide the best possible [performance](#performance) (and, as a side product, proper typings):\n\n### Valid message\n\n> A valid message is an object (1) not missing any required fields and (2) exclusively composed of JS types understood by the wire format writer.\n\nThere are two possible types of valid messages and the encoder is able to work with both of these for convenience:\n\n* **Message instances** (explicit instances of message classes with default values on their prototype) naturally satisfy the requirements of a valid message and\n* **Plain JavaScript objects** that just so happen to be composed in a way satisfying the requirements of a valid message as well.\n\nIn a nutshell, the wire format writer understands the following types:\n\n| Field type | Expected JS type (create, encode) | Conversion (fromObject)\n|------------|-----------------------------------|------------------------\n| s-/u-/int32<br />s-/fixed32 | `number` (32 bit integer) | <code>value &#124; 0</code> if signed<br />`value >>> 0` if unsigned\n| s-/u-/int64<br />s-/fixed64 | `Long`-like (optimal)<br />`number` (53 bit integer) | `Long.fromValue(value)` with long.js<br />`parseInt(value, 10)` otherwise\n| float<br />double | `number` | `Number(value)`\n| bool | `boolean` | `Boolean(value)`\n| string | `string` | `String(value)`\n| bytes | `Uint8Array` (optimal)<br />`Buffer` (optimal under node)<br />`Array.<number>` (8 bit integers) | `base64.decode(value)` if a `string`<br />`Object` with non-zero `.length` is assumed to be buffer-like\n| enum | `number` (32 bit integer) | Looks up the numeric id if a `string`\n| message | Valid message | `Message.fromObject(value)`\n| repeated T | `Array<T>` | Copy\n| map<K, V> | `Object<K,V>` | Copy\n\n* Explicit `undefined` and `null` are considered as not set if the field is optional.\n* Maps are objects where the key is the string representation of the respective value or an 8 characters long hash string for `Long`-likes.\n\n### Toolset\n\nWith that in mind and again for performance reasons, each message class provides a distinct set of methods with each method doing just one thing. This avoids unnecessary assertions / redundant operations where performance is a concern but also forces a user to perform verification (of plain JavaScript objects that *might* just so happen to be a valid message) explicitly where necessary - for example when dealing with user input.\n\n**Note** that `Message` below refers to any message class.\n\n* **Message.verify**(message: `Object`): `null|string`<br />\n  verifies that a **plain JavaScript object** satisfies the requirements of a valid message and thus can be encoded without issues. Instead of throwing, it returns the error message as a string, if any.\n\n  ```js\n  var payload = \"invalid (not an object)\";\n  var err = AwesomeMessage.verify(payload);\n  if (err)\n    throw Error(err);\n  ```\n\n* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />\n  encodes a **message instance** or valid **plain JavaScript object**. This method does not implicitly verify the message and it's up to the user to make sure that the payload is a valid message.\n\n  ```js\n  var buffer = AwesomeMessage.encode(message).finish();\n  ```\n\n* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />\n  works like `Message.encode` but additionally prepends the length of the message as a varint.\n\n* **Message.decode**(reader: `Reader|Uint8Array`): `Message`<br />\n  decodes a buffer to a **message instance**. If required fields are missing, it throws a `util.ProtocolError` with an `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`.\n\n  ```js\n  try {\n    var decodedMessage = AwesomeMessage.decode(buffer);\n  } catch (e) {\n      if (e instanceof protobuf.util.ProtocolError) {\n        // e.instance holds the so far decoded message with missing required fields\n      } else {\n        // wire format is invalid\n      }\n  }\n  ```\n\n* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`<br />\n  works like `Message.decode` but additionally reads the length of the message prepended as a varint.\n\n* **Message.create**(properties: `Object`): `Message`<br />\n  creates a new **message instance** from a set of properties that satisfy the requirements of a valid message. Where applicable, it is recommended to prefer `Message.create` over `Message.fromObject` because it doesn't perform possibly redundant conversion.\n\n  ```js\n  var message = AwesomeMessage.create({ awesomeField: \"AwesomeString\" });\n  ```\n\n* **Message.fromObject**(object: `Object`): `Message`<br />\n  converts any non-valid **plain JavaScript object** to a **message instance** using the conversion steps outlined within the table above.\n\n  ```js\n  var message = AwesomeMessage.fromObject({ awesomeField: 42 });\n  // converts awesomeField to a string\n  ```\n\n* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`<br />\n  converts a **message instance** to an arbitrary **plain JavaScript object** for interoperability with other libraries or storage. The resulting plain JavaScript object *might* still satisfy the requirements of a valid message depending on the actual conversion options specified, but most of the time it does not.\n\n  ```js\n  var object = AwesomeMessage.toObject(message, {\n    enums: String,  // enums as string names\n    longs: String,  // longs as strings (requires long.js)\n    bytes: String,  // bytes as base64 encoded strings\n    defaults: true, // includes default values\n    arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\n    objects: true,  // populates empty objects (map fields) even if defaults=false\n    oneofs: true    // includes virtual oneof fields set to the present field's name\n  });\n  ```\n\nFor reference, the following diagram aims to display relationships between the different methods and the concept of a valid message:\n\n<p align=\"center\"><img alt=\"Toolset Diagram\" src=\"https://protobufjs.github.io/protobuf.js/toolset.svg\" /></p>\n\n> In other words: `verify` indicates that calling `create` or `encode` directly on the plain object will [result in a valid message respectively] succeed. `fromObject`, on the other hand, does conversion from a broader range of plain objects to create valid messages. ([ref](https://github.com/protobufjs/protobuf.js/issues/748#issuecomment-291925749))\n\nExamples\n--------\n\n### Using .proto files\n\nIt is possible to load existing .proto files using the full library, which parses and compiles the definitions to ready to use (reflection-based) message classes:\n\n```protobuf\n// awesome.proto\npackage awesomepackage;\nsyntax = \"proto3\";\n\nmessage AwesomeMessage {\n    string awesome_field = 1; // becomes awesomeField\n}\n```\n\n```js\nprotobuf.load(\"awesome.proto\", function(err, root) {\n    if (err)\n        throw err;\n\n    // Obtain a message type\n    var AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\");\n\n    // Exemplary payload\n    var payload = { awesomeField: \"AwesomeString\" };\n\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\n    var errMsg = AwesomeMessage.verify(payload);\n    if (errMsg)\n        throw Error(errMsg);\n\n    // Create a new message\n    var message = AwesomeMessage.create(payload); // or use .fromObject if conversion is necessary\n\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\n    var buffer = AwesomeMessage.encode(message).finish();\n    // ... do something with buffer\n\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\n    var message = AwesomeMessage.decode(buffer);\n    // ... do something with message\n\n    // If the application uses length-delimited buffers, there is also encodeDelimited and decodeDelimited.\n\n    // Maybe convert the message back to a plain object\n    var object = AwesomeMessage.toObject(message, {\n        longs: String,\n        enums: String,\n        bytes: String,\n        // see ConversionOptions\n    });\n});\n```\n\nAdditionally, promise syntax can be used by omitting the callback, if preferred:\n\n```js\nprotobuf.load(\"awesome.proto\")\n    .then(function(root) {\n       ...\n    });\n```\n\n### Using JSON descriptors\n\nThe library utilizes JSON descriptors that are equivalent to a .proto definition. For example, the following is identical to the .proto definition seen above:\n\n```json\n// awesome.json\n{\n  \"nested\": {\n    \"awesomepackage\": {\n      \"nested\": {\n        \"AwesomeMessage\": {\n          \"fields\": {\n            \"awesomeField\": {\n              \"type\": \"string\",\n              \"id\": 1\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nJSON descriptors closely resemble the internal reflection structure:\n\n| Type (T)           | Extends            | Type-specific properties\n|--------------------|--------------------|-------------------------\n| *ReflectionObject* |                    | options\n| *Namespace*        | *ReflectionObject* | nested\n| Root               | *Namespace*        | **nested**\n| Type               | *Namespace*        | **fields**\n| Enum               | *ReflectionObject* | **values**\n| Field              | *ReflectionObject* | rule, **type**, **id**\n| MapField           | Field              | **keyType**\n| OneOf              | *ReflectionObject* | **oneof** (array of field names)\n| Service            | *Namespace*        | **methods**\n| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream\n\n* **Bold properties** are required. *Italic types* are abstract.\n* `T.fromJSON(name, json)` creates the respective reflection object from a JSON descriptor\n* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)\n\nExclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required in this case).\n\nA JSON descriptor can either be loaded the usual way:\n\n```js\nprotobuf.load(\"awesome.json\", function(err, root) {\n    if (err) throw err;\n\n    // Continue at \"Obtain a message type\" above\n});\n```\n\nOr it can be loaded inline:\n\n```js\nvar jsonDescriptor = require(\"./awesome.json\"); // exemplary for node\n\nvar root = protobuf.Root.fromJSON(jsonDescriptor);\n\n// Continue at \"Obtain a message type\" above\n```\n\n### Using reflection only\n\nBoth the full and the light library include full reflection support. One could, for example, define the .proto definitions seen in the examples above using just reflection:\n\n```js\n...\nvar Root  = protobuf.Root,\n    Type  = protobuf.Type,\n    Field = protobuf.Field;\n\nvar AwesomeMessage = new Type(\"AwesomeMessage\").add(new Field(\"awesomeField\", 1, \"string\"));\n\nvar root = new Root().define(\"awesomepackage\").add(AwesomeMessage);\n\n// Continue at \"Create a new message\" above\n...\n```\n\nDetailed information on the reflection structure is available within the [API documentation](#additional-documentation).\n\n### Using custom classes\n\nMessage classes can also be extended with custom functionality and it is also possible to register a custom constructor with a reflected message type:\n\n```js\n...\n\n// Define a custom constructor\nfunction AwesomeMessage(properties) {\n    // custom initialization code\n    ...\n}\n\n// Register the custom constructor with its reflected type (*)\nroot.lookupType(\"awesomepackage.AwesomeMessage\").ctor = AwesomeMessage;\n\n// Define custom functionality\nAwesomeMessage.customStaticMethod = function() { ... };\nAwesomeMessage.prototype.customInstanceMethod = function() { ... };\n\n// Continue at \"Create a new message\" above\n```\n\n(*) Besides referencing its reflected type through `AwesomeMessage.$type` and `AwesomeMesage#$type`, the respective custom class is automatically populated with:\n\n* `AwesomeMessage.create`\n* `AwesomeMessage.encode` and `AwesomeMessage.encodeDelimited`\n* `AwesomeMessage.decode` and `AwesomeMessage.decodeDelimited`\n* `AwesomeMessage.verify`\n* `AwesomeMessage.fromObject`, `AwesomeMessage.toObject` and `AwesomeMessage#toJSON`\n\nAfterwards, decoded messages of this type are `instanceof AwesomeMessage`.\n\nAlternatively, it is also possible to reuse and extend the internal constructor if custom initialization code is not required:\n\n```js\n...\n\n// Reuse the internal constructor\nvar AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\").ctor;\n\n// Define custom functionality\nAwesomeMessage.customStaticMethod = function() { ... };\nAwesomeMessage.prototype.customInstanceMethod = function() { ... };\n\n// Continue at \"Create a new message\" above\n```\n\n### Using services\n\nThe library also supports consuming services but it doesn't make any assumptions about the actual transport channel. Instead, a user must provide a suitable RPC implementation, which is an asynchronous function that takes the reflected service method, the binary request and a node-style callback as its parameters:\n\n```js\nfunction rpcImpl(method, requestData, callback) {\n    // perform the request using an HTTP request or a WebSocket for example\n    var responseData = ...;\n    // and call the callback with the binary response afterwards:\n    callback(null, responseData);\n}\n```\n\nBelow is a working example with a typescript implementation using grpc npm package.\n```ts\nconst grpc = require('grpc')\n\nconst Client = grpc.makeGenericClientConstructor({})\nconst client = new Client(\n  grpcServerUrl,\n  grpc.credentials.createInsecure()\n)\n\nconst rpcImpl = function(method, requestData, callback) {\n  client.makeUnaryRequest(\n    method.name,\n    arg => arg,\n    arg => arg,\n    requestData,\n    callback\n  )\n}\n```\n\nExample:\n\n```protobuf\n// greeter.proto\nsyntax = \"proto3\";\n\nservice Greeter {\n    rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\nmessage HelloRequest {\n    string name = 1;\n}\n\nmessage HelloReply {\n    string message = 1;\n}\n```\n\n```js\n...\nvar Greeter = root.lookup(\"Greeter\");\nvar greeter = Greeter.create(/* see above */ rpcImpl, /* request delimited? */ false, /* response delimited? */ false);\n\ngreeter.sayHello({ name: 'you' }, function(err, response) {\n    console.log('Greeting:', response.message);\n});\n```\n\nServices also support promises:\n\n```js\ngreeter.sayHello({ name: 'you' })\n    .then(function(response) {\n        console.log('Greeting:', response.message);\n    });\n```\n\nThere is also an [example for streaming RPC](https://github.com/protobufjs/protobuf.js/blob/master/examples/streaming-rpc.js).\n\nNote that the service API is meant for clients. Implementing a server-side endpoint pretty much always requires transport channel (i.e. http, websocket, etc.) specific code with the only common denominator being that it decodes and encodes messages.\n\n### Usage with TypeScript\n\nThe library ships with its own [type definitions](https://github.com/protobufjs/protobuf.js/blob/master/index.d.ts) and modern editors like [Visual Studio Code](https://code.visualstudio.com/) will automatically detect and use them for code completion.\n\nThe npm package depends on [@types/node](https://www.npmjs.com/package/@types/node) because of `Buffer` and [@types/long](https://www.npmjs.com/package/@types/long) because of `Long`. If you are not building for node and/or not using long.js, it should be safe to exclude them manually.\n\n#### Using the JS API\n\nThe API shown above works pretty much the same with TypeScript. However, because everything is typed, accessing fields on instances of dynamically generated message classes requires either using bracket-notation (i.e. `message[\"awesomeField\"]`) or explicit casts. Alternatively, it is possible to use a [typings file generated for its static counterpart](#pbts-for-typescript).\n\n```ts\nimport { load } from \"protobufjs\"; // respectively \"./node_modules/protobufjs\"\n\nload(\"awesome.proto\", function(err, root) {\n  if (err)\n    throw err;\n\n  // example code\n  const AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\");\n\n  let message = AwesomeMessage.create({ awesomeField: \"hello\" });\n  console.log(`message = ${JSON.stringify(message)}`);\n\n  let buffer = AwesomeMessage.encode(message).finish();\n  console.log(`buffer = ${Array.prototype.toString.call(buffer)}`);\n\n  let decoded = AwesomeMessage.decode(buffer);\n  console.log(`decoded = ${JSON.stringify(decoded)}`);\n});\n```\n\n#### Using generated static code\n\nIf you generated static code to `bundle.js` using the CLI and its type definitions to `bundle.d.ts`, then you can just do:\n\n```ts\nimport { AwesomeMessage } from \"./bundle.js\";\n\n// example code\nlet message = AwesomeMessage.create({ awesomeField: \"hello\" });\nlet buffer  = AwesomeMessage.encode(message).finish();\nlet decoded = AwesomeMessage.decode(buffer);\n```\n\n#### Using decorators\n\nThe library also includes an early implementation of [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html).\n\n**Note** that decorators are an experimental feature in TypeScript and that declaration order is important depending on the JS target. For example, `@Field.d(2, AwesomeArrayMessage)` requires that `AwesomeArrayMessage` has been defined earlier when targeting `ES5`.\n\n```ts\nimport { Message, Type, Field, OneOf } from \"protobufjs/light\"; // respectively \"./node_modules/protobufjs/light.js\"\n\nexport class AwesomeSubMessage extends Message<AwesomeSubMessage> {\n\n  @Field.d(1, \"string\")\n  public awesomeString: string;\n\n}\n\nexport enum AwesomeEnum {\n  ONE = 1,\n  TWO = 2\n}\n\n@Type.d(\"SuperAwesomeMessage\")\nexport class AwesomeMessage extends Message<AwesomeMessage> {\n\n  @Field.d(1, \"string\", \"optional\", \"awesome default string\")\n  public awesomeField: string;\n\n  @Field.d(2, AwesomeSubMessage)\n  public awesomeSubMessage: AwesomeSubMessage;\n\n  @Field.d(3, AwesomeEnum, \"optional\", AwesomeEnum.ONE)\n  public awesomeEnum: AwesomeEnum;\n\n  @OneOf.d(\"awesomeSubMessage\", \"awesomeEnum\")\n  public which: string;\n\n}\n\n// example code\nlet message = new AwesomeMessage({ awesomeField: \"hello\" });\nlet buffer  = AwesomeMessage.encode(message).finish();\nlet decoded = AwesomeMessage.decode(buffer);\n```\n\nSupported decorators are:\n\n* **Type.d(typeName?: `string`)** &nbsp; *(optional)*<br />\n  annotates a class as a protobuf message type. If `typeName` is not specified, the constructor's runtime function name is used for the reflected type.\n\n* **Field.d&lt;T>(fieldId: `number`, fieldType: `string | Constructor<T>`, fieldRule?: `\"optional\" | \"required\" | \"repeated\"`, defaultValue?: `T`)**<br />\n  annotates a property as a protobuf field with the specified id and protobuf type.\n\n* **MapField.d&lt;T extends { [key: string]: any }>(fieldId: `number`, fieldKeyType: `string`, fieldValueType. `string | Constructor<{}>`)**<br />\n  annotates a property as a protobuf map field with the specified id, protobuf key and value type.\n\n* **OneOf.d&lt;T extends string>(...fieldNames: `string[]`)**<br />\n  annotates a property as a protobuf oneof covering the specified fields.\n\nOther notes:\n\n* Decorated types reside in `protobuf.roots[\"decorated\"]` using a flat structure, so no duplicate names.\n* Enums are copied to a reflected enum with a generic name on decorator evaluation because referenced enum objects have no runtime name the decorator could use.\n* Default values must be specified as arguments to the decorator instead of using a property initializer for proper prototype behavior.\n* Property names on decorated classes must not be renamed on compile time (i.e. by a minifier) because decorators just receive the original field name as a string.\n\n**ProTip!** Not as pretty, but you can [use decorators in plain JavaScript](https://github.com/protobufjs/protobuf.js/blob/master/examples/js-decorators.js) as well.\n\nAdditional documentation\n------------------------\n\n#### Protocol Buffers\n* [Google's Developer Guide](https://protobuf.dev/overview/)\n\n#### protobuf.js\n* [API Documentation](https://protobufjs.github.io/protobuf.js)\n* [CHANGELOG](https://github.com/protobufjs/protobuf.js/blob/master/CHANGELOG.md)\n* [Frequently asked questions](https://github.com/protobufjs/protobuf.js/wiki) on our wiki\n\n#### Community\n* [Questions and answers](http://stackoverflow.com/search?tab=newest&q=protobuf.js) on StackOverflow\n\nPerformance\n-----------\nThe package includes a benchmark that compares protobuf.js performance to native JSON (as far as this is possible) and [Google's JS implementation](https://github.com/google/protobuf/tree/master/js). On an i7-2600K running node 6.9.1 it yields:\n\n```\nbenchmarking encoding performance ...\n\nprotobuf.js (reflect) x 541,707 ops/sec \u00b11.13% (87 runs sampled)\nprotobuf.js (static) x 548,134 ops/sec \u00b11.38% (89 runs sampled)\nJSON (string) x 318,076 ops/sec \u00b10.63% (93 runs sampled)\nJSON (buffer) x 179,165 ops/sec \u00b12.26% (91 runs sampled)\ngoogle-protobuf x 74,406 ops/sec \u00b10.85% (86 runs sampled)\n\n   protobuf.js (static) was fastest\n  protobuf.js (reflect) was 0.9% ops/sec slower (factor 1.0)\n          JSON (string) was 41.5% ops/sec slower (factor 1.7)\n          JSON (buffer) was 67.6% ops/sec slower (factor 3.1)\n        google-protobuf was 86.4% ops/sec slower (factor 7.3)\n\nbenchmarking decoding performance ...\n\nprotobuf.js (reflect) x 1,383,981 ops/sec \u00b10.88% (93 runs sampled)\nprotobuf.js (static) x 1,378,925 ops/sec \u00b10.81% (93 runs sampled)\nJSON (string) x 302,444 ops/sec \u00b10.81% (93 runs sampled)\nJSON (buffer) x 264,882 ops/sec \u00b10.81% (93 runs sampled)\ngoogle-protobuf x 179,180 ops/sec \u00b10.64% (94 runs sampled)\n\n  protobuf.js (reflect) was fastest\n   protobuf.js (static) was 0.3% ops/sec slower (factor 1.0)\n          JSON (string) was 78.1% ops/sec slower (factor 4.6)\n          JSON (buffer) was 80.8% ops/sec slower (factor 5.2)\n        google-protobuf was 87.0% ops/sec slower (factor 7.7)\n\nbenchmarking combined performance ...\n\nprotobuf.js (reflect) x 275,900 ops/sec \u00b10.78% (90 runs sampled)\nprotobuf.js (static) x 290,096 ops/sec \u00b10.96% (90 runs sampled)\nJSON (string) x 129,381 ops/sec \u00b10.77% (90 runs sampled)\nJSON (buffer) x 91,051 ops/sec \u00b10.94% (90 runs sampled)\ngoogle-protobuf x 42,050 ops/sec \u00b10.85% (91 runs sampled)\n\n   protobuf.js (static) was fastest\n  protobuf.js (reflect) was 4.7% ops/sec slower (factor 1.0)\n          JSON (string) was 55.3% ops/sec slower (factor 2.2)\n          JSON (buffer) was 68.6% ops/sec slower (factor 3.2)\n        google-protobuf was 85.5% ops/sec slower (factor 6.9)\n```\n\nThese results are achieved by\n\n* generating type-specific encoders, decoders, verifiers and converters at runtime\n* configuring the reader/writer interface according to the environment\n* using node-specific functionality where beneficial and, of course\n* avoiding unnecessary operations through splitting up [the toolset](#toolset).\n\nYou can also run [the benchmark](https://github.com/protobufjs/protobuf.js/blob/master/bench/index.js) ...\n\n```\n$> npm run bench\n```\n\nand [the profiler](https://github.com/protobufjs/protobuf.js/blob/master/bench/prof.js) yourself (the latter requires a recent version of node):\n\n```\n$> npm run prof <encode|decode|encode-browser|decode-browser> [iterations=10000000]\n```\n\nNote that as of this writing, the benchmark suite performs significantly slower on node 7.2.0 compared to 6.9.1 because moths.\n\nCompatibility\n-------------\n\n* Works in all modern and not-so-modern browsers except IE8.\n* Because the internals of this package do not rely on `google/protobuf/descriptor.proto`, options are parsed and presented literally.\n* If typed arrays are not supported by the environment, plain arrays will be used instead.\n* Support for pre-ES5 environments (except IE8) can be achieved by [using a polyfill](https://github.com/protobufjs/protobuf.js/blob/master/lib/polyfill.js).\n* Support for [Content Security Policy](https://w3c.github.io/webappsec-csp/)-restricted environments (like Chrome extensions without unsafe-eval) can be achieved by generating and using static code instead.\n* If a proper way to work with 64 bit values (uint64, int64 etc.) is required, just install [long.js](https://github.com/dcodeIO/long.js) alongside this library. All 64 bit numbers will then be returned as a `Long` instance instead of a possibly unsafe JavaScript number ([see](https://github.com/dcodeIO/long.js)).\n* For descriptor.proto interoperability, see [ext/descriptor](https://github.com/protobufjs/protobuf.js/tree/master/ext/descriptor)\n\nBuilding\n--------\n\nTo build the library or its components yourself, clone it from GitHub and install the development dependencies:\n\n```\n$> git clone https://github.com/protobufjs/protobuf.js.git\n$> cd protobuf.js\n$> npm install\n```\n\nBuilding the respective development and production versions with their respective source maps to `dist/`:\n\n```\n$> npm run build\n```\n\nBuilding the documentation to `docs/`:\n\n```\n$> npm run docs\n```\n\nBuilding the TypeScript definition to `index.d.ts`:\n\n```\n$> npm run build:types\n```\n\n### Browserify integration\n\nBy default, protobuf.js integrates into any browserify build-process without requiring any optional modules. Hence:\n\n* If int64 support is required, explicitly require the `long` module somewhere in your project as it will be excluded otherwise. This assumes that a global `require` function is present that protobuf.js can call to obtain the long module.\n\n  If there is no global `require` function present after bundling, it's also possible to assign the long module programmatically:\n\n  ```js\n  var Long = ...;\n\n  protobuf.util.Long = Long;\n  protobuf.configure();\n  ```\n\n* If you have any special requirements, there is [the bundler](https://github.com/protobufjs/protobuf.js/blob/master/scripts/bundle.js) for reference.\n\n**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)\n",
        "releases": [
            {
                "name": "protobufjs: v7.4.0",
                "date": "2024-08-22T19:02:13Z"
            },
            {
                "name": "protobufjs-cli: v1.1.4",
                "date": "2024-08-22T19:02:12Z"
            },
            {
                "name": "protobufjs: v7.3.3",
                "date": "2024-08-16T19:58:31Z"
            },
            {
                "name": "protobufjs-cli: v1.1.3",
                "date": "2024-08-16T19:58:30Z"
            },
            {
                "name": "protobufjs: v7.3.2",
                "date": "2024-06-12T08:26:11Z"
            },
            {
                "name": "protobufjs: v7.3.1",
                "date": "2024-06-07T23:09:08Z"
            },
            {
                "name": "protobufjs: v7.3.0",
                "date": "2024-05-10T03:43:00Z"
            },
            {
                "name": "protobufjs: v7.2.6",
                "date": "2024-01-16T22:53:43Z"
            },
            {
                "name": "protobufjs: v7.2.5",
                "date": "2023-08-22T00:03:54Z"
            },
            {
                "name": "protobufjs-cli: v1.1.2",
                "date": "2023-08-22T00:03:53Z"
            },
            {
                "name": "protobufjs: v7.2.4",
                "date": "2023-06-23T23:33:43Z"
            },
            {
                "name": "protobufjs: v7.2.3",
                "date": "2023-03-27T18:07:39Z"
            },
            {
                "name": "protobufjs: v7.2.2",
                "date": "2023-02-07T15:24:56Z"
            },
            {
                "name": "protobufjs: v7.2.1",
                "date": "2023-02-02T21:16:41Z"
            },
            {
                "name": "protobufjs-cli: v1.1.1",
                "date": "2023-02-02T21:16:39Z"
            },
            {
                "name": "protobufjs: v7.2.0",
                "date": "2023-01-24T19:49:20Z"
            },
            {
                "name": "protobufjs-cli: v1.1.0",
                "date": "2023-01-24T19:49:18Z"
            },
            {
                "name": "protobufjs: v7.1.2",
                "date": "2022-09-22T18:33:24Z"
            },
            {
                "name": "protobufjs: v7.1.1",
                "date": "2022-09-10T00:37:10Z"
            },
            {
                "name": "protobufjs-cli: v1.0.2",
                "date": "2022-09-10T00:37:09Z"
            },
            {
                "name": "protobufjs: v7.1.0",
                "date": "2022-08-26T22:07:10Z"
            },
            {
                "name": "protobufjs-cli: v1.0.1",
                "date": "2022-08-26T22:07:08Z"
            },
            {
                "name": "protobufjs: v7.0.0",
                "date": "2022-07-08T17:40:51Z"
            },
            {
                "name": "protobufjs-cli: v1.0.0",
                "date": "2022-07-08T17:40:49Z"
            },
            {
                "name": "v6.11.3",
                "date": "2022-05-20T19:29:29Z"
            },
            {
                "name": "v6.11.2",
                "date": "2021-04-30T17:32:06Z"
            },
            {
                "name": "v6.11.1",
                "date": "2021-04-30T17:16:31Z"
            },
            {
                "name": "v6.11.0",
                "date": "2021-04-30T17:16:02Z"
            },
            {
                "name": "protobuf.js v6.10.2",
                "date": "2020-11-16T21:15:32Z"
            },
            {
                "name": "protobuf.js v6.10.1",
                "date": "2020-07-16T02:52:29Z"
            },
            {
                "name": "v6.10.1-beta.0 Pre-release",
                "date": "2020-07-16T02:38:11Z"
            },
            {
                "name": "protobuf.js v6.10.0",
                "date": "2020-07-13T23:33:46Z"
            },
            {
                "name": "v6.10.0-beta.2 Pre-release",
                "date": "2020-07-13T23:06:29Z"
            },
            {
                "name": "v6.10.0-beta.1 Pre-release",
                "date": "2020-07-13T21:34:19Z"
            },
            {
                "name": "v6.10.0-beta.0 Pre-release",
                "date": "2020-06-17T23:05:56Z"
            },
            {
                "name": "protobuf.js v6.9.0",
                "date": "2020-04-20T18:13:08Z"
            },
            {
                "name": "v6.9.0-beta.0 Pre-release",
                "date": "2020-04-17T22:32:33Z"
            },
            {
                "name": "5.0.3",
                "date": "2018-05-16T09:24:55Z"
            },
            {
                "name": "6.8.6",
                "date": "2018-02-26T11:47:28Z"
            },
            {
                "name": "protobuf.js 6.8.0",
                "date": "2017-06-09T21:04:43Z"
            },
            {
                "name": "protobuf.js 6.7.0",
                "date": "2017-04-02T13:58:46Z"
            },
            {
                "name": "protobuf.js 6.6.0",
                "date": "2017-01-24T04:15:27Z"
            },
            {
                "name": "protobuf.js 6.5.0",
                "date": "2017-01-17T14:01:17Z"
            },
            {
                "name": "protobuf.js 6.4.0",
                "date": "2017-01-03T15:48:42Z"
            },
            {
                "name": "protobuf.js 6.0.0",
                "date": "2016-11-28T17:10:31Z"
            },
            {
                "name": "3.0.0 using ByteBuffer 3",
                "date": "2014-07-08T15:21:52Z"
            },
            {
                "name": "2.2.1 - last 2.x",
                "date": "2014-06-04T12:34:39Z"
            },
            {
                "name": "2.0.5",
                "date": "2014-02-20T20:46:16Z"
            },
            {
                "name": "1.5.2 - last 1.x",
                "date": "2013-11-18T17:03:17Z"
            }
        ]
    }
}
{
    "https://api.github.com/repos/hackergrrl/art-of-readme": {
        "forks": 414,
        "watchers": 7043,
        "stars": 7043,
        "languages": {},
        "commits": [
            "2022-08-21T15:42:02Z",
            "2022-08-21T15:12:53Z",
            "2022-08-19T16:32:24Z",
            "2022-08-16T15:05:42Z",
            "2022-08-16T15:05:01Z",
            "2022-08-16T15:04:39Z",
            "2022-08-06T21:02:58Z",
            "2022-08-06T20:25:38Z",
            "2022-08-05T15:07:29Z",
            "2022-01-29T02:05:17Z",
            "2022-01-28T14:35:10Z",
            "2021-11-16T17:30:40Z",
            "2021-04-14T00:05:49Z",
            "2021-04-13T22:14:13Z",
            "2021-02-02T21:06:27Z",
            "2021-02-02T21:05:32Z",
            "2021-01-29T20:13:44Z",
            "2021-01-29T13:29:12Z",
            "2021-01-29T13:24:32Z",
            "2021-01-29T13:22:32Z",
            "2021-01-29T12:59:03Z",
            "2021-01-29T12:49:19Z",
            "2021-01-27T20:16:15Z",
            "2021-01-27T20:02:50Z",
            "2021-01-26T21:06:25Z",
            "2021-01-26T20:08:55Z",
            "2021-01-26T20:07:12Z",
            "2021-01-26T19:56:31Z",
            "2021-01-26T19:42:56Z",
            "2021-01-26T19:24:54Z"
        ],
        "creation_date": "2016-10-01T15:22:24Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 91,
        "readme": "# Art of README\n\n*This article can also be read in [Chinese](README-zh.md),\n[Japanese](README-ja-JP.md),\n[Brazilian Portuguese](README-pt-BR.md), [Spanish](README-es-ES.md),\n[German](README-de-DE.md), [French](README-fr.md) and [Traditional Chinese](README-zh-TW.md).*\n\n## Etymology\n\nWhere does the term \"README\" come from?\n\nThe nomenclature dates back to *at least* the 1970s [and the\nPDP-10](http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html),\nthough it may even harken back to the days of informative paper notes placed atop\nstacks of punchcards, \"READ ME!\" scrawled on them, describing their use.\n\nA reader<sup>[1](#footnote-1)</sup> suggested that the title README may be a playful nudge toward Lewis\nCarroll's *Alice's Adventures in Wonderland*, which features a potion and a cake\nlabelled *\"DRINK ME\"* and *\"EAT ME\"*, respectively.\n\nThe pattern of README appearing in all-caps is a consistent facet throughout\nhistory. In addition to the visual strikingness of using all-caps, UNIX systems\nwould sort capitals before lower case letters, conveniently putting the README\nbefore the rest of the directory's content<sup>[2](#footnote-2)</sup>.\n\nThe intent is clear: *\"This is important information for the user to read before\nproceeding.\"* Let's explore together what constitutes \"important information\" in\nthis modern age.\n\n\n## For creators, for consumers\n\nThis is an article about READMEs. About what they do, why they are an absolute\nnecessity, and how to craft them well.\n\nThis is written for module creators, for as a builder of modules, your job is to\ncreate something that will last. This is an inherent motivation, even if the\nauthor has no intent of sharing their work. Once 6 months pass, a module without\ndocumentation begins to look new and unfamiliar.\n\nThis is also written for module consumers, for every module author is also a\nmodule consumer. Node has a very healthy degree of interdependency: no one lives\nat the bottom of the dependency tree.\n\nDespite being focused on Node, the author contends that its lessons apply\nequally well to other programming ecosystems, as well.\n\n\n## Many modules: some good, some bad\n\nThe Node ecosystem is powered by its modules. [npm](https://npmjs.org) is the\nmagic that makes it all *go*. In the course of a week, Node developers evaluate\ndozens of modules for inclusion in their projects. This is a great deal of power\nbeing churned out on a daily basis, ripe for the plucking, just as fast as one\ncan write `npm install`.\n\nLike any ecosystem that is extremely accessible, the quality bar varies. npm\ndoes its best to nicely pack away all of these modules and ship them far and\nwide. However, the tools found are widely varied: some are shining and new,\nothers broken and rusty, and still others are somewhere in between. There are\neven some that we don't know what they do!\n\nFor modules, this can take the form of inaccurate or unhelpful names (any\nguesses what the `fudge` module does?), no documentation, no tests, no source\ncode comments, or incomprehensible function names.\n\nMany don't have an active maintainer. If a module has no human available to\nanswer questions and explain what a module does, combined with no remnants of\ndocumentation left behind, a module becomes a bizarre alien artifact, unusable\nand incomprehensible by the archaeologist-hackers of tomorrow.\n\nFor those modules that do have documentation, where do they fall on the quality\nspectrum? Maybe it's just a one-liner description: `\"sorts numbers by their hex\nvalue\"`. Maybe it's a snippet of example code. These are both improvements upon\nnothing, but they tend to result in the worst-case scenario for a modern day\nmodule spelunker: digging into the source code to try and understand how it\nactually works. Writing excellent documentation is all about keeping the users\n*out* of the source code by providing instructions sufficient to enjoy the\nwonderful abstractions that your module brings.\n\nNode has a \"wide\" ecosystem: it's largely made up of a very long list of\nindependent do-one-thing-well modules flying no flags but their own. There are\n[exceptions](https://github.com/lodash/lodash), but despite these minor fiefdoms,\nit is the single-purpose commoners who, given their larger numbers, truly rule the\nNode kingdom.\n\nThis situation has a natural consequence: it can be hard to find *quality* modules\nthat do exactly what you want.\n\n**This is okay**. Truly. A low bar to entry and a discoverability problem is\ninfinitely better than a culture problem, where only the privileged few may\nparticipate.\n\nPlus, discoverability -- as it turns out -- is easier to address.\n\n\n## All roads lead to README.md\n\nThe Node community has responded to the challenge of discoverability in\ndifferent ways.\n\nSome experienced Node developers band together to create [curated\nlists](https://github.com/sindresorhus/awesome-nodejs) of quality modules.\nDevelopers leverage their many years examining hundreds of different modules to\nshare with newcomers the *cr\u00e8me de la cr\u00e8me*: the best modules in each category.\nThis might also take the form of RSS feeds and mailing lists of new modules deemed\nto be useful by trusted community members.\n\nHow about the social graph? This idea spurred the creation of\n[node-modules.com](http://node-modules.com/), a npm search replacement that\nleverages your GitHub social graph to find modules your friends like or have\nmade.\n\nOf course there is also npm's built-in [search](https://npmjs.org)\nfunctionality: a safe default, and the usual port of entry for new developers.\n\nNo matter your approach, regardless whether a module spelunker enters the module\nunderground at [npmjs.org](https://npmjs.org),\n[github.com](https://github.com), or somewhere else, this would-be user will\neventually end up staring your README square in the face. Since your users\nwill inevitably find themselves here, what can be done to make their first\nimpressions maximally effective?\n\n\n## Professional module spelunking\n\n### The README: Your one-stop shop\n\nA README is a module consumer's first -- and maybe only -- look into your\ncreation. The consumer wants a module to fulfill their need, so you must explain\nexactly what need your module fills, and how effectively it does so.\n\nYour job is to\n\n1. tell them what it is (with context)\n2. show them what it looks like in action\n3. show them how they use it\n4. tell them any other relevant details\n\nThis is *your* job. It's up to the module creator to prove that their work is a\nshining gem in the sea of slipshod modules. Since so many developers' eyes will\nfind their way to your README before anything else, quality here is your\npublic-facing measure of your work.\n\n\n### Brevity\n\nThe lack of a README is a powerful red flag, but even a lengthy README is not\nindicative of there being high quality. The ideal README is as short as it can\nbe without being any shorter. Detailed documentation is good -- make separate\npages for it! -- but keep your README succinct.\n\n\n### Learn from the past\n\nIt is said that those who do not study their history are doomed to make its\nmistakes again. Developers have been writing documentation for quite some number\nof years. It would be wasteful to not look back a little bit and see what people\ndid right before Node.\n\nPerl, for all of the flak it receives, is in some ways the spiritual grandparent\nof Node. Both are high-level scripting languages, adopt many UNIX idioms, fuel\nmuch of the internet, and both feature a wide module ecosystem.\n\nIt so turns out that the [monks](http://perlmonks.org) of the Perl community\nindeed have a great deal of experience in writing [quality\nREADMEs](http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm). CPAN is a\nwonderful resource that is worth reading through to learn more about a community\nthat wrote consistently high-calibre documentation.\n\n\n### No README? No abstraction\n\nNo README means developers will need to delve into your code in order to\nunderstand it.\n\nThe Perl monks have wisdom to share on the matter:\n\n> Your documentation is complete when someone can use your module without ever\n> having to look at its code. This is very important. This makes it possible for\n> you to separate your module's documented interface from its internal\n> implementation (guts). This is good because it means that you are free to\n> change the module's internals as long as the interface remains the same.\n>\n> Remember: the documentation, not the code, defines what a module does.\n-- [Ken Williams](http://mathforum.org/ken/perl_modules.html#document)\n\n\n### Key elements\n\nOnce a README is located, the brave module spelunker must scan it to discern if\nit matches the developer's needs. This becomes essentially a series of pattern\nmatching problems for their brain to solve, where each step takes them deeper\ninto the module and its details.\n\nLet's say, for example, my search for a 2D collision detection module leads me\nto [`collide-2d-aabb-aabb`](https://github.com/hackergrrl/collide-2d-aabb-aabb). I\nbegin to examine it from top to bottom:\n\n1. *Name* -- self-explanatory names are best. `collide-2d-aabb-aabb` sounds\n   promising, though it assumes I know what an \"aabb\" is. If the name sounds too\n   vague or unrelated, it may be a signal to move on.\n\n2. *One-liner* -- having a one-liner that describes the module is useful for\n   getting an idea of what the module does in slightly greater detail.\n   `collide-2d-aabb-aabb` says it\n\n   > Determines whether a moving axis-aligned bounding box (AABB) collides with\n   > other AABBs.\n\n   Awesome: it defines what an AABB is, and what the module does. Now to gauge how\n   well it'd fit into my code:\n\n3. *Usage* -- rather than starting to delve into the API docs, it'd be great to\n   see what the module looks like in action. I can quickly determine whether the\n   example JS fits the desired style and problem. People have lots of opinions\n   on things like promises/callbacks and ES6. If it does fit the bill, then I\n   can proceed to greater detail.\n\n4. *API* -- the name, description, and usage of this module all sound appealing\n   to me. I'm very likely to use this module at this point. I just need to scan\n   the API to make sure it does exactly what I need and that it will integrate\n   easily into my codebase. The API section ought to detail the module's objects\n   and functions, their signatures, return types, callbacks, and events in\n   detail. Types should be included where they aren't obvious. Caveats should be\n   made clear.\n\n5. *Installation* -- if I've read this far down, then I'm sold on trying out the\n   module. If there are nonstandard installation notes, here's where they'd go,\n   but even if it's just a regular `npm install`, I'd like to see that mentioned,\n   too. New users start using Node all the time, so having a link to npmjs.org\n   and an install command provides them the resources to figure out how Node\n   modules work.\n\n6. *License* -- most modules put this at the very bottom, but this might\n   actually be better to have higher up; you're likely to exclude a module VERY\n   quickly if it has a license incompatible with your work. I generally stick to\n   the MIT/BSD/X11/ISC flavours. If you have a non-permissive license, stick it\n   at the very top of the module to prevent any confusion.\n\n\n## Cognitive funneling\n\nThe ordering of the above was not chosen at random.\n\nModule consumers use many modules, and need to look at many modules.\n\nOnce you've looked at hundreds of modules, you begin to notice that the mind\nbenefits from predictable patterns.\n\nYou also start to build out your own personal heuristic for what information you\nwant, and what red flags disqualify modules quickly.\n\nThus, it follows that in a README it is desirable to have:\n\n1. a predictable format\n2. certain key elements present\n\nYou don't need to use *this* format, but try to be consistent to save your users\nprecious cognitive cycles.\n\nThe ordering presented here is lovingly referred to as \"cognitive funneling,\"\nand can be imagined as a funnel held upright, where the widest end contains the\nbroadest more pertinent details, and moving deeper down into the funnel presents\nmore specific details that are pertinent for only a reader who is interested\nenough in your work to have reached that deeply in the document. Finally, the\nbottom can be reserved for details only for those intrigued by the deeper\ncontext of the work (background, credits, biblio, etc.).\n\nOnce again, the Perl monks have wisdom to share on the subject:\n\n> The level of detail in Perl module documentation generally goes from\n> less detailed to more detailed.  Your SYNOPSIS section should\n> contain a minimal example of use (perhaps as little as one line of\n> code; skip the unusual use cases or anything not needed by most\n> users); the DESCRIPTION should describe your module in broad terms,\n> generally in just a few paragraphs; more detail of the module's\n> routines or methods, lengthy code examples, or other in-depth\n> material should be given in subsequent sections.\n>\n> Ideally, someone who's slightly familiar with your module should be\n> able to refresh their memory without hitting \"page down\".  As your\n> reader continues through the document, they should receive a\n> progressively greater amount of knowledge.\n> -- from `perlmodstyle`\n\n\n## Care about people's time\n\nAwesome; the ordering of these key elements should be decided by how quickly\nthey let someone 'short circuit' and bail on your module.\n\nThis sounds bleak, doesn't it? But think about it: your job, when you're doing\nit with optimal altruism in mind, isn't to \"sell\" people on your work. It's to\nlet them evaluate what your creation does as objectively as possible, and decide\nwhether it meets their needs or not -- not to, say, maximize your downloads or\nuserbase.\n\nThis mindset doesn't appeal to everyone; it requires checking your ego at the\ndoor and letting the work speak for itself as much as possible. Your only job is\nto describe its promise as succinctly as you can, so module spelunkers can\neither use your work when it's a fit, or move on to something else that does.\n\n\n## Call to arms!\n\nGo forth, brave module spelunker, and make your work discoverable and usable\nthrough excellent documentation!\n\n\n## Bonus: other good practices\n\nOutside of the key points of the article, there are other practices you can\nfollow (or not follow) to raise your README's quality bar even further and\nmaximize its usefulness to others:\n\n1. Consider including a **Background** section if your module depends on\n   important but not widely known abstractions or other ecosystems. The function\n   of [`bisecting-between`](https://github.com/hackergrrl/bisecting-between) is not\n   immediately obvious from its name, so it has a detailed *Background* section\n   to define and link to the big concepts and abstractions one needs to\n   understand to use and grok it. This is also a great place to explain the\n   module's motivation if similar modules already exist on npm.\n\n2. Aggressively linkify! If you talk about other modules, ideas, or people, make\n   that reference text a link so that visitors can more easily grok your module\n   and the ideas it builds on. Few modules exist in a vacuum: all work comes\n   from other work, so it pays to help users follow your module's history and\n   inspiration.\n\n3. Include information on types of arguments and return parameters if it's not\n   obvious. Prefer convention wherever possible (`cb` probably means callback\n   function, `num` probably means a `Number`, etc.).\n\n4. Include the example code in **Usage** as a file in your repo -- maybe as\n   `example.js`. It's great to have README code that users can actually run if\n   they clone the repository.\n\n5. Be judicious in your use of badges. They're easy to\n   [abuse](https://github.com/angular/angular). They can also be a breeding\n   ground for bikeshedding and endless debate. They add visual noise to your\n   README and generally only function if the user is reading your Markdown in a\n   browser online, since the images are often hosted elsewhere on the\n   internet. For each badge, consider: \"what real value is this badge providing\n   to the typical viewer of this README?\" Do you have a CI badge to show build/test\n   status? This signal would better reach important parties by emailing\n   maintainers or automatically creating an issue. Always consider the\n   audience of the data in your README and ask yourself if there's a flow for\n   that data that can better reach its intended audience.\n\n6. API formatting is highly bikesheddable. Use whatever format you think is\n   clearest, but make sure your format expresses important subtleties:\n\n   a. which parameters are optional, and their defaults\n\n   b. type information, where it is not obvious from convention\n\n   c. for `opts` object parameters, all keys and values that are accepted\n\n   d. don't shy away from providing a tiny example of an API function's use if\n      it is not obvious or fully covered in the **Usage** section.\n      However, this can also be a strong signal that the function is too complex\n      and needs to be refactored, broken into smaller functions, or removed\n      altogether\n\n   e. aggressively linkify specialized terminology! In markdown you can keep\n      [footnotes](https://daringfireball.net/projects/markdown/syntax#link) at\n      the bottom of your document, so referring to them several times throughout\n      becomes cheap. Some of my personal preferences on API formatting can be\n      found\n      [here](https://github.com/hackergrrl/common-readme/blob/master/api_formatting.md)\n\n7. If your module is a small collection of stateless functions, having a\n   **Usage** section as a [Node REPL\n   session](https://github.com/hackergrrl/bisecting-between#example) of function\n   calls and results might communicate usage more clearly than a source code\n   file to run.\n\n8. If your module provides a CLI (command line interface) instead of (or in\n    addition to) a programmatic API, show usage examples as command invocations\n    and their output. If you create or modify a file, `cat` it to demonstrate\n    the change before and after.\n\n9. Don't forget to use `package.json`\n    [keywords](https://docs.npmjs.com/files/package.json#keywords) to direct\n    module spelunkers to your doorstep.\n\n10. The more you change your API, the more work you need to exert updating\n    documentation -- the implication here is that you should keep your APIs\n    small and concretely defined early on. Requirements change over time, but\n    instead of front-loading assumptions into the APIs of your modules, load\n    them up one level of abstraction: the module set itself. If the requirements\n    *do* change and 'do-one-concrete-thing' no longer makes sense, then simply\n    write a new module that does the thing you need. The 'do-one-concrete-thing'\n    module remains a valid and valuable model for the npm ecosystem, and your\n    course correction cost you nothing but a simple substitution of one module for\n    another.\n\n11. Finally, please remember that your version control repository and its\n    embedded README will outlive your [repository host](https://github.com) and\n    any of the things you hyperlink to -- especially images -- so *inline* anything\n    that is essential to future users grokking your work.\n\n\n## Bonus: *common-readme*\n\nNot coincidentally, this is also the format used by\n[**common-readme**](https://github.com/hackergrrl/common-readme), a set of README\nguidelines and handy command-line generator. If you like what's written here,\nyou may save some time writing READMEs with `common-readme`. You'll find\nreal module examples with this format, too.\n\nYou may also enjoy\n[standard-readme](https://github.com/richardlitt/standard-readme), which is a\nmore structured, lintable take on a common README format.\n\n\n## Bonus: Exemplars\n\nTheory is well and good, but what do excellent READMEs look like? Here are some\nthat I think embody the principles of this article well:\n\n- https://github.com/hackergrrl/ice-box\n- https://github.com/substack/quote-stream\n- https://github.com/feross/bittorrent-dht\n- https://github.com/mikolalysenko/box-intersect\n- https://github.com/freeman-lab/pixel-grid\n- https://github.com/mafintosh/torrent-stream\n- https://github.com/pull-stream/pull-stream\n- https://github.com/substack/tape\n- https://github.com/yoshuawuyts/vmd\n\n\n## Bonus: The README Checklist\n\nA helpful checklist to gauge how your README is coming along:\n\n- [ ] One-liner explaining the purpose of the module\n- [ ] Necessary background context & links\n- [ ] Potentially unfamiliar terms link to informative sources\n- [ ] Clear, *runnable* example of usage\n- [ ] Installation instructions\n- [ ] Extensive API documentation\n- [ ] Performs [cognitive funneling](https://github.com/hackergrrl/art-of-readme#cognitive-funneling)\n- [ ] Caveats and limitations mentioned up-front\n- [ ] Doesn't rely on images to relay critical information\n- [ ] License\n\n\n## The author\n\nHi, I'm [Kira](http://kira.solar).\n\nThis little project began back in May in Berlin at squatconf, where I was\ndigging into how Perl monks write their documentation and also lamenting the\nstate of READMEs in the Node ecosystem. It spurred me to create\n[common-readme](https://github.com/hackergrrl/common-readme). The \"README Tips\"\nsection overflowed with tips though, which I decided could be usefully collected\ninto an article about writing READMEs. Thus, Art of README was born!\n\n\n## Further Reading\n\n- [README-Driven Development](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html)\n- [Documentation First](http://joeyh.name/blog/entry/documentation_first/)\n\n\n## Footnotes\n\n1. <a name=\"footnote-1\"></a>Thanks,\n   [Sixes666](https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6)!\n\n2. <a name=\"footnote-2\"></a>See [The Jargon File](http://catb.org/~esr/jargon/html/R/README-file.html).\n   However, most systems today will not sort capitals before all lowercase\n   characters, reducing this convention's usefulness to just the visual\n   strikingness of all-caps.\n\n\n## Credits\n\nA heartfelt thank you to [@mafintosh](https://github.com/mafintosh) and\n[@feross](https://github.com/feross) for the encouragement I needed to get this\nidea off the ground and start writing!\n\nThank you to the following awesome readers for noticing errors and sending me\nPRs :heart: :\n\n- [@ungoldman](https://github.com/ungoldman)\n- [@boidolr](https://github.com/boidolr)\n- [@imjoehaines](https://github.com/imjoehaines)\n- [@radarhere](https://github.com/radarhere)\n- [@joshmanders](https://github.com/joshmanders)\n- [@ddbeck](https://github.com/ddbeck)\n- [@RichardLitt](https://github.com/RichardLitt)\n- [@StevenMaude](https://github.com/StevenMaude)\n- [@KrishMunot](https://github.com/KrishMunot)\n- [@chesterhow](https://github.com/chesterhow)\n- [@sjsyrek](https://github.com/sjsyrek)\n- [@thenickcox](https://github.com/thenickcox)\n\nThank you to [@qihaiyan](https://github.com/qihaiyan) for translating Art of\nREADME to Chinese! The following users also made contributions:\n\n- [@BrettDong](https://github.com/brettdong) for revising punctuation in Chinese version.\n- [@Alex-fun](https://github.com/Alex-fun)\n- [@HmyBmny](https://github.com/HmyBmny)\n- [@vra](https://github.com/vra)\n\nThank you to [@lennonjesus](https://github.com/lennonjesus) for translating Art\nof README to Brazilian Portuguese! The following users also made contributions:\n\n- [@rectius](https://github.com/rectius)\n\nThank you to [@jabiinfante](https://github.com/jabiinfante) for translating Art\nof README to Spanish!\n\nThank you to [@Ryuno-Ki](https://github.com/Ryuno-Ki) for translating Art of\nREADME to German! The following users also made contributions:\n\n- [@randomC0der](https://github.com/randomC0der)\n\nThank you to [@Manfred Madelaine](https://github.com/Manfred-Madelaine-pro) and\n[@Ruben Madelaine](https://github.com/Ruben-Madelaine)\nfor translating Art of README to French!\n\n## Other Resources\nSome readers have suggested other useful resources for README composition:\n- [Software Release Practice](https://tldp.org/HOWTO/Software-Release-Practice-HOWTO/distpractice.html#readme)\n- [GNU Releases](https://www.gnu.org/prep/standards/html_node/Releases.html#index-README-file)\n\n\n## License\n\n[Creative Commons Attribution License](http://creativecommons.org/licenses/by/2.0/)\n",
        "releases": []
    }
}
{
    "https://api.github.com/repos/Jam3/math-as-code": {
        "forks": 1092,
        "watchers": 15270,
        "stars": 15270,
        "languages": {},
        "commits": [
            "2019-06-26T19:40:03Z",
            "2019-05-30T08:26:49Z",
            "2019-05-30T08:26:27Z",
            "2019-05-30T08:25:49Z",
            "2019-05-30T08:24:38Z",
            "2019-05-29T21:59:13Z",
            "2019-05-29T21:58:05Z",
            "2019-05-29T21:45:08Z",
            "2019-05-29T21:43:45Z",
            "2019-05-13T16:09:49Z",
            "2019-05-13T13:47:22Z",
            "2019-05-13T07:00:47Z",
            "2019-05-13T06:57:45Z",
            "2019-05-13T06:57:27Z",
            "2019-05-13T06:47:09Z",
            "2019-05-13T06:33:04Z",
            "2019-05-13T05:48:51Z",
            "2019-05-13T05:33:24Z",
            "2019-05-12T16:28:32Z",
            "2019-05-12T15:49:18Z",
            "2018-09-19T10:15:21Z",
            "2018-09-19T10:14:12Z",
            "2018-09-19T10:13:53Z",
            "2018-09-19T10:13:43Z",
            "2018-09-17T11:55:20Z",
            "2018-09-17T11:54:32Z",
            "2018-01-18T03:43:49Z",
            "2018-01-18T03:33:52Z",
            "2017-12-22T14:56:47Z",
            "2017-12-18T17:19:58Z"
        ],
        "creation_date": "2015-06-29T21:59:08Z",
        "contributors": 16,
        "topics": [],
        "subscribers": 407,
        "readme": "# math-as-code\n\n>[Chinese translation (\u4e2d\u6587\u7248)](./README-zh.md)  \n>[Python version (English)](./PYTHON-README.md)\n\nThis is a reference to ease developers into mathematical notation by showing comparisons with JavaScript code.\n\nMotivation: Academic papers can be intimidating for self-taught game and graphics programmers. :) \n\nThis guide is not yet finished. If you see errors or want to contribute, please [open a ticket](https://github.com/Jam3/math-as-code/issues) or send a PR.\n\n> **Note**: For brevity, some code examples make use of [npm packages](https://www.npmjs.com/). You can refer to their GitHub repos for implementation details.\n\n\n\n# foreword\n\nMathematical symbols can mean different things depending on the author, context and the field of study (linear algebra, set theory, etc). This guide may not cover *all* uses of a symbol. In some cases, real-world references (blog posts, publications, etc) will be cited to demonstrate how a symbol might appear in the wild.\n\nFor a more complete list, refer to [Wikipedia - List of Mathematical Symbols](https://en.wikipedia.org/wiki/List_of_mathematical_symbols). \n\nFor simplicity, many of the code examples here operate on floating point values and are not numerically robust. For more details on why this may be a problem, see [Robust Arithmetic Notes](https://github.com/mikolalysenko/robust-arithmetic-notes) by Mikola Lysenko.\n\n# contents\n\n- [variable name conventions](#variable-name-conventions)\n- [equals `=` `\u2248` `\u2260` `:=`](#equals-symbols)\n- [square root and complex numbers `\u221a` *`i`*](#square-root-and-complex-numbers)\n- [dot & cross `\u00b7` `\u00d7` `\u2218`](#dot--cross)\n  - [scalar multiplication](#scalar-multiplication)\n  - [vector multiplication](#vector-multiplication)\n  - [dot product](#dot-product)\n  - [cross product](#cross-product)\n- [sigma `\u03a3`](#sigma) - *summation*\n- [capital Pi `\u03a0`](#capital-pi) - *products of sequences*\n- [pipes `||`](#pipes)\n  - [absolute value](#absolute-value)\n  - [Euclidean norm](#euclidean-norm)\n  - [determinant](#determinant)\n- [hat **`\u00e2`**](#hat) - *unit vector*\n- [\"element of\" `\u2208` `\u2209`](#element)\n- [common number sets `\u211d` `\u2124` `\u211a` `\u2115`](#common-number-sets)\n- [function `\u0192`](#function)\n  - [piecewise function](#piecewise-function)\n  - [common functions](#common-functions)\n  - [function notation `\u21a6` `\u2192`](#function-notation)\n- [prime `\u2032`](#prime)\n- [floor & ceiling `\u230a` `\u2309`](#floor--ceiling)\n- [arrows](#arrows)\n  - [material implication `\u21d2` `\u2192`](#material-implication)\n  - [equality `<` `\u2265` `\u226b`](#equality)\n  - [conjunction & disjunction `\u2227` `\u2228`](#conjunction--disjunction)\n- [logical negation `\u00ac` `~` `!`](#logical-negation)\n- [intervals](#intervals)\n- [more...](#more)\n\n## variable name conventions\n\nThere are a variety of naming conventions depending on the context and field of study, and they are not always consistent. However, in some of the literature you may find variable names to follow a pattern like so:\n\n- *s* - italic lowercase letters for scalars (e.g. a number)\n- **x** - bold lowercase letters for vectors (e.g. a 2D point)\n- **A** - bold uppercase letters for matrices (e.g. a 3D transformation)\n- *\u03b8* - italic lowercase Greek letters for constants and special variables (e.g. [polar angle *\u03b8*, *theta*](https://en.wikipedia.org/wiki/Spherical_coordinate_system))\n\nThis will also be the format of this guide.\n\n## equals symbols\n\nThere are a number of symbols resembling the equals sign `=`. Here are a few common examples:\n\n- `=` is for equality (values are the same)\n- `\u2260` is for inequality (value are not the same)\n- `\u2248` is for approximately equal to (`\u03c0 \u2248 3.14159`)\n- `:=` is for definition (A is defined as B)\n\nIn JavaScript:\n\n```js\n// equality\n2 === 3\n\n// inequality\n2 !== 3\n\n// approximately equal\nalmostEqual(Math.PI, 3.14159, 1e-5)\n\nfunction almostEqual(a, b, epsilon) {\n  return Math.abs(a - b) <= epsilon\n}\n```\n\nYou might see the `:=`, `=:` and `=` symbols being used for *definition*.<sup>[1]</sup>\n\nFor example, the following defines *x* to be another name for 2*kj*.\n\n![equals1](http://latex.codecogs.com/svg.latex?x%20%3A%3D%202kj)\n\n<!-- x := 2kj -->\n\nIn JavaScript, we might use `var` to *define* our variables and provide aliases:\n\n```js\nvar x = 2 * k * j\n```\n\nHowever, this is mutable, and only takes a snapshot of the values at that time. Some languages have pre-processor `#define` statements, which are closer to a mathematical *define*. \n\nA more accurate *define* in JavaScript (ES6) might look a bit like this:\n\n```js\nconst f = (k, j) => 2 * k * j\n```\n\nThe following, on the other hand, represents equality:\n\n![equals2](http://latex.codecogs.com/svg.latex?x%20%3D%202kj)\n\n<!-- x = 2kj -->\n\nThe above equation might be interpreted in code as an [assertion](https://developer.mozilla.org/en-US/docs/Web/API/console/assert):\n\n```js\nconsole.assert(x === (2 * k * j))\n```\n\n## square root and complex numbers\n\nA square root operation is of the form:\n\n![squareroot](http://latex.codecogs.com/svg.latex?%5Cleft%28%5Csqrt%7Bx%7D%5Cright%29%5E2%20%3D%20x)\n\n<!-- \\left(\\sqrt{x}\\right)^2 = x -->\n\nIn programming we use a `sqrt` function, like so: \n\n```js\nvar x = 9;\nconsole.log(Math.sqrt(x));\n//=> 3\n```\n\nComplex numbers are expressions of the form ![complex](http://latex.codecogs.com/svg.latex?a&space;&plus;&space;ib), where ![a](http://latex.codecogs.com/svg.latex?a) is the real part and ![b](http://latex.codecogs.com/svg.latex?b) is the imaginary part. The imaginary number ![i](http://latex.codecogs.com/svg.latex?i) is defined as:\n\n![imaginary](http://latex.codecogs.com/svg.latex?i%3D%5Csqrt%7B-1%7D).\n<!-- i=\\sqrt{-1} -->\n\nIn JavaScript, there is no built-in functionality for complex numbers, but there are some libraries that support complex number arithmetic. For example, using [mathjs](https://www.npmjs.com/package/mathjs):\n\n```js\nvar math = require('mathjs')\n\nvar a = math.complex(3, -1)\n//=> { re: 3, im: -1 }\n\nvar b = math.sqrt(-1)\n//=> { re: 0, im: 1 }\n\nconsole.log(math.multiply(a, b).toString())\n//=> '1 + 3i'\n```\n\nThe library also supports evaluating a string expression, so the above could be re-written as:\n\n```js\nconsole.log(math.eval('(3 - i) * i').toString())\n//=> '1 + 3i'\n```\n\nOther implementations:\n\n- [immutable-complex](https://www.npmjs.com/package/immutable-complex)\n- [complex-js](https://www.npmjs.com/package/complex-js)\n- [Numeric-js](http://www.numericjs.com/)\n\n## dot & cross\n\nThe dot `\u00b7` and cross `\u00d7` symbols have different uses depending on context.\n\nThey might seem obvious, but it's important to understand the subtle differences before we continue into other sections.\n\n#### scalar multiplication\n\nBoth symbols can represent simple multiplication of scalars. The following are equivalent:\n\n![dotcross1](http://latex.codecogs.com/svg.latex?5%20%5Ccdot%204%20%3D%205%20%5Ctimes%204)\n\n<!-- 5 \\cdot 4 = 5 \\times 4 -->\n\nIn programming languages we tend to use asterisk for multiplication:\n\n```js\nvar result = 5 * 4\n```\n\nOften, the multiplication sign is only used to avoid ambiguity (e.g. between two numbers). Here, we can omit it entirely:\n\n![dotcross2](http://latex.codecogs.com/svg.latex?3kj)\n\n<!-- 3kj -->\n\nIf these variables represent scalars, the code would be:\n\n```js\nvar result = 3 * k * j\n```\n\n#### vector multiplication\n\nTo denote multiplication of one vector with a scalar, or element-wise multiplication of a vector with another vector, we typically do not use the dot `\u00b7` or cross `\u00d7` symbols. These have different meanings in linear algebra, discussed shortly.\n\nLet's take our earlier example but apply it to vectors. For element-wise vector multiplication, you might see an open dot `\u2218` to represent the [Hadamard product](https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29).<sup>[2]</sup>\n\n![dotcross3](http://latex.codecogs.com/svg.latex?3%5Cmathbf%7Bk%7D%5Ccirc%5Cmathbf%7Bj%7D)\n\n<!-- 3\\mathbf{k}\\circ\\mathbf{j} -->\n\nIn other instances, the author might explicitly define a different notation, such as a circled dot `\u2299` or a filled circle `\u25cf`.<sup>[3]</sup>\n\nHere is how it would look in code, using arrays `[x, y]` to represent the 2D vectors.\n\n```js\nvar s = 3\nvar k = [ 1, 2 ]\nvar j = [ 2, 3 ]\n\nvar tmp = multiply(k, j)\nvar result = multiplyScalar(tmp, s)\n//=> [ 6, 18 ]\n```\n\nOur `multiply` and `multiplyScalar` functions look like this:\n\n```js\nfunction multiply(a, b) {\n  return [ a[0] * b[0], a[1] * b[1] ]\n}\n\nfunction multiplyScalar(a, scalar) {\n  return [ a[0] * scalar, a[1] * scalar ]\n}\n```\n\nSimilarly, matrix multiplication typically does not use the dot `\u00b7` or cross symbol `\u00d7`. Matrix multiplication will be covered in a later section.\n\n#### dot product\n\nThe dot symbol `\u00b7` can be used to denote the [*dot product*](https://en.wikipedia.org/wiki/Dot_product) of two vectors. Sometimes this is called the *scalar product* since it evaluates to a scalar.\n\n![dotcross4](http://latex.codecogs.com/svg.latex?%5Cmathbf%7Bk%7D%5Ccdot%20%5Cmathbf%7Bj%7D)\n\n<!-- \\mathbf{k}\\cdot \\mathbf{j} -->\n\nIt is a very common feature of linear algebra, and with a 3D vector it might look like this:\n\n```js\nvar k = [ 0, 1, 0 ]\nvar j = [ 1, 0, 0 ]\n\nvar d = dot(k, j)\n//=> 0\n```\n\nThe result `0` tells us our vectors are perpendicular. Here is a `dot` function for 3-component vectors:\n\n```js\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n```\n\n#### cross product\n\nThe cross symbol `\u00d7` can be used to denote the [*cross product*](https://en.wikipedia.org/wiki/Cross_product) of two vectors.\n\n![dotcross5](http://latex.codecogs.com/svg.latex?%5Cmathbf%7Bk%7D%5Ctimes%20%5Cmathbf%7Bj%7D)\n\n<!-- \\mathbf{k}\\times \\mathbf{j} -->\n\nIn code, it would look like this:\n\n```js\nvar k = [ 0, 1, 0 ]\nvar j = [ 1, 0, 0 ]\n\nvar result = cross(k, j)\n//=> [ 0, 0, -1 ]\n```\n\nHere, we get `[ 0, 0, -1 ]`, which is perpendicular to both **k** and **j**.\n\nOur `cross` function:\n\n```js\nfunction cross(a, b) {\n  var ax = a[0], ay = a[1], az = a[2],\n    bx = b[0], by = b[1], bz = b[2]\n\n  var rx = ay * bz - az * by\n  var ry = az * bx - ax * bz\n  var rz = ax * by - ay * bx\n  return [ rx, ry, rz ]\n}\n```\n\nFor other implementations of vector multiplication, cross product, and dot product:\n\n- [gl-vec3](https://github.com/stackgl/gl-vec3)\n- [gl-vec2](https://github.com/stackgl/gl-vec2)\n- [vectors](https://github.com/hughsk/vectors) - includes n-dimensional\n\n## sigma \n\nThe big Greek `\u03a3` (Sigma) is for [Summation](https://en.wikipedia.org/wiki/Summation). In other words: summing up some numbers.\n\n![sigma](http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B100%7Di)\n\n<!-- \\sum_{i=1}^{100}i -->\n\nHere, `i=1` says to start at `1` and end at the number above the Sigma, `100`. These are the lower and upper bounds, respectively. The *i* to the right of the \"E\" tells us what we are summing. In code:\n\n```js\nvar sum = 0\nfor (var i = 1; i <= 100; i++) {\n  sum += i\n}\n```\n\nThe result of `sum` is `5050`.\n\n**Tip:** With whole numbers, this particular pattern can be optimized to the following:\n\n```js\nvar n = 100 // upper bound\nvar sum = (n * (n + 1)) / 2\n```\n\nHere is another example where the *i*, or the \"what to sum,\" is different:\n\n![sum2](http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B100%7D%282i&plus;1%29)\n\n<!-- \\sum_{i=1}^{100}(2i+1) -->\n\nIn code:\n\n```js\nvar sum = 0\nfor (var i = 1; i <= 100; i++) {\n  sum += (2 * i + 1)\n}\n```\n\nThe result of `sum` is `10200`.\n\nThe notation can be nested, which is much like nesting a `for` loop. You should evaluate the right-most sigma first, unless the author has enclosed them in parentheses to alter the order. However, in the following case, since we are dealing with finite sums, the order does not matter.\n\n![sigma3](http://latex.codecogs.com/svg.latex?%5Csum_%7Bi%3D1%7D%5E%7B2%7D%5Csum_%7Bj%3D4%7D%5E%7B6%7D%283ij%29)\n\n<!-- \\sum_{i=1}^{2}\\sum_{j=4}^{6}(3ij) -->\n\nIn code:\n\n```js\nvar sum = 0\nfor (var i = 1; i <= 2; i++) {\n  for (var j = 4; j <= 6; j++) {\n    sum += (3 * i * j)\n  }\n}\n```\n\nHere, `sum` will be `135`.\n\n## capital Pi\n\nThe capital Pi or \"Big Pi\" is very similar to [Sigma](#sigma), except we are using multiplication to find the product of a sequence of values. \n\nTake the following:\n\n![capitalPi](http://latex.codecogs.com/svg.latex?%5Cprod_%7Bi%3D1%7D%5E%7B6%7Di)\n\n<!-- \\prod_{i=1}^{6}i -->\n\nIn code, it might look like this:\n\n```js\nvar value = 1\nfor (var i = 1; i <= 6; i++) {\n  value *= i\n}\n```\n\nWhere `value` will evaluate to `720`.\n\n## pipes\n\nPipe symbols, known as *bars*, can mean different things depending on the context. Below are three common uses: [absolute value](#absolute-value), [Euclidean norm](#euclidean-norm), and [determinant](#determinant).\n\nThese three features all describe the *length* of an object.\n\n#### absolute value \n\n![pipes1](http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%20x%20%5Cright%20%7C)\n\n<!-- \\left | x \\right | -->\n\nFor a number *x*, `|x|` means the absolute value of *x*. In code:\n\n```js\nvar x = -5\nvar result = Math.abs(x)\n// => 5\n```\n\n#### Euclidean norm\n\n![pipes4](http://latex.codecogs.com/svg.latex?%5Cleft%20%5C%7C%20%5Cmathbf%7Bv%7D%20%5Cright%20%5C%7C)\n\n<!-- \\left \\| \\mathbf{v} \\right \\| -->\n\nFor a vector **v**, `\u2016v\u2016` is the [Euclidean norm](https://en.wikipedia.org/wiki/Norm_%28mathematics%29#Euclidean_norm) of **v**. It is also referred to as the \"magnitude\" or \"length\" of a vector.\n\nOften this is represented by double-bars to avoid ambiguity with the *absolute value* notation, but sometimes you may see it with single bars:\n\n![pipes2](http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%20%5Cmathbf%7Bv%7D%20%5Cright%20%7C)\n\n<!-- \\left | \\mathbf{v} \\right | -->\n\nHere is an example using an array `[x, y, z]` to represent a 3D vector.\n\n```js\nvar v = [ 0, 4, -3 ]\nlength(v)\n//=> 5\n```\n\nThe `length` function:\n\n```js\nfunction length (vec) {\n  var x = vec[0]\n  var y = vec[1]\n  var z = vec[2]\n  return Math.sqrt(x * x + y * y + z * z)\n}\n```\n\nOther implementations:\n\n- [magnitude](https://github.com/mattdesl/magnitude/blob/864ff5a7eb763d34bf154ac5f5332d7601192b70/index.js) - n-dimensional\n- [gl-vec2/length](https://github.com/stackgl/gl-vec2/blob/21f460a371540258521fd2f720d80f14e87bd400/length.js) - 2D vector\n- [gl-vec3/length](https://github.com/stackgl/gl-vec3/blob/507480fa57ba7c5fb70679cf531175a52c48cf53/length.js) - 3D vector\n\n#### determinant\n\n![pipes3](http://latex.codecogs.com/svg.latex?%5Cleft%20%7C%5Cmathbf%7BA%7D%20%5Cright%20%7C)\n\n<!-- \\left |\\mathbf{A}  \\right | -->\n\nFor a matrix **A**, `|A|` means the [determinant](https://en.wikipedia.org/wiki/Determinant) of matrix **A**.\n\nHere is an example computing the determinant of a 2x2 matrix, represented by a flat array in column-major format.\n\n```js\nvar determinant = require('gl-mat2/determinant')\n\nvar matrix = [ 1, 0, 0, 1 ]\nvar det = determinant(matrix)\n//=> 1\n```\n\nImplementations:\n\n- [gl-mat4/determinant](https://github.com/stackgl/gl-mat4/blob/c2e2de728fe7eba592f74cd02266100cc21ec89a/determinant.js) - also see [gl-mat3](https://github.com/stackgl/gl-mat3) and [gl-mat2](https://github.com/stackgl/gl-mat2)\n- [ndarray-determinant](https://www.npmjs.com/package/ndarray-determinant)\n- [glsl-determinant](https://www.npmjs.com/package/glsl-determinant)\n- [robust-determinant](https://www.npmjs.com/package/robust-determinant)\n- [robust-determinant-2](https://www.npmjs.com/package/robust-determinant-2) and [robust-determinant-3](https://www.npmjs.com/package/robust-determinant-3), specifically for 2x2 and 3x3 matrices, respectively\n\n## hat\n\nIn geometry, the \"hat\" symbol above a character is used to represent a [unit vector](https://en.wikipedia.org/wiki/Unit_vector). For example, here is the unit vector of **a**:\n\n![hat](http://latex.codecogs.com/svg.latex?%5Chat%7B%5Cmathbf%7Ba%7D%7D)\n\n<!-- \\hat{\\mathbf{a}} -->\n\nIn Cartesian space, a unit vector is typically length 1. That means each part of the vector will be in the range of -1.0 to 1.0. Here we *normalize* a 3D vector into a unit vector:\n\n```js\nvar a = [ 0, 4, -3 ]\nnormalize(a)\n//=> [ 0, 0.8, -0.6 ]\n```\n\nHere is the `normalize` function, operating on 3D vectors:\n\n```js\nfunction normalize(vec) {\n  var x = vec[0]\n  var y = vec[1]\n  var z = vec[2]\n  var squaredLength = x * x + y * y + z * z\n\n  if (squaredLength > 0) {\n    var length = Math.sqrt(squaredLength)\n    vec[0] = x / length\n    vec[1] = y / length\n    vec[2] = z / length\n  }\n  return vec\n}\n```\n\nOther implementations:\n\n- [gl-vec3/normalize](https://github.com/stackgl/gl-vec3/blob/507480fa57ba7c5fb70679cf531175a52c48cf53/normalize.js) and [gl-vec2/normalize](https://github.com/stackgl/gl-vec2/blob/21f460a371540258521fd2f720d80f14e87bd400/normalize.js)\n- [vectors/normalize-nd](https://github.com/hughsk/vectors/blob/master/normalize-nd.js) (n-dimensional)\n\n## element\n\nIn set theory, the \"element of\" symbol `\u2208` and `\u220b` can be used to describe whether something is an element of a *set*. For example:\n\n![element1](http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%203%20%5Cin%20A)\n\n<!-- A=\\left \\{3,9,14}{  \\right \\}, 3 \\in A -->\n\nHere we have a set of numbers *A* `{ 3, 9, 14 }` and we are saying `3` is an \"element of\" that set. \n\nA simple implementation in ES5 might look like this:\n\n```js\nvar A = [ 3, 9, 14 ]\n\nA.indexOf(3) >= 0\n//=> true\n```\n\nHowever, it would be more accurate to use a `Set` which only holds unique values. This is a feature of ES6.\n\n```js\nvar A = new Set([ 3, 9, 14 ])\n\nA.has(3)\n//=> true\n```\n\nThe backwards `\u220b` is the same, but the order changes:\n\n![element2](http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%20A%20%5Cni%203)\n\n<!-- A=\\left \\{3,9,14}{  \\right \\}, A \\ni 3 -->\n\nYou can also use the \"not an element of\" symbols `\u2209` and `\u220c` like so:\n\n![element3](http://latex.codecogs.com/svg.latex?A%3D%5Cleft%20%5C%7B3%2C9%2C14%7D%7B%20%5Cright%20%5C%7D%2C%206%20%5Cnotin%20A)\n\n<!-- A=\\left \\{3,9,14}{  \\right \\}, 6 \\notin A -->\n\n## common number sets\n\nYou may see some some large [Blackboard](https://en.wikipedia.org/wiki/Blackboard_bold) letters among equations. Often, these are used to describe sets.\n\nFor example, we might describe *k* to be an [element of](#element) the set `\u211d`. \n\n![real](http://latex.codecogs.com/svg.latex?k%20%5Cin%20%5Cmathbb%7BR%7D)\n\n<!-- k \\in \\mathbb{R} -->\n\nListed below are a few common sets and their symbols.\n\n#### `\u211d` real numbers\n\nThe large `\u211d` describes the set of *real numbers*. These include integers, as well as rational and irrational numbers.\n\nJavaScript treats floats and integers as the same type, so the following would be a simple test of our *k* \u2208 \u211d example:\n\n```js\nfunction isReal (k) {\n  return typeof k === 'number' && isFinite(k);\n}\n```\n\n*Note:* Real numbers are also *finite*, as in, *not infinite.*\n\n#### `\u211a` rational numbers\n\nRational numbers are real numbers that can be expressed as a fraction, or *ratio* (like `\u2157`). Rational numbers cannot have zero as a denominator.\n\nThis also means that all integers are rational numbers, since the denominator can be expressed as 1.\n\nAn irrational number, on the other hand, is one that cannot be expressed as a ratio, like \u03c0 (PI). \n\n#### `\u2124` integers\n\nAn integer, i.e. a real number that has no fractional part. These can be positive or negative.\n\nA simple test in JavaScript might look like this:\n\n```js\nfunction isInteger (n) {\n  return typeof n === 'number' && n % 1 === 0\n}\n```\n\n#### `\u2115` natural numbers\n\nA natural number, a positive and non-negative integer. Depending on the context and field of study, the set may or may not include zero, so it could look like either of these:\n\n```js\n{ 0, 1, 2, 3, ... }\n{ 1, 2, 3, 4, ... }\n```\n\nThe former is more common in computer science, for example:\n\n```js\nfunction isNaturalNumber (n) {\n  return isInteger(n) && n >= 0\n}\n```\n\n#### `\u2102` complex numbers\n\nA complex number is a combination of a real and imaginary number, viewed as a co-ordinate in the 2D plane. For more info, see [A Visual, Intuitive Guide to Imaginary Numbers](http://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/).\n\n## function\n\n[Functions](https://en.wikipedia.org/wiki/Function_%28mathematics%29) are fundamental features of mathematics, and the concept is fairly easy to translate into code.\n\nA function relates an input to an output value. For example, the following is a function:\n\n![function1](http://latex.codecogs.com/svg.latex?x%5E%7B2%7D)\n\n<!-- x^{2} -->\n\nWe can give this function a *name*. Commonly, we use `\u0192` to describe a function, but it could be named `A(x)` or anything else.\n\n![function2](http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D)\n\n<!-- f\\left (x  \\right ) = x^{2} -->\n\nIn code, we might name it `square` and write it like this:\n\n```js\nfunction square (x) {\n  return Math.pow(x, 2)\n}\n```\n\nSometimes a function is not named, and instead the output is written.\n\n![function3](http://latex.codecogs.com/svg.latex?y%20%3D%20x%5E%7B2%7D)\n\n<!-- y = x^{2} -->\n\nIn the above example, *x* is the input, the relationship is *squaring*, and *y* is the output.\n\nFunctions can also have multiple parameters, like in a programming language. These are known as *arguments* in mathematics, and the number of arguments a function takes is known as the *arity* of the function.\n\n![function4](http://latex.codecogs.com/svg.latex?f%28x%2Cy%29%20%3D%20%5Csqrt%7Bx%5E2%20&plus;%20y%5E2%7D)\n\n<!-- f(x,y) = \\sqrt{x^2 + y^2} -->\n\nIn code:\n\n```js\nfunction length (x, y) {\n  return Math.sqrt(x * x + y * y)\n}\n```\n\n### piecewise function\n\nSome functions will use different relationships depending on the input value, *x*.\n\nThe following function *\u0192* chooses between two \"sub functions\" depending on the input value.\n\n![piecewise1](http://latex.codecogs.com/svg.latex?f%28x%29%3D%20%5Cbegin%7Bcases%7D%20%5Cfrac%7Bx%5E2-x%7D%7Bx%7D%2C%26%20%5Ctext%7Bif%20%7D%20x%5Cgeq%201%5C%5C%200%2C%20%26%20%5Ctext%7Botherwise%7D%20%5Cend%7Bcases%7D)\n\n<!--    f(x)= \n\\begin{cases}\n    \\frac{x^2-x}{x},& \\text{if } x\\geq 1\\\\\n    0, & \\text{otherwise}\n\\end{cases} -->\n\nThis is very similar to `if` / `else` in code. The right-side conditions are often written as **\"for x < 0\"** or **\"if x = 0\"**. If the condition is true, the function to the left is used.\n\nIn piecewise functions, **\"otherwise\"** and **\"elsewhere\"** are analogous to the `else` statement in code.\n\n```js\nfunction f (x) {\n  if (x >= 1) {\n    return (Math.pow(x, 2) - x) / x\n  } else {\n    return 0\n  }\n}\n```\n\n### common functions\n\nThere are some function names that are ubiquitous in mathematics. For a programmer, these might be analogous to functions \"built-in\" to the language (like `parseInt` in JavaScript).\n\nOne such example is the *sgn* function. This is the *signum* or *sign* function. Let's use [piecewise function](#piecewise-function) notation to describe it:\n\n![sgn](http://latex.codecogs.com/svg.latex?sgn%28x%29%20%3A%3D%20%5Cbegin%7Bcases%7D%20-1%26%20%5Ctext%7Bif%20%7D%20x%20%3C%200%5C%5C%200%2C%20%26%20%5Ctext%7Bif%20%7D%20%7Bx%20%3D%200%7D%5C%5C%201%2C%20%26%20%5Ctext%7Bif%20%7D%20x%20%3E%200%5C%5C%20%5Cend%7Bcases%7D)\n\n<!-- sgn(x) := \n\\begin{cases}\n    -1& \\text{if } x < 0\\\\\n    0, & \\text{if } {x = 0}\\\\\n    1, & \\text{if } x > 0\\\\\n\\end{cases} -->\n\nIn code, it might look like this:\n\n```js\nfunction sgn (x) {\n  if (x < 0) return -1\n  if (x > 0) return 1\n  return 0\n}\n```\n\nSee [signum](https://github.com/scijs/signum) for this function as a module.\n\nOther examples of such functions: *sin*, *cos*, *tan*.\n\n### function notation\n\nIn some literature, functions may be defined with more explicit notation. For example, let's go back to the `square` function we mentioned earlier:\n\n![function2](http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D)\n\n<!-- f\\left (x  \\right ) = x^{2} -->\n\nIt might also be written in the following form:\n\n![mapsto](http://latex.codecogs.com/svg.latex?f%20%3A%20x%20%5Cmapsto%20x%5E2)\n\n<!-- f : x \\mapsto x^2 -->\n\nThe arrow here with a tail typically means \"maps to,\" as in *x maps to x<sup>2</sup>*. \n\nSometimes, when it isn't obvious, the notation will also describe the *domain* and *codomain* of the function. A more formal definition of *\u0192* might be written as:\n\n![funcnot](http://latex.codecogs.com/svg.latex?%5Cbegin%7Balign*%7D%20f%20%3A%26%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5C%5C%20%26x%20%5Cmapsto%20x%5E2%20%5Cend%7Balign*%7D)\n\n<!-- \\begin{align*}\nf :&\\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n&x \\mapsto x^2 \n\\end{align*}\n -->\n\nA function's *domain* and *codomain* is a bit like its *input* and *output* types, respectively. Here's another example, using our earlier *sgn* function, which outputs an integer:\n\n![domain2](http://latex.codecogs.com/svg.latex?sgn%20%3A%20%5Cmathbb%7BR%7D%20%5Crightarrow%20%5Cmathbb%7BZ%7D)\n\n<!-- sgn : \\mathbb{R} \\rightarrow \\mathbb{Z} -->\n\nThe arrow here (without a tail) is used to map one *set* to another.\n\nIn JavaScript and other dynamically typed languages, you might use documentation and/or runtime checks to explain and validate a function's input/output. Example:\n\n```js\n/**\n * Squares a number.\n * @param  {Number} a real number\n * @return {Number} a real number\n */\nfunction square (a) {\n  if (typeof a !== 'number') {\n    throw new TypeError('expected a number')\n  }\n  return Math.pow(a, 2)\n}\n```\n\nSome tools like [flowtype](http://flowtype.org/) attempt to bring static typing into JavaScript.\n\nOther languages, like Java, allow for true method overloading based on the static types of a function's input/output. This is closer to mathematics: two functions are not the same if they use a different *domain*.\n\n## prime\n\nThe prime symbol (`\u2032`) is often used in variable names to describe things which are similar, without giving it a different name altogether. It can describe the \"next value\" after some transformation.\n\nFor example, if we take a 2D point *(x, y)* and rotate it, you might name the result *(x\u2032, y\u2032)*. Or, the *transpose* of matrix **M** might be named **M\u2032**.\n\nIn code, we typically just assign the variable a more descriptive name, like `transformedPosition`.\n\nFor a mathematical [function](#function), the prime symbol often describes the *derivative* of that function. Derivatives will be explained in a future section. Let's take our earlier function:\n\n![function2](http://latex.codecogs.com/svg.latex?f%5Cleft%20%28x%20%5Cright%20%29%20%3D%20x%5E%7B2%7D)\n\n<!-- f\\left (x  \\right ) = x^{2} -->\n\nIts derivative could be written with a prime `\u2032` symbol:\n\n![prime1](http://latex.codecogs.com/svg.latex?f%27%28x%29%20%3D%202x)\n\n<!-- f'(x) = 2x -->\n\nIn code:\n\n```js\nfunction f (x) {\n  return Math.pow(x, 2)\n}\n\nfunction fPrime (x) {\n  return 2 * x\n}\n```\n\nMultiple prime symbols can be used to describe the second derivative *\u0192\u2032\u2032* and third derivative *\u0192\u2032\u2032\u2032*. After this, authors typically express higher orders with roman numerals *\u0192*<sup>IV</sup> or superscript numbers *\u0192*<sup>(n)</sup>.\n\n## floor & ceiling\n\nThe special brackets `\u230ax\u230b` and `\u2308x\u2309` represent the *floor* and *ceil* functions, respectively.\n\n![floor](http://latex.codecogs.com/svg.latex?floor%28x%29%20%3D%20%5Clfloor%20x%20%5Crfloor)\n\n<!-- floor(x) =  \\lfloor x \\rfloor -->\n\n![ceil](http://latex.codecogs.com/svg.latex?ceil%28x%29%20%3D%20%5Clceil%20x%20%5Crceil)\n\n<!-- ceil(x) =  \\lceil x \\rceil -->\n\nIn code:\n\n```js\nMath.floor(x)\nMath.ceil(x)\n```\n\nWhen the two symbols are mixed `\u230ax\u2309`, it typically represents a function that rounds to the nearest integer:\n\n![round](http://latex.codecogs.com/svg.latex?round%28x%29%20%3D%20%5Clfloor%20x%20%5Crceil)\n\n<!-- round(x) =  \\lfloor x \\rceil -->\n\nIn code:\n\n```js\nMath.round(x)\n```\n\n## arrows\n\nArrows are often used in [function notation](#function-notation). Here are a few other areas you might see them.\n\n#### material implication\n\nArrows like `\u21d2` and `\u2192` are sometimes used in logic for *material implication.* That is, if A is true, then B is also true.\n\n![material1](http://latex.codecogs.com/svg.latex?A%20%5CRightarrow%20B)\n\n<!-- A \\Rightarrow B -->\n\nInterpreting this as code might look like this:\n\n```js\nif (A === true) {\n  console.assert(B === true)\n}\n```\n\nThe arrows can go in either direction `\u21d0` `\u21d2`, or both `\u21d4`. When *A \u21d2 B* and *B \u21d2 A*, they are said to be equivalent:\n\n![material-equiv](http://latex.codecogs.com/svg.latex?A%20%5CLeftrightarrow%20B)\n\n<!-- A \\Leftrightarrow B -->\n\n#### equality\n\nIn math, the `<` `>` `\u2264` and `\u2265` are typically used in the same way we use them in code: *less than*, *greater than*, *less than or equal to* and *greater than or equal to*, respectively.\n\n```js\n50 > 2 === true\n2 < 10 === true\n3 <= 4 === true\n4 >= 4 === true\n```\n\nOn rare occasions you might see a slash through these symbols, to describe *not*. As in, *k* is \"not greater than\" *j*.\n\n![ngt](http://latex.codecogs.com/svg.latex?k%20%5Cngtr%20j)\n\n<!-- k \\ngtr j -->\n\nThe `\u226a` and `\u226b` are sometimes used to represent *significant* inequality. That is, *k* is an [order of magnitude](https://en.wikipedia.org/wiki/Order_of_magnitude) larger than *j*.\n\n![orderofmag](http://latex.codecogs.com/svg.latex?k%20%5Cgg%20j)\n\n<!-- k \\gg j -->\n\nIn mathematics, *order of magnitude* is rather specific; it is not just a \"really big difference.\" A simple example of the above:\n\n```js\norderOfMagnitude(k) > orderOfMagnitude(j)\n```\n\nAnd below is our `orderOfMagnitude` function, using [Math.trunc](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc) (ES6).\n\n```js\nfunction log10(n) {\n  // logarithm in base 10\n  return Math.log(n) / Math.LN10\n}\n\nfunction orderOfMagnitude (n) {\n  return Math.trunc(log10(n))\n}\n```\n\n<sup>*Note:* This is not numerically robust.</sup>\n\nSee [math-trunc](https://www.npmjs.com/package/math-trunc) for a ponyfill in ES5.\n\n#### conjunction & disjunction\n\nAnother use of arrows in logic is conjunction `\u2227` and disjunction `\u2228`. They are analogous to a programmer's `AND` and `OR` operators, respectively.\n\nThe following shows conjunction `\u2227`, the logical `AND`.\n\n![and](http://latex.codecogs.com/svg.latex?k%20%3E%202%20%5Cland%20k%20%3C%204%20%5CLeftrightarrow%20k%20%3D%203)\n\n<!-- k > 2 \\land k <  4 \\Leftrightarrow k = 3   -->\n\nIn JavaScript, we use `&&`. Assuming *k* is a natural number, the logic implies that *k* is 3:\n\n```js\nif (k > 2 && k < 4) {\n  console.assert(k === 3)\n}\n```\n\nSince both sides are equivalent `\u21d4`, it also implies the following:\n\n```js\nif (k === 3) {\n  console.assert(k > 2 && k < 4)\n}\n```\n\nThe down arrow `\u2228` is logical disjunction, like the OR operator.\n\n![logic-or](http://latex.codecogs.com/svg.latex?A%20%5Clor%20B)\n\n<!-- A \\lor B -->\n\nIn code:\n\n```js\nA || B\n```\n\n## logical negation\n\nOccasionally, the `\u00ac`, `~` and `!` symbols are used to represent logical `NOT`. For example, *\u00acA* is only true if A is false.\n\nHere is a simple example using the *not* symbol:\n\n![negation](http://latex.codecogs.com/svg.latex?x%20%5Cneq%20y%20%5CLeftrightarrow%20%5Clnot%28x%20%3D%20y%29)\n\n<!-- x \\neq y \\Leftrightarrow \\lnot(x = y) -->\n\nAn example of how we might interpret this in code:\n\n```js\nif (x !== y) {\n  console.assert(!(x === y))\n}\n```\n\n*Note:* The tilde `~` has many different meanings depending on context. For example, *row equivalence* (matrix theory) or *same order of magnitude* (discussed in [equality](#equality)).\n\n## intervals\n\nSometimes a function deals with real numbers restricted to some range of values, such a constraint can be represented using an *interval*\n\nFor example we can represent the numbers between zero and one including/not including zero and/or one as:\n\n- Not including zero or one: ![interval-opened-left-opened-right](http://latex.codecogs.com/svg.latex?%280%2C%201%29)\n\n<!-- (0, 1) -->\n\n- Including zero or but not one: ![interval-closed-left-opened-right](http://latex.codecogs.com/svg.latex?%5B0%2C%201%29)\n\n<!-- [0, 1) -->\n\n- Not including zero but including one: ![interval-opened-left-closed-right](http://latex.codecogs.com/svg.latex?%280%2C%201%5D)\n\n<!-- (0, 1] -->\n\n- Including zero and one: ![interval-closed-left-closed-right](http://latex.codecogs.com/svg.latex?%5B0%2C%201%5D)\n\n<!-- [0, 1] -->\n\nFor example we to indicate that a point `x` is in the unit cube in 3D we say:\n\n![interval-unit-cube](http://latex.codecogs.com/svg.latex?x%20%5Cin%20%5B0%2C%201%5D%5E3)\n\n<!-- x \\in [0, 1]^3 -->\n\nIn code we can represent an interval using a two element 1d array:\n\n```js\nvar nextafter = require('nextafter')\n\nvar a = [nextafter(0, Infinity), nextafter(1, -Infinity)]     // open interval\nvar b = [nextafter(0, Infinity), 1]                           // interval closed on the left \nvar c = [0, nextafter(1, -Infinity)]                          // interval closed on the right\nvar d = [0, 1]                                                // closed interval\n```\n\nIntervals are used in conjunction with set operations:\n\n- *intersection* e.g. ![interval-intersection](http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20%5Ccap%20%5B4%2C%206%5D%20%3D%20%5B4%2C%205%29)\n\n<!-- [3, 5) \\cap [4, 6] = [4, 5) -->\n\n- *union* e.g. ![interval-union](http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20%5Ccup%20%5B4%2C%206%5D%20%3D%20%5B3%2C%206%5D)\n\n<!-- [3, 5) \\cup [4, 6] = [3, 6] -->\n\n- *difference* e.g. ![interval-difference-1](http://latex.codecogs.com/svg.latex?%5B3%2C%205%29%20-%20%5B4%2C%206%5D%20%3D%20%5B3%2C%204%29) and ![interval-difference-2](http://latex.codecogs.com/svg.latex?%5B4%2C%206%5D%20-%20%5B3%2C%205%29%20%3D%20%5B5%2C%206%5D)\n\n<!-- [3, 5) - [4, 6] = [3, 4) -->\n<!-- [4, 6] - [3, 5)  = [5, 6] -->\n\nIn code:\n\n```js\nvar Interval = require('interval-arithmetic')\nvar nextafter = require('nextafter')\n\nvar a = Interval(3, nextafter(5, -Infinity))\nvar b = Interval(4, 6)\n\nInterval.intersection(a, b)\n// {lo: 4, hi: 4.999999999999999}\n\nInterval.union(a, b)\n// {lo: 3, hi: 6}\n\nInterval.difference(a, b)\n// {lo: 3, hi: 3.9999999999999996}\n\nInterval.difference(b, a)\n// {lo: 5, hi: 6}\n```\n\nSee:\n\n- [next-after](https://github.com/scijs/nextafter) \n- [interval-arithmetic](https://github.com/maurizzzio/interval-arithmetic)\n\n## more...\n\nLike this guide? Suggest some [more features](https://github.com/Jam3/math-as-code/issues/1) or send us a Pull Request!\n\n## Contributing\n\nFor details on how to contribute, see [CONTRIBUTING.md](./CONTRIBUTING.md).\n\n## License\n\nMIT, see [LICENSE.md](http://github.com/Jam3/math-as-code/blob/master/LICENSE.md) for details.\n\n[1]: http://mimosa-pudica.net/improved-oren-nayar.html#images\n[2]: http://buzzard.ups.edu/courses/2007spring/projects/million-paper.pdf\n[3]: https://www.math.washington.edu/~morrow/464_12/fft.pdf\n",
        "releases": []
    }
}
{
    "https://api.github.com/repos/aemkei/jsfuck": {
        "forks": 678,
        "watchers": 8262,
        "stars": 8262,
        "languages": {
            "JavaScript": 13601,
            "HTML": 5133
        },
        "commits": [
            "2024-11-15T16:15:26Z",
            "2024-10-29T10:21:56Z",
            "2024-09-02T07:53:50Z",
            "2024-09-01T15:04:03Z",
            "2024-01-05T09:31:33Z",
            "2024-01-04T19:46:03Z",
            "2023-06-01T18:44:26Z",
            "2021-07-23T09:55:49Z",
            "2021-07-16T12:24:43Z",
            "2021-07-16T12:21:29Z",
            "2021-07-16T12:20:50Z",
            "2021-07-16T12:18:12Z",
            "2021-07-16T12:15:38Z",
            "2020-09-10T09:12:54Z",
            "2020-09-10T09:11:02Z",
            "2020-09-09T15:11:27Z",
            "2020-09-02T08:20:51Z",
            "2020-09-02T07:54:34Z",
            "2020-09-02T02:29:31Z",
            "2020-08-31T08:50:24Z",
            "2020-08-31T05:27:10Z",
            "2020-08-30T21:51:03Z",
            "2020-08-28T22:27:55Z",
            "2020-08-28T22:12:41Z",
            "2020-08-28T22:08:43Z",
            "2020-08-28T13:42:30Z",
            "2020-08-28T09:54:10Z",
            "2020-08-28T09:17:51Z",
            "2020-08-28T09:10:12Z",
            "2020-08-28T09:04:21Z"
        ],
        "creation_date": "2012-08-12T15:46:14Z",
        "contributors": 19,
        "topics": [],
        "subscribers": 128,
        "readme": "# JSFuck `[]()!+`\n\nJSFuck is an esoteric and educational programming style based on the atomic parts of JavaScript. It uses only six different characters to write and execute code.\n\nIt does not depend on a browser, so you can even run it on Node.js.\n\nDemo: [jsfuck.com](http://www.jsfuck.com)\n\nBy [@aemkei](https://twitter.com/aemkei) and [friends](https://github.com/aemkei/jsfuck/graphs/contributors).\n\n### Example\n\nThe following source will do an `alert(1)`:\n\n```js\n[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[\n]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]\n])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+\n(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+\n!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![\n]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]\n+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[\n+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!!\n[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![\n]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[\n]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![\n]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(!\n[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])\n[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(\n!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[\n])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()\n```\n\n### Basics\n\n    false       =>  ![]\n    true        =>  !![]\n    undefined   =>  [][[]]\n    NaN         =>  +[![]]\n    0           =>  +[]\n    1           =>  +!+[]\n    2           =>  !+[]+!+[]\n    10          =>  +[[+!+[]]+[+[]]]\n    Array       =>  []\n    Number      =>  +[]\n    String      =>  []+[]\n    Boolean     =>  ![]\n    Function    =>  [][\"filter\"]\n    run         =>  [][\"filter\"][\"constructor\"]( CODE )()\n    eval        =>  [][\"filter\"][\"constructor\"](\"return eval\")()( CODE )\n    window      =>  [][\"filter\"][\"constructor\"](\"return this\")()\n\nSee the full list [here](https://github.com/aemkei/jsfuck/blob/master/jsfuck.js).  \n\n# How it Works\n\n**Note:** Feel free to join the discussion here: https://gitter.im/aemkei/jsfuck\n\n## `[]` \u2013 Brackets\n\nLet's start with the opening and closing brackets and see what is possible here. They are super useful for this project and are considered as a core element because they provide a way to:\n\n1. deal with arrays\n2. access properties and methods.\n\n\n### `[]` \u2013 Array Literals\n\nCreate new arrays:\n\n```js\n[]   // an empty array\n[[]] // an array with one element (another array)\n```\n\n### `[X][i]` \u2013 Array / Object Access\n\n```js\n[][[]] // undefined, same as [][\"\"]\n```\n\nLater we will be able to do this:\n\n```js\n\"abc\"[0]     // get single letter\n[][\"length\"] // get property\n[][\"fill\"]   // get methods\n```\n\n### `[X][0]` - Array wrapping trick\n\nBy wrapping an expression in an array and then getting the element at index zero, we can apply several operators on one expression. This means brackets `[]` can replace parenthesis `()` to isolate expressions:\n\n```js\n          [X][0]           // X\n++[ ++[ ++[X][0] ][0] ][0] // X + 3\n```\n\n## `+` \u2013 Plus Sign\n\nThis symbol is useful, because it allows us to:\n\n1. create numbers\n2. add two values\n3. concatenating strings\n4. create strings\n\nThe current version of JSFuck uses it a lot but we not sure if they are fundamental.\n\n### Cast to Number\n\n```js\n+[] // 0 - the number 0\n```\n\n### Increment Numbers\n\nUsing the array wrapping trick mentioned above:\n\n```js\n++[ 0  ][  0  ] // 1\n++[ [] ][ +[] ] // 1\n```\n\n### Getting `undefined`\n\nGetting an element by index in an empty array will return `undefined`:\n\n```js\n[][   0 ] // undefined\n[][ +[] ] // get first element (undefined)\n[][  [] ] // look for property \"\"\n```\n\n### Getting `NaN`\n\nCasting `undefined` to Number will result in not-a-number:\n\n```js\n+[][[]]    // +undefined = NaN\n```\n\n### Add Numbers\n\n```js\n          1 +           1 // 2\n++[[]][+[]] + ++[[]][+[]] // 2\n```\n\nA shorter way using ++:\n\n```js\n++[          1][  0] // 2\n++[++[[]][  0]][  0] // 2\n++[++[[]][+[]]][+[]] // 2\n```\n\nUsing this technique, we are able to access all digits:\n\n`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`\n\n### `+[]` \u2013 Casting to String\n\nCombining the plus sign and brackets will turn other values into strings:\n\n```js\n  []        +[] // \"\" - empty string\n +[]        +[] // \"0\"\n  [][[]]    +[] // \"undefined\"\n++[][[]]    +[] // \"NaN\"\n++[[]][+[]] +[] // \"1\"\n```\n\n### `\"word\"[i]` \u2013 Get Single Characters\n\nAs we have strings, we can also get single characters:\n\n```js\n  \"undefined\"          [  0] // \"u\"\n[ \"undefined\"    ][  0][  0] // \"u\"\n[  undefined +[] ][+[]][+[]] // \"u\"\n[  [][[]]    +[] ][+[]][+[]] // \"u\"\n```\n\n```js\n  \"undefined\"   [           1 ] // \"n\"\n[[][[]]+[]][+[]][ ++[[]][+[]] ] // \"n\"\n```\n\nSince we have \"NaN\" and \"undefined\", we got the following characters:\n\n`N`,`a`,`d`,`e`,`f`,`i`,`n`,`u`.\n\n## `+` \u2013 Combine Characters\n\nNow we can concat characters to new words.\n\n```js\n// can be written using []+ only:\n\"undefined\"[4] // \"f\"\n\"undefined\"[5] // \"i\"\n\"undefined\"[6] // \"n\"\n\"undefined\"[3] // \"d\"\n\n// combine using +\n\"f\"+\"i\"+\"n\"+\"d\" // \"find\"\n```\n\n## `\"e\"` \u2013 Numbers in exponential notation\n\nAs we have the character \"e\" from \"undefined\", we can use exponential notation to construct very big numbers and get a reference to `Infinity`:\n\n```js\n+(\"1e309\")         //  Infinity\n+(\"1e309\")     +[] // \"Infinity\"\n+(\"11e100\")        //  1.1e+101\n+(\"11e100\")    +[] // \"1.1e+101\"   (gives us `.` and `+`)\n+(\"0.0000001\")     //  1e-7\n+(\"0.0000001\") +[] // \"1e-7\"       (gives us `-`)\n```\n\nResulting chars:\n\n`I`,`f`,`i`,`n`,`t`,`y`,`.`,`+`,`-`.\n\n\n## `[][\"method\"]` \u2013 Access Methods\n\nNewly combinded characters can form method names. These can be accessed using the square brackets notation:\n\n```js\n[][\"f\"+\"i\"+\"n\"+\"d\"] // where \"f\" is the first char of \"false\" and so on\n[][\"find\"]          // same as the dot syntax:\n[] .find\n```\n\n*Note*: With the characters from \"undefined\", \"NaN\" and \"Infinity\", the only method we are able to find in the objects we have is `Array.prototype.find`.\n\n## `method+[]` \u2013 Get Method Definitions\n\nWe can cast a method to a String and get its definition as a String:\n\n```js\n[][\"find\"] +[]\n```\n\nThis will return the following String:\n\n```js\n\"function find() { [native code] }\"\n```\n\n*Note*: String representations of native functions are not part of the ECMAScript standard and differ between browsers. For example, Firefox will output a slightly different string with additional line breaks using `\\n`.\n\nResulting characters:\n\n* `a`,`c`,`d`,`e`,`f`,`i`,`n`,`o`,`t`,`u`,`v`\n* ` `, `{`, `}`, `(`, `)`, `[`,`]`\n\nResulting methods:\n\n* `.concat`\n* `.find`.\n\n## `!` \u2013 Logical NOT operator\n\nThis is the fourth character in the original JSFuck set and used to create booleans.\n\nNote: This symbol could also be replaced by others, like `<` or `=`. See the section \"Alternatives\" below.\n\n### `!X` \u2013 Cast to Boolean\n\nThe logical \"Not\" operator can be used to create booleans `false` and `true`:\n\n```js\n ![] // false\n!![] // true\n```\n\n### `!X+[]` \u2013 Get \"true\" and \"false\"\n\nBooleans can be casted to string:\n\n```js\n ![] +[] // \"false\"\n!![] +[] // \"true\"\n```\n\nThis will give us access to more characters:\n\n`a`, `e`, `f`, `l`, `r`, `s`, `t`, `u`.\n\nTogether with the set above, we will have `{}()[]+. INacdefilnorstuvy` with access to these methods:\n\n* `call`\n* `concat`\n* `constructor`\n* `entries`\n* `every`\n* `fill`\n* `filter`\n* `find`\n* `fontcolor`\n* `includes`\n* `italics`\n* `reduce`\n* `reverse`\n* `slice`\n* `sort`\n\n*Important:* We might use another symbols like `=` to create booleans, because they are more powerful (see section \"Alternatives\" below).\n\n## `X[\"constructor\"]` \u2013 Primitive wrappers names\n\nWith `.constructor` we have a reference to the function that created the instance. For primitives values, it returns the corresponding built-in wrappers:\n\n```js\n0       [\"constructor\"] // Number\n\"\"      [\"constructor\"] // String\n[]      [\"constructor\"] // Array\nfalse   [\"constructor\"] // Boolean\n[].find [\"constructor\"] // Function\n```\n\nUse `+[]` to convert them to strings and retrieve their function name in order to get more chars:\n\n```js\n0[\"constructor\"]+[] // \"function Number() { ... }\"\n```\n\nNew chars available :\n`m`, `b`, `S`, `g`, `B`, `A`, `F`.\n\n\u2026 and more methods and properties:\n\n* `arguments`\n* `big`\n* `bind`\n* `bold`\n* `name`\n* `small`\n* `some`\n* `sub`\n* `substr`\n* `substring`\n* `toString`\n* `trim`\n\n\n## `()` \u2013 Parenthesis\n\n### Calling Methods\n\nSince we have access to methods, we can call them to get more power. To do this we need to introduce two more symbols `(` and `)` here.\n\nExample without arguments:\n\n```js\n\"\"[\"fontcolor\"]()   // \"<font color=\"undefined\"></font>\"\n[][\"entries\"]() +[] // \"[object Array Iterator]\"\n```\n\nNew characters:\n\n`j`, `<`, `>`, `=`, `\"`, `/`\n\n### Calling method with more than one argument\n\nCalling a method with more than one argument is non trivial - to do it you can use the following [technique](https://stackoverflow.com/q/63601330/860099) (discovered by trincot) - for example: \n\ncalling string method `\"truefalse\".replace(\"true\",\"1\")` can be written as `[\"true\", \"1\"].reduce(\"\".replace.bind(\"truefalse\"))` and finally:\n\n```js\n[\"true\"][\"concat\"](\"1\")[\"reduce\"](\"\"[\"replace\"][\"bind\"](\"truefalse\"))\n```\n\ncalling array method `[1,2,3].slice(1,2)` can be written as `[1,2].reduce([].slice.bind([1,2,3]))` and finally:\n\n```js\n[1][\"concat\"](2)[\"reduce\"]([][\"slice\"][\"bind\"]([1,2,3]))\n```\n\n\n### Calling string method with more than one argument in \"flow way\"\n\nTo be able to call a method (with multiple arguments) in right side on results of previous method you can use this [technique](https://stackoverflow.com/q/63604058/860099) (discovered by trincot) - for example: `\"truefalse\".replace(\"true\",\"1\").replace(\"false\",\"0\")` can be written as \n\n```js\n\"truefalse\"\n    .split().concat([[\"true\", \"1\"]]).reduce(\"\".replace.apply.bind(\"\".replace))\n    .split().concat([[\"false\", \"0\"]]).reduce(\"\".replace.apply.bind(\"\".replace))\n``` \n\nand finally:\n\n```js\n\"truefalse\"\n  [\"split\"]()[\"concat\"]([[\"true\"][\"concat\"](\"1\")])[\"reduce\"](\"\"[\"replace\"][\"apply\"][\"bind\"](\"\"[\"replace\"]))\n  [\"split\"]()[\"concat\"]([[\"false\"][\"concat\"](\"0\")])[\"reduce\"](\"\"[\"replace\"][\"apply\"][\"bind\"](\"\"[\"replace\"]))\n\n```\n\n### Calling array method with more than one argument in \"flow way\"\n\nTo call array methods in righthand side (flow) way\" we use similar technique like for strings but with additional tricks (details [here](https://stackoverflow.com/q/63631908/860099)) presented in following example: `[3,4,5].slice(1,2).concat(6)` can be written as `[[3,4,5]].concat([[1,2]]).reduce([].slice.apply.bind([].slice)).concat(6)` (similar like for strings) but now we need to find right-hand side way to wrap array `[3,4,5]` and get `[[3,4,5]]` which can be done as follows `[3,4,5].map([].constructor).concat([[[]]])[0].slice(-1)` so we get\n\n```js\n[3,4,5]\n    // call: slice(1,2) \n    .map([].constructor).concat([[[]]])[0].slice(-1)\n    .concat([[1,2]]).reduce([].slice.apply.bind([].slice))\n    // call next method (in flow)\n    .concat(6) \n```\nand finally (after remove dots and commas)\n\n```js\n[3][\"concat\"](4)[\"concat\"](5)\n    [\"map\"]([][\"constructor\"])[\"concat\"]([[[]]])[0][\"slice\"](-1)\n    [\"concat\"]([[1][\"concat\"](2)])[\"reduce\"]([][\"slice\"][\"apply\"][\"bind\"]([][\"slice\"]))\n    [\"concat\"](6) \n```\n\n\n\n### `number.toString(x)` \u2013 Getting any lowercase letter\n\nNumber's `toString` method has an optional argument specifying the base to use (between 2 and 36). With base 36 we can retrieve any *lowercase* letter:\n\n```js\n10[\"toString\"](36) // \"a\"\n11[\"toString\"](36) // \"b\"\n...\n34[\"toString\"](36) // \"y\"\n35[\"toString\"](36) // \"z\"\n```\nExposed characters: `abcdefghijklmnopqrstuvwxyz`\n\n### `Function(\"code\")()` \u2013 Evaluate Code\n\nThe Function constructor is the master key in JSFuck: It takes a String as an argument and returns a new anonymous function with this string as the function body. So it basically lets you evaluate any code as a String. This is like `eval`, without the need for a reference to the global scope (a.k.a. `window`). We can get the Function constructor e.g. with `[][\"find\"][\"constructor\"]`.\n\nThis is the first major step and an essential part of a JS-to-JSFuck compiler.\n...\n\n### `Function(\"return this\")()` \u2013 window\n\nWhen evaluating `function anonymous() { return this }`, we get the invocation context which is a reference to the global scope here: `window`!\n\nGetting a reference to `window` is another huge step forward for JSFuck. With the brackets characters, we could only dig in the available objects: numbers, arrays, some functions... With a reference to the global scope, we now have access to any global variable and the inner properties of these globals.\n\n### Create regular expression object\n\nYou can create regular expression e.g. `/pattern/g` as follows\n\n```js\n[][\"fill\"][\"constructor\"](\"return RegExp\")()(\"pattern\",\"g\")\n```\n\nwhich after removing the comma (by using [multi-arguments technique](#calling-method-with-more-than-one-argument) without `bind`ing) looks as follows\n\n```js\n[\"pattern\"][\"concat\"](\"g\")[\"reduce\"]([][\"fill\"][\"constructor\"](\"return RegExp\")())\n```\n\n---\n\n# Alternatives\n\n\n## Combine Characters\n\nInstead of `+` we could use `.concat` to combine strings:\n\n```js\n\"f\"[\"concat\"](\"i\")[\"concat\"](\"l\")[\"concat\"](\"l\") // fill\n```\n\nProblem: We need to combine \"c\", \"o\", \"n\", \"c\", \"a\" and \"t\" to get \"concat\".\n\n## Booleans\n\nThe `!` might be replaced with more \"powerful\" characters that have more than one use.\n\n### `=` \u2013 Boolean + Assign Values\n\n```js\nX == X // true\nX == Y // false\nX = Y  // assign a new value\n```\n\n### `>` \u2013 Boolean + Create Numbers\n\n```js\nX > Y  // true\nX > X  // false\nX >> Y // number\n```\n\nA more complex example is to get character \"f\" with `[]>+` only:\n\n```js\n[[ []>[] ] + [] ] [[]>>[]] [[]>>[]]\n[[ false ] + [] ] [     0] [     0]\n[ \"false\"       ] [     0] [     0]\n  \"false\"                  [     0]\n```\n\n## Numbers\n\nInstead of `+` we could use booleans and bitshift operators to create numbers:\n\n```js\ntrue >> false         // 1\ntrue << true          // 2\ntrue << true << true  // 4\n```\n\nProblem: Some number (like `5`) are harder to get. But it is possible when using strings, eg `\"11\" >> true`.\n\n## Execute Functions\n\nWays of executing functions other than using `()`:\n\n1. using backticks: `` ` ``\n2. handle events: `on...`\n3. constructor: `new ...`\n4. type conversion: `toString|valueOf`\n5. symbol datatype: `[Symbol...]`\n\n### Using Backticks\n\nInstead of using opening and closing parentheses, we could use backticks ` to execute functions. In ES6 they can be used to interpolate strings and serve an expression for tagged template literals.\n\n```js\n([][\"entries\"]``).constructor // Object\n```\n\nThis would give us characters from \"Object\" and access to its methods.\n\nUnfortunately, we can only pass a single string (from our basic alphabet eg. `[]!+`) as the parameter. It is not possible to call methods with multiple arguments or a precompiled string. To do that, we have to use expression interpolation using `${}` which would introduce new characters.\n\nThe possibilities of backticks were discussed in detail [in the Gitter chat room](https://gitter.im/aemkei/jsfuck).\n\n### Mapping Type Conversion\n\nAnother approach to execute functions without parentheses would be to map the `.toString` or `.valueOf` method and call them implicitly.\n\n```js\nA = []\nA[\"toString\"] = A[\"pop\"]\nA+\"\" // will execute A.pop\n```\n\nNote: There is no way to pass arguments and it requires to `=` be present in our basic alphabet. And it only works for methods that return basic types.\n\nSo far the only use-case is to wire `.toSource` in Firefox to get special characters like the backslash `\\`.\n\n### Trigger Event Handler\n\nFunction or methods could also be executed by assinging them to an event hander. There are several ways to do that, e.g:\n\n```js\n// override onload event on start\nonload = f\n\n// write image tags\ndocument.body.innerHTML = '<img onerror=f src=X />'\n\n// throw and handle error\nonerror=f; throw 'x'\n\n// trigger event\nonhashchange = f; location.hash = 1;\n```\n\nNote: We need `=` to assign the handler.\n\nProblem: We do not have access to `window` or DOM elements to attatch the event handlers.\n\n### Constructor\n\nWe could also use the `new` operator to call the function as a pseudo object type:\n\n```js\nnew f\n```\n\nProblem: The `new` operator is not (yet) available with our basic set of symbols.\n\n### Symbol\n\nA symbol is a unique and immutable data type and may be used as an identifier for object properties. This can be used to implicitly call a function.\n\n```js\nf[Symbol.toPrimitive] = f;  f++;\nf[Symbol.iterator]    = f; [...f];\n```\n\nNote: We need `=` to assign the function.\n\nProblem: We do not have access to `Symbol` using our reduced character set.\n\n# Further Readings\n\nJSFuck was not the first approach! Many people around the world are trying to break the so-called \"Wall\". Read more here:\n\n* [Esolang Wiki: JSFuck](https://esolangs.org/wiki/JSFuck)\n* [sla.ckers.org](http://sla.ckers.org/forum/read.php?24,32930) \u2013 Original Discussion\n* [Xchars.js](http://slides.com/sylvainpv/xchars-js/) \u2013 Sylvain Pollet-Villard\n* [Non Alphanumeric JavaScript](http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html) \u2013 Patricio Palladino\n* [Non-alphanumeric code](http://www.businessinfo.co.uk/labs/talk/Nonalpha.pdf) \u2013 Gareth Heyes\n* [Executing non-alphanumeric JavaScript without parenthesis](http://blog.portswigger.net/2016/07/executing-non-alphanumeric-javascript.html) \u2013 Portswigger\n",
        "releases": []
    }
}
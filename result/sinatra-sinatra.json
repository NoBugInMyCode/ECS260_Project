{
    "https://api.github.com/repos/sinatra/sinatra": {
        "forks": 2078,
        "watchers": 12217,
        "stars": 12217,
        "languages": {
            "Ruby": 678606,
            "HTML": 1685,
            "Haml": 605,
            "Slim": 498,
            "Sass": 72,
            "Liquid": 70,
            "SCSS": 36,
            "Stylus": 16
        },
        "commits": [
            "2024-11-20T15:47:22Z",
            "2024-11-19T14:35:55Z",
            "2024-11-18T21:41:05Z",
            "2024-11-18T11:50:26Z",
            "2024-11-18T11:27:41Z",
            "2024-11-18T11:13:31Z",
            "2024-11-08T07:50:38Z",
            "2024-11-07T17:14:49Z",
            "2024-11-07T16:49:02Z",
            "2024-11-07T16:34:43Z",
            "2024-11-07T15:44:56Z",
            "2024-11-07T08:49:02Z",
            "2024-11-07T08:20:11Z",
            "2024-11-07T08:15:17Z",
            "2024-11-07T08:11:37Z",
            "2024-11-07T08:10:08Z",
            "2024-10-20T22:51:08Z",
            "2024-10-20T22:41:28Z",
            "2024-07-11T15:11:08Z",
            "2024-07-11T12:44:11Z",
            "2024-07-11T12:32:32Z",
            "2024-07-11T09:20:57Z",
            "2024-07-10T17:48:34Z",
            "2024-07-11T08:55:51Z",
            "2024-07-10T18:07:37Z",
            "2024-07-10T21:43:48Z",
            "2024-07-11T08:50:14Z",
            "2024-03-27T15:25:35Z",
            "2024-03-27T07:59:24Z",
            "2024-03-27T07:40:24Z"
        ],
        "creation_date": "2009-01-14T01:27:30Z",
        "contributors": 30,
        "topics": [
            "rack",
            "ruby",
            "sinatra",
            "web-framework"
        ],
        "subscribers": 373,
        "readme": "# Sinatra\n\n[![Gem Version](https://badge.fury.io/rb/sinatra.svg)](https://badge.fury.io/rb/sinatra)\n[![Testing](https://github.com/sinatra/sinatra/actions/workflows/test.yml/badge.svg)](https://github.com/sinatra/sinatra/actions/workflows/test.yml)\n\nSinatra is a [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) for\nquickly creating web applications in Ruby with minimal effort:\n\n```ruby\n# myapp.rb\nrequire 'sinatra'\n\nget '/' do\n  'Hello world!'\nend\n```\n\nInstall the gems needed:\n\n```shell\ngem install sinatra rackup puma\n```\n\nAnd run with:\n\n```shell\nruby myapp.rb\n```\n\nView at: [http://localhost:4567](http://localhost:4567)\n\nThe code you changed will not take effect until you restart the server.\nPlease restart the server every time you change or use a code reloader\nlike [rerun](https://github.com/alexch/rerun) or\n[rack-unreloader](https://github.com/jeremyevans/rack-unreloader).\n\nIt is recommended to also run `gem install puma`, which Sinatra will\npick up if available.\n\n## Table of Contents\n\n- [Sinatra](#sinatra)\n  - [Table of Contents](#table-of-contents)\n  - [Routes](#routes)\n  - [Conditions](#conditions)\n  - [Return Values](#return-values)\n  - [Custom Route Matchers](#custom-route-matchers)\n  - [Static Files](#static-files)\n  - [Views / Templates](#views--templates)\n    - [Literal Templates](#literal-templates)\n    - [Available Template Languages](#available-template-languages)\n      - [Haml Templates](#haml-templates)\n      - [Erb Templates](#erb-templates)\n      - [Builder Templates](#builder-templates)\n      - [Nokogiri Templates](#nokogiri-templates)\n      - [Sass Templates](#sass-templates)\n      - [Scss Templates](#scss-templates)\n      - [Liquid Templates](#liquid-templates)\n      - [Markdown Templates](#markdown-templates)\n      - [RDoc Templates](#rdoc-templates)\n      - [AsciiDoc Templates](#asciidoc-templates)\n      - [Markaby Templates](#markaby-templates)\n      - [RABL Templates](#rabl-templates)\n      - [Slim Templates](#slim-templates)\n      - [Yajl Templates](#yajl-templates)\n    - [Accessing Variables in Templates](#accessing-variables-in-templates)\n    - [Templates with `yield` and nested layouts](#templates-with-yield-and-nested-layouts)\n    - [Inline Templates](#inline-templates)\n    - [Named Templates](#named-templates)\n    - [Associating File Extensions](#associating-file-extensions)\n    - [Adding Your Own Template Engine](#adding-your-own-template-engine)\n    - [Using Custom Logic for Template Lookup](#using-custom-logic-for-template-lookup)\n  - [Filters](#filters)\n  - [Helpers](#helpers)\n    - [Using Sessions](#using-sessions)\n      - [Session Secret Security](#session-secret-security)\n      - [Session Config](#session-config)\n      - [Choosing Your Own Session Middleware](#choosing-your-own-session-middleware)\n    - [Halting](#halting)\n    - [Passing](#passing)\n    - [Triggering Another Route](#triggering-another-route)\n    - [Setting Body, Status Code, and Headers](#setting-body-status-code-and-headers)\n    - [Streaming Responses](#streaming-responses)\n    - [Logging](#logging)\n    - [Mime Types](#mime-types)\n    - [Generating URLs](#generating-urls)\n    - [Browser Redirect](#browser-redirect)\n    - [Cache Control](#cache-control)\n    - [Sending Files](#sending-files)\n    - [Accessing the Request Object](#accessing-the-request-object)\n    - [Attachments](#attachments)\n    - [Dealing with Date and Time](#dealing-with-date-and-time)\n    - [Looking Up Template Files](#looking-up-template-files)\n  - [Configuration](#configuration)\n    - [Configuring attack protection](#configuring-attack-protection)\n    - [Available Settings](#available-settings)\n  - [Lifecycle Events](#lifecycle-events)\n  - [Environments](#environments)\n  - [Error Handling](#error-handling)\n    - [Not Found](#not-found)\n    - [Error](#error)\n  - [Rack Middleware](#rack-middleware)\n  - [Testing](#testing)\n  - [Sinatra::Base - Middleware, Libraries, and Modular Apps](#sinatrabase---middleware-libraries-and-modular-apps)\n    - [Modular vs. Classic Style](#modular-vs-classic-style)\n    - [Serving a Modular Application](#serving-a-modular-application)\n    - [Using a Classic Style Application with a config.ru](#using-a-classic-style-application-with-a-configru)\n    - [When to use a config.ru?](#when-to-use-a-configru)\n    - [Using Sinatra as Middleware](#using-sinatra-as-middleware)\n    - [Dynamic Application Creation](#dynamic-application-creation)\n  - [Scopes and Binding](#scopes-and-binding)\n    - [Application/Class Scope](#applicationclass-scope)\n    - [Request/Instance Scope](#requestinstance-scope)\n    - [Delegation Scope](#delegation-scope)\n  - [Command Line](#command-line)\n    - [Multi-threading](#multi-threading)\n  - [Requirement](#requirement)\n  - [The Bleeding Edge](#the-bleeding-edge)\n    - [With Bundler](#with-bundler)\n  - [Versioning](#versioning)\n  - [Further Reading](#further-reading)\n\n## Routes\n\nIn Sinatra, a route is an HTTP method paired with a URL-matching pattern.\nEach route is associated with a block:\n\n```ruby\nget '/' do\n  .. show something ..\nend\n\npost '/' do\n  .. create something ..\nend\n\nput '/' do\n  .. replace something ..\nend\n\npatch '/' do\n  .. modify something ..\nend\n\ndelete '/' do\n  .. annihilate something ..\nend\n\noptions '/' do\n  .. appease something ..\nend\n\nlink '/' do\n  .. affiliate something ..\nend\n\nunlink '/' do\n  .. separate something ..\nend\n```\n\nRoutes are matched in the order they are defined. The first route that\nmatches the request is invoked.\n\nRoutes with trailing slashes are different from the ones without:\n\n```ruby\nget '/foo' do\n  # Does not match \"GET /foo/\"\nend\n```\n\nRoute patterns may include named parameters, accessible via the\n`params` hash:\n\n```ruby\nget '/hello/:name' do\n  # matches \"GET /hello/foo\" and \"GET /hello/bar\"\n  # params['name'] is 'foo' or 'bar'\n  \"Hello #{params['name']}!\"\nend\n```\n\nYou can also access named parameters via block parameters:\n\n```ruby\nget '/hello/:name' do |n|\n  # matches \"GET /hello/foo\" and \"GET /hello/bar\"\n  # params['name'] is 'foo' or 'bar'\n  # n stores params['name']\n  \"Hello #{n}!\"\nend\n```\n\nRoute patterns may also include splat (or wildcard) parameters, accessible\nvia the `params['splat']` array:\n\n```ruby\nget '/say/*/to/*' do\n  # matches /say/hello/to/world\n  params['splat'] # => [\"hello\", \"world\"]\nend\n\nget '/download/*.*' do\n  # matches /download/path/to/file.xml\n  params['splat'] # => [\"path/to/file\", \"xml\"]\nend\n```\n\nOr with block parameters:\n\n```ruby\nget '/download/*.*' do |path, ext|\n  [path, ext] # => [\"path/to/file\", \"xml\"]\nend\n```\n\nRoute matching with Regular Expressions:\n\n```ruby\nget /\\/hello\\/([\\w]+)/ do\n  \"Hello, #{params['captures'].first}!\"\nend\n```\n\nOr with a block parameter:\n\n```ruby\nget %r{/hello/([\\w]+)} do |c|\n  # Matches \"GET /meta/hello/world\", \"GET /hello/world/1234\" etc.\n  \"Hello, #{c}!\"\nend\n```\n\nRoute patterns may have optional parameters:\n\n```ruby\nget '/posts/:format?' do\n  # matches \"GET /posts/\" and any extension \"GET /posts/json\", \"GET /posts/xml\" etc\nend\n```\n\nRoutes may also utilize query parameters:\n\n```ruby\nget '/posts' do\n  # matches \"GET /posts?title=foo&author=bar\"\n  title = params['title']\n  author = params['author']\n  # uses title and author variables; query is optional to the /posts route\nend\n```\n\nBy the way, unless you disable the path traversal attack protection (see\n[below](#configuring-attack-protection)), the request path might be modified before\nmatching against your routes.\n\nYou may customize the [Mustermann](https://github.com/sinatra/mustermann#readme)\noptions used for a given route by passing in a `:mustermann_opts` hash:\n\n```ruby\nget '\\A/posts\\z', :mustermann_opts => { :type => :regexp, :check_anchors => false } do\n  # matches /posts exactly, with explicit anchoring\n  \"If you match an anchored pattern clap your hands!\"\nend\n```\n\nIt looks like a [condition](#conditions), but it isn't one! These options will\nbe merged into the global `:mustermann_opts` hash described\n[below](#available-settings).\n\n## Conditions\n\nRoutes may include a variety of matching conditions, such as the user agent:\n\n```ruby\nget '/foo', :agent => /Songbird (\\d\\.\\d)[\\d\\/]*?/ do\n  \"You're using Songbird version #{params['agent'][0]}\"\nend\n\nget '/foo' do\n  # Matches non-songbird browsers\nend\n```\n\nOther available conditions are `host_name` and `provides`:\n\n```ruby\nget '/', :host_name => /^admin\\./ do\n  \"Admin Area, Access denied!\"\nend\n\nget '/', :provides => 'html' do\n  haml :index\nend\n\nget '/', :provides => ['rss', 'atom', 'xml'] do\n  builder :feed\nend\n```\n`provides` searches the request's Accept header.\n\nYou can easily define your own conditions:\n\n```ruby\nset(:probability) { |value| condition { rand <= value } }\n\nget '/win_a_car', :probability => 0.1 do\n  \"You won!\"\nend\n\nget '/win_a_car' do\n  \"Sorry, you lost.\"\nend\n```\n\nFor a condition that takes multiple values use a splat:\n\n```ruby\nset(:auth) do |*roles|   # <- notice the splat here\n  condition do\n    unless logged_in? && roles.any? {|role| current_user.in_role? role }\n      redirect \"/login/\", 303\n    end\n  end\nend\n\nget \"/my/account/\", :auth => [:user, :admin] do\n  \"Your Account Details\"\nend\n\nget \"/only/admin/\", :auth => :admin do\n  \"Only admins are allowed here!\"\nend\n```\n\n## Return Values\n\nThe return value of a route block determines at least the response body\npassed on to the HTTP client or at least the next middleware in the\nRack stack. Most commonly, this is a string, as in the above examples.\nBut other values are also accepted.\n\nYou can return an object that would either be a valid Rack response, Rack\nbody object or HTTP status code:\n\n* An Array with three elements: `[status (Integer), headers (Hash), response\n  body (responds to #each)]`\n* An Array with two elements: `[status (Integer), response body (responds to\n  #each)]`\n* An object that responds to `#each` and passes nothing but strings to\n  the given block\n* A Integer representing the status code\n\nThat way we can, for instance, easily implement a streaming example:\n\n```ruby\nclass Stream\n  def each\n    100.times { |i| yield \"#{i}\\n\" }\n  end\nend\n\nget('/') { Stream.new }\n```\n\nYou can also use the `stream` helper method ([described below](#streaming-responses)) to reduce\nboilerplate and embed the streaming logic in the route.\n\n## Custom Route Matchers\n\nAs shown above, Sinatra ships with built-in support for using String\npatterns and regular expressions as route matches. However, it does not\nstop there. You can easily define your own matchers:\n\n```ruby\nclass AllButPattern\n  def initialize(except)\n    @except = except\n  end\n\n  def to_pattern(options)\n    return self\n  end\n\n  def params(route)\n    return {} unless @except === route\n  end\nend\n\ndef all_but(pattern)\n  AllButPattern.new(pattern)\nend\n\nget all_but(\"/index\") do\n  # ...\nend\n```\n\nNote that the above example might be over-engineered, as it can also be\nexpressed as:\n\n```ruby\nget /.*/ do\n  pass if request.path_info == \"/index\"\n  # ...\nend\n```\n\n## Static Files\n\nStatic files are served from the `./public` directory. You can specify\na different location by setting the `:public_folder` option:\n\n```ruby\nset :public_folder, __dir__ + '/static'\n```\n\nNote that the public directory name is not included in the URL. A file\n`./public/css/style.css` is made available as\n`http://example.com/css/style.css`.\n\nUse the `:static_cache_control` setting (see [below](#cache-control)) to add\n`Cache-Control` header info.\n\n## Views / Templates\n\nEach template language is exposed via its own rendering method. These\nmethods simply return a string:\n\n```ruby\nget '/' do\n  erb :index\nend\n```\n\nThis renders `views/index.erb`.\n\nInstead of a template name, you can also just pass in the template content\ndirectly:\n\n```ruby\nget '/' do\n  code = \"<%= Time.now %>\"\n  erb code\nend\n```\n\nTemplates take a second argument, the options hash:\n\n```ruby\nget '/' do\n  erb :index, :layout => :post\nend\n```\n\nThis will render `views/index.erb` embedded in the\n`views/post.erb` (default is `views/layout.erb`, if it exists).\n\nAny options not understood by Sinatra will be passed on to the template\nengine:\n\n```ruby\nget '/' do\n  haml :index, :format => :html5\nend\n```\n\nYou can also set options per template language in general:\n\n```ruby\nset :haml, :format => :html5\n\nget '/' do\n  haml :index\nend\n```\n\nOptions passed to the render method override options set via `set`.\n\nAvailable Options:\n\n<dl>\n  <dt>locals</dt>\n  <dd>\n    List of locals passed to the document. Handy with partials.\n    Example: <tt>erb \"<%= foo %>\", :locals => {:foo => \"bar\"}</tt>\n  </dd>\n\n  <dt>default_encoding</dt>\n  <dd>\n    String encoding to use if uncertain. Defaults to\n    <tt>settings.default_encoding</tt>.\n  </dd>\n\n  <dt>views</dt>\n  <dd>\n    Views folder to load templates from. Defaults to <tt>settings.views</tt>.\n  </dd>\n\n  <dt>layout</dt>\n  <dd>\n    Whether to use a layout (<tt>true</tt> or <tt>false</tt>). If it's a\n    Symbol, specifies what template to use. Example:\n    <tt>erb :index, :layout => !request.xhr?</tt>\n  </dd>\n\n  <dt>content_type</dt>\n  <dd>\n    Content-Type the template produces. Default depends on template language.\n  </dd>\n\n  <dt>scope</dt>\n  <dd>\n    Scope to render template under. Defaults to the application\n    instance. If you change this, instance variables and helper methods\n    will not be available.\n  </dd>\n\n  <dt>layout_engine</dt>\n  <dd>\n    Template engine to use for rendering the layout. Useful for\n    languages that do not support layouts otherwise. Defaults to the\n    engine used for the template. Example: <tt>set :rdoc, :layout_engine\n    => :erb</tt>\n  </dd>\n\n  <dt>layout_options</dt>\n  <dd>\n    Special options only used for rendering the layout. Example:\n    <tt>set :rdoc, :layout_options => { :views => 'views/layouts' }</tt>\n  </dd>\n</dl>\n\nTemplates are assumed to be located directly under the `./views`\ndirectory. To use a different views directory:\n\n```ruby\nset :views, settings.root + '/templates'\n```\n\n\nOne important thing to remember is that you always have to reference\ntemplates with symbols, even if they're in a subdirectory (in this case,\nuse: `:'subdir/template'` or `'subdir/template'.to_sym`). You must use a\nsymbol because otherwise rendering methods will render any strings\npassed to them directly.\n\n### Literal Templates\n\n```ruby\nget '/' do\n  haml '%div.title Hello World'\nend\n```\n\nRenders the template string. You can optionally specify `:path` and\n`:line` for a clearer backtrace if there is a filesystem path or line\nassociated with that string:\n\n```ruby\nget '/' do\n  haml '%div.title Hello World', :path => 'examples/file.haml', :line => 3\nend\n```\n\n### Available Template Languages\n\nSome languages have multiple implementations. To specify what implementation\nto use (and to be thread-safe), you should simply require it first:\n\n```ruby\nrequire 'rdiscount'\nget('/') { markdown :index }\n```\n\n#### Haml Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"http://haml.info/\" title=\"haml\">haml</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.haml</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>haml :index, :format => :html5</tt></td>\n  </tr>\n</table>\n\n#### Erb Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td>\n      <a href=\"https://github.com/jeremyevans/erubi\" title=\"erubi\">erubi</a>\n      or erb (included in Ruby)\n    </td>\n  </tr>\n  <tr>\n    <td>File Extensions</td>\n    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubi</tt> (Erubi only)</td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>erb :index</tt></td>\n  </tr>\n</table>\n\n#### Builder Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td>\n      <a href=\"https://github.com/jimweirich/builder\" title=\"builder\">builder</a>\n    </td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.builder</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>builder { |xml| xml.em \"hi\" }</tt></td>\n  </tr>\n</table>\n\nIt also takes a block for inline templates (see [example](#inline-templates)).\n\n#### Nokogiri Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"http://www.nokogiri.org/\" title=\"nokogiri\">nokogiri</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.nokogiri</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>nokogiri { |xml| xml.em \"hi\" }</tt></td>\n  </tr>\n</table>\n\nIt also takes a block for inline templates (see [example](#inline-templates)).\n\n#### Sass Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://github.com/ntkme/sass-embedded-host-ruby\" title=\"sass-embedded\">sass-embedded</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.sass</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>sass :stylesheet, :style => :expanded</tt></td>\n  </tr>\n</table>\n\n#### Scss Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://github.com/ntkme/sass-embedded-host-ruby\" title=\"sass-embedded\">sass-embedded</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.scss</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>scss :stylesheet, :style => :expanded</tt></td>\n  </tr>\n</table>\n\n#### Liquid Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://shopify.github.io/liquid/\" title=\"liquid\">liquid</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.liquid</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>\n  </tr>\n</table>\n\nSince you cannot call Ruby methods (except for `yield`) from a Liquid\ntemplate, you almost always want to pass locals to it.\n\n#### Markdown Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td>\n      Anyone of:\n        <a href=\"https://github.com/davidfstr/rdiscount\" title=\"RDiscount\">RDiscount</a>,\n        <a href=\"https://github.com/vmg/redcarpet\" title=\"RedCarpet\">RedCarpet</a>,\n        <a href=\"https://kramdown.gettalong.org/\" title=\"kramdown\">kramdown</a>,\n        <a href=\"https://github.com/gjtorikian/commonmarker\" title=\"commonmarker\">commonmarker</a>\n        <a href=\"https://github.com/alphabetum/pandoc-ruby\" title=\"pandoc\">pandoc</a>\n    </td>\n  </tr>\n  <tr>\n    <td>File Extensions</td>\n    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>markdown :index, :layout_engine => :erb</tt></td>\n  </tr>\n</table>\n\nIt is not possible to call methods from Markdown, nor to pass locals to it.\nYou therefore will usually use it in combination with another rendering\nengine:\n\n```ruby\nerb :overview, :locals => { :text => markdown(:introduction) }\n```\n\nNote that you may also call the `markdown` method from within other\ntemplates:\n\n```ruby\n%h1 Hello From Haml!\n%p= markdown(:greetings)\n```\n\nSince you cannot call Ruby from Markdown, you cannot use layouts written in\nMarkdown. However, it is possible to use another rendering engine for the\ntemplate than for the layout by passing the `:layout_engine` option.\n\n#### RDoc Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"http://rdoc.sourceforge.net/\" title=\"RDoc\">RDoc</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.rdoc</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>\n  </tr>\n</table>\n\nIt is not possible to call methods from RDoc, nor to pass locals to it. You\ntherefore will usually use it in combination with another rendering engine:\n\n```ruby\nerb :overview, :locals => { :text => rdoc(:introduction) }\n```\n\nNote that you may also call the `rdoc` method from within other templates:\n\n```ruby\n%h1 Hello From Haml!\n%p= rdoc(:greetings)\n```\n\nSince you cannot call Ruby from RDoc, you cannot use layouts written in\nRDoc. However, it is possible to use another rendering engine for the\ntemplate than for the layout by passing the `:layout_engine` option.\n\n#### AsciiDoc Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"http://asciidoctor.org/\" title=\"Asciidoctor\">Asciidoctor</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>\n  </tr>\n</table>\n\nSince you cannot call Ruby methods directly from an AsciiDoc template, you\nalmost always want to pass locals to it.\n\n#### Markaby Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://markaby.github.io/\" title=\"Markaby\">Markaby</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.mab</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>markaby { h1 \"Welcome!\" }</tt></td>\n  </tr>\n</table>\n\nIt also takes a block for inline templates (see [example](#inline-templates)).\n\n#### RABL Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://github.com/nesquena/rabl\" title=\"Rabl\">Rabl</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.rabl</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>rabl :index</tt></td>\n  </tr>\n</table>\n\n#### Slim Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://slim-template.github.io/\" title=\"Slim Lang\">Slim Lang</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.slim</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td><tt>slim :index</tt></td>\n  </tr>\n</table>\n\n#### Yajl Templates\n\n<table>\n  <tr>\n    <td>Dependency</td>\n    <td><a href=\"https://github.com/brianmario/yajl-ruby\" title=\"yajl-ruby\">yajl-ruby</a></td>\n  </tr>\n  <tr>\n    <td>File Extension</td>\n    <td><tt>.yajl</tt></td>\n  </tr>\n  <tr>\n    <td>Example</td>\n    <td>\n      <tt>\n        yajl :index,\n             :locals => { :key => 'qux' },\n             :callback => 'present',\n             :variable => 'resource'\n      </tt>\n    </td>\n  </tr>\n</table>\n\n\nThe template source is evaluated as a Ruby string, and the\nresulting json variable is converted using `#to_json`:\n\n```ruby\njson = { :foo => 'bar' }\njson[:baz] = key\n```\n\nThe `:callback` and `:variable` options can be used to decorate the rendered\nobject:\n\n```javascript\nvar resource = {\"foo\":\"bar\",\"baz\":\"qux\"};\npresent(resource);\n```\n\n### Accessing Variables in Templates\n\nTemplates are evaluated within the same context as route handlers. Instance\nvariables set in route handlers are directly accessible by templates:\n\n```ruby\nget '/:id' do\n  @foo = Foo.find(params['id'])\n  haml '%h1= @foo.name'\nend\n```\n\nOr, specify an explicit Hash of local variables:\n\n```ruby\nget '/:id' do\n  foo = Foo.find(params['id'])\n  haml '%h1= bar.name', :locals => { :bar => foo }\nend\n```\n\nThis is typically used when rendering templates as partials from within\nother templates.\n\n### Templates with `yield` and nested layouts\n\nA layout is usually just a template that calls `yield`.\nSuch a template can be used either through the `:template` option as\ndescribed above, or it can be rendered with a block as follows:\n\n```ruby\nerb :post, :layout => false do\n  erb :index\nend\n```\n\nThis code is mostly equivalent to `erb :index, :layout => :post`.\n\nPassing blocks to rendering methods is most useful for creating nested\nlayouts:\n\n```ruby\nerb :main_layout, :layout => false do\n  erb :admin_layout do\n    erb :user\n  end\nend\n```\n\nThis can also be done in fewer lines of code with:\n\n```ruby\nerb :admin_layout, :layout => :main_layout do\n  erb :user\nend\n```\n\nCurrently, the following rendering methods accept a block: `erb`, `haml`,\n`liquid`, `slim `. Also, the general `render` method accepts a block.\n\n### Inline Templates\n\nTemplates may be defined at the end of the source file:\n\n```ruby\nrequire 'sinatra'\n\nget '/' do\n  haml :index\nend\n\n__END__\n\n@@ layout\n%html\n  != yield\n\n@@ index\n%div.title Hello world.\n```\n\nNOTE: Inline templates defined in the source file that requires Sinatra are\nautomatically loaded. Call `enable :inline_templates` explicitly if you\nhave inline templates in other source files.\n\n### Named Templates\n\nTemplates may also be defined using the top-level `template` method:\n\n```ruby\ntemplate :layout do\n  \"%html\\n  =yield\\n\"\nend\n\ntemplate :index do\n  '%div.title Hello World!'\nend\n\nget '/' do\n  haml :index\nend\n```\n\nIf a template named \"layout\" exists, it will be used each time a template\nis rendered. You can individually disable layouts by passing\n`:layout => false` or disable them by default via\n`set :haml, :layout => false`:\n\n```ruby\nget '/' do\n  haml :index, :layout => !request.xhr?\nend\n```\n\n### Associating File Extensions\n\nTo associate a file extension with a template engine, use\n`Tilt.register`. For instance, if you like to use the file extension\n`tt` for Haml templates, you can do the following:\n\n```ruby\nTilt.register Tilt[:haml], :tt\n```\n\n### Adding Your Own Template Engine\n\nFirst, register your engine with Tilt, then create a rendering method:\n\n```ruby\nTilt.register MyAwesomeTemplateEngine, :myat\n\nhelpers do\n  def myat(*args) render(:myat, *args) end\nend\n\nget '/' do\n  myat :index\nend\n```\n\nRenders `./views/index.myat`. Learn more about\n[Tilt](https://github.com/rtomayko/tilt#readme).\n\n### Using Custom Logic for Template Lookup\n\nTo implement your own template lookup mechanism you can write your\nown `#find_template` method:\n\n```ruby\nconfigure do\n  set :views, [ './views/a', './views/b' ]\nend\n\ndef find_template(views, name, engine, &block)\n  Array(views).each do |v|\n    super(v, name, engine, &block)\n  end\nend\n```\n\n## Filters\n\nBefore filters are evaluated before each request within the same context\nas the routes will be and can modify the request and response. Instance\nvariables set in filters are accessible by routes and templates:\n\n```ruby\nbefore do\n  @note = 'Hi!'\n  request.path_info = '/foo/bar/baz'\nend\n\nget '/foo/*' do\n  @note #=> 'Hi!'\n  params['splat'] #=> 'bar/baz'\nend\n```\n\nAfter filters are evaluated after each request within the same context\nas the routes will be and can also modify the request and response.\nInstance variables set in before filters and routes are accessible by\nafter filters:\n\n```ruby\nafter do\n  puts response.status\nend\n```\n\nNote: Unless you use the `body` method rather than just returning a\nString from the routes, the body will not yet be available in the after\nfilter, since it is generated later on.\n\nFilters optionally take a pattern, causing them to be evaluated only if the\nrequest path matches that pattern:\n\n```ruby\nbefore '/protected/*' do\n  authenticate!\nend\n\nafter '/create/:slug' do |slug|\n  session[:last_slug] = slug\nend\n```\n\nLike routes, filters also take conditions:\n\n```ruby\nbefore :agent => /Songbird/ do\n  # ...\nend\n\nafter '/blog/*', :host_name => 'example.com' do\n  # ...\nend\n```\n\n## Helpers\n\nUse the top-level `helpers` method to define helper methods for use in\nroute handlers and templates:\n\n```ruby\nhelpers do\n  def bar(name)\n    \"#{name}bar\"\n  end\nend\n\nget '/:name' do\n  bar(params['name'])\nend\n```\n\nAlternatively, helper methods can be separately defined in a module:\n\n```ruby\nmodule FooUtils\n  def foo(name) \"#{name}foo\" end\nend\n\nmodule BarUtils\n  def bar(name) \"#{name}bar\" end\nend\n\nhelpers FooUtils, BarUtils\n```\n\nThe effect is the same as including the modules in the application class.\n\n### Using Sessions\n\nA session is used to keep state during requests. If activated, you have one\nsession hash per user session:\n\n```ruby\nenable :sessions\n\nget '/' do\n  \"value = \" << session[:value].inspect\nend\n\nget '/:value' do\n  session['value'] = params['value']\nend\n```\n\n#### Session Secret Security\n\nTo improve security, the session data in the cookie is signed with a session\nsecret using `HMAC-SHA1`. This session secret should optimally be a\ncryptographically secure random value of an appropriate length which for\n`HMAC-SHA1` is greater than or equal to 64 bytes (512 bits, 128 hex\ncharacters). You would be advised not to use a secret that is less than 32\nbytes of randomness (256 bits, 64 hex characters). It is therefore **very\nimportant** that you don't just make the secret up, but instead use a secure\nrandom number generator to create it. Humans are extremely bad at generating\nrandom values.\n\nBy default, a 32 byte secure random session secret is generated for you by\nSinatra, but it will change with every restart of your application. If you\nhave multiple instances of your application, and you let Sinatra generate the\nkey, each instance would then have a different session key which is probably\nnot what you want.\n\nFor better security and usability it's\n[recommended](https://12factor.net/config) that you generate a secure random\nsecret and store it in an environment variable on each host running your\napplication so that all of your application instances will share the same\nsecret. You should periodically rotate this session secret to a new value.\nHere are some examples of how you might create a 64-byte secret and set it:\n\n**Session Secret Generation**\n\n```text\n$ ruby -e \"require 'securerandom'; puts SecureRandom.hex(64)\"\n99ae8af...snip...ec0f262ac\n```\n\n**Session Secret Environment Variable**\n\nSet a `SESSION_SECRET` environment variable for Sinatra to the value you\ngenerated. Make this value persistent across reboots of your host. Since the\nmethod for doing this will vary across systems this is for illustrative\npurposes only:\n\n```bash\n# echo \"export SESSION_SECRET=99ae8af...snip...ec0f262ac\" >> ~/.bashrc\n```\n\n**Session Secret App Config**\n\nSet up your app config to fail-safe to a secure random secret\nif the `SESSION_SECRET` environment variable is not available:\n\n```ruby\nrequire 'securerandom'\nset :session_secret, ENV.fetch('SESSION_SECRET') { SecureRandom.hex(64) }\n```\n\n#### Session Config\n\nIf you want to configure it further, you may also store a hash with options\nin the `sessions` setting:\n\n```ruby\nset :sessions, :domain => 'foo.com'\n```\n\nTo share your session across other apps on subdomains of foo.com, prefix the\ndomain with a *.* like this instead:\n\n```ruby\nset :sessions, :domain => '.foo.com'\n```\n\n#### Choosing Your Own Session Middleware\n\nNote that `enable :sessions` actually stores all data in a cookie. This\nmight not always be what you want (storing lots of data will increase your\ntraffic, for instance). You can use any Rack session middleware in order to\ndo so, one of the following methods can be used:\n\n```ruby\nenable :sessions\nset :session_store, Rack::Session::Pool\n```\n\nOr to set up sessions with a hash of options:\n\n```ruby\nset :sessions, :expire_after => 2592000\nset :session_store, Rack::Session::Pool\n```\n\nAnother option is to **not** call `enable :sessions`, but instead pull in\nyour middleware of choice as you would any other middleware.\n\nIt is important to note that when using this method, session based\nprotection **will not be enabled by default**.\n\nThe Rack middleware to do that will also need to be added:\n\n```ruby\nuse Rack::Session::Pool, :expire_after => 2592000\nuse Rack::Protection::RemoteToken\nuse Rack::Protection::SessionHijacking\n```\n\nSee '[Configuring attack protection](#configuring-attack-protection)' for more information.\n\n### Halting\n\nTo immediately stop a request within a filter or route use:\n\n```ruby\nhalt\n```\n\nYou can also specify the status when halting:\n\n```ruby\nhalt 410\n```\n\nOr the body:\n\n```ruby\nhalt 'this will be the body'\n```\n\nOr both:\n\n```ruby\nhalt 401, 'go away!'\n```\n\nWith headers:\n\n```ruby\nhalt 402, {'Content-Type' => 'text/plain'}, 'revenge'\n```\n\nIt is of course possible to combine a template with `halt`:\n\n```ruby\nhalt erb(:error)\n```\n\n### Passing\n\nA route can punt processing to the next matching route using `pass`:\n\n```ruby\nget '/guess/:who' do\n  pass unless params['who'] == 'Frank'\n  'You got me!'\nend\n\nget '/guess/*' do\n  'You missed!'\nend\n```\n\nThe route block is immediately exited and control continues with the next\nmatching route. If no matching route is found, a 404 is returned.\n\n### Triggering Another Route\n\nSometimes `pass` is not what you want, instead, you would like to get the\nresult of calling another route. Simply use `call` to achieve this:\n\n```ruby\nget '/foo' do\n  status, headers, body = call env.merge(\"PATH_INFO\" => '/bar')\n  [status, headers, body.map(&:upcase)]\nend\n\nget '/bar' do\n  \"bar\"\nend\n```\n\nNote that in the example above, you would ease testing and increase\nperformance by simply moving `\"bar\"` into a helper used by both `/foo` and\n`/bar`.\n\nIf you want the request to be sent to the same application instance rather\nthan a duplicate, use `call!` instead of `call`.\n\nCheck out the Rack specification if you want to learn more about `call`.\n\n### Setting Body, Status Code, and Headers\n\nIt is possible and recommended to set the status code and response body with\nthe return value of the route block. However, in some scenarios, you might\nwant to set the body at an arbitrary point in the execution flow. You can do\nso with the `body` helper method. If you do so, you can use that method from\nthereon to access the body:\n\n```ruby\nget '/foo' do\n  body \"bar\"\nend\n\nafter do\n  puts body\nend\n```\n\nIt is also possible to pass a block to `body`, which will be executed by the\nRack handler (this can be used to implement streaming, [see \"Return Values\"](#return-values)).\n\nSimilar to the body, you can also set the status code and headers:\n\n```ruby\nget '/foo' do\n  status 418\n  headers \\\n    \"Allow\"   => \"BREW, POST, GET, PROPFIND, WHEN\",\n    \"Refresh\" => \"Refresh: 20; https://ietf.org/rfc/rfc2324.txt\"\n  body \"I'm a teapot!\"\nend\n```\n\nLike `body`, `headers` and `status` with no arguments can be used to access\ntheir current values.\n\n### Streaming Responses\n\nSometimes you want to start sending out data while still generating parts of\nthe response body. In extreme examples, you want to keep sending data until\nthe client closes the connection. You can use the `stream` helper to avoid\ncreating your own wrapper:\n\n```ruby\nget '/' do\n  stream do |out|\n    out << \"It's gonna be legen -\\n\"\n    sleep 0.5\n    out << \" (wait for it) \\n\"\n    sleep 1\n    out << \"- dary!\\n\"\n  end\nend\n```\n\nThis allows you to implement streaming APIs,\n[Server Sent Events](https://w3c.github.io/eventsource/), and can be used as\nthe basis for [WebSockets](https://en.wikipedia.org/wiki/WebSocket). It can\nalso be used to increase throughput if some but not all content depends on a\nslow resource.\n\nNote that the streaming behavior, especially the number of concurrent\nrequests, highly depends on the webserver used to serve the application.\nSome servers might not even support streaming at all. If the server does not\nsupport streaming, the body will be sent all at once after the block passed\nto `stream` finishes executing. Streaming does not work at all with Shotgun.\n\nIf the optional parameter is set to `keep_open`, it will not call `close` on\nthe stream object, allowing you to close it at any later point in the\nexecution flow.\n\nYou can have a look at the [chat example](https://github.com/sinatra/sinatra/blob/main/examples/chat.rb)\n\nIt's also possible for the client to close the connection when trying to\nwrite to the socket. Because of this, it's recommended to check\n`out.closed?` before trying to write.\n\n### Logging\n\nIn the request scope, the `logger` helper exposes a `Logger` instance:\n\n```ruby\nget '/' do\n  logger.info \"loading data\"\n  # ...\nend\n```\n\nThis logger will automatically take your Rack handler's logging settings into\naccount. If logging is disabled, this method will return a dummy object, so\nyou do not have to worry about it in your routes and filters.\n\nNote that logging is only enabled for `Sinatra::Application` by default, so\nif you inherit from `Sinatra::Base`, you probably want to enable it yourself:\n\n```ruby\nclass MyApp < Sinatra::Base\n  configure :production, :development do\n    enable :logging\n  end\nend\n```\n\nTo avoid any logging middleware to be set up, set the `logging` option to\n`nil`. However, keep in mind that `logger` will in that case return `nil`. A\ncommon use case is when you want to set your own logger. Sinatra will use\nwhatever it will find in `env['rack.logger']`.\n\n### Mime Types\n\nWhen using `send_file` or static files you may have mime types Sinatra\ndoesn't understand. Use `mime_type` to register them by file extension:\n\n```ruby\nconfigure do\n  mime_type :foo, 'text/foo'\nend\n```\n\nYou can also use it with the `content_type` helper:\n\n```ruby\nget '/' do\n  content_type :foo\n  \"foo foo foo\"\nend\n```\n\n### Generating URLs\n\nFor generating URLs you should use the `url` helper method, for instance, in\nHaml:\n\n```ruby\n%a{:href => url('/foo')} foo\n```\n\nIt takes reverse proxies and Rack routers into account - if present.\n\nThis method is also aliased to `to` (see [below](#browser-redirect) for an example).\n\n### Browser Redirect\n\nYou can trigger a browser redirect with the `redirect` helper method:\n\n```ruby\nget '/foo' do\n  redirect to('/bar')\nend\n```\n\nAny additional parameters are handled like arguments passed to `halt`:\n\n```ruby\nredirect to('/bar'), 303\nredirect 'http://www.google.com/', 'wrong place, buddy'\n```\n\nYou can also easily redirect back to the page the user came from with\n`redirect back`:\n\n```ruby\nget '/foo' do\n  \"<a href='/bar'>do something</a>\"\nend\n\nget '/bar' do\n  do_something\n  redirect back\nend\n```\n\nTo pass arguments with a redirect, either add them to the query:\n\n```ruby\nredirect to('/bar?sum=42')\n```\n\nOr use a session:\n\n```ruby\nenable :sessions\n\nget '/foo' do\n  session[:secret] = 'foo'\n  redirect to('/bar')\nend\n\nget '/bar' do\n  session[:secret]\nend\n```\n\n### Cache Control\n\nSetting your headers correctly is the foundation for proper HTTP caching.\n\nYou can easily set the Cache-Control header like this:\n\n```ruby\nget '/' do\n  cache_control :public\n  \"cache it!\"\nend\n```\n\nPro tip: Set up caching in a before filter:\n\n```ruby\nbefore do\n  cache_control :public, :must_revalidate, :max_age => 60\nend\n```\n\nIf you are using the `expires` helper to set the corresponding header,\n`Cache-Control` will be set automatically for you:\n\n```ruby\nbefore do\n  expires 500, :public, :must_revalidate\nend\n```\n\nTo properly use caches, you should consider using `etag` or `last_modified`.\nIt is recommended to call those helpers *before* doing any heavy lifting, as\nthey will immediately flush a response if the client already has the current\nversion in its cache:\n\n```ruby\nget \"/article/:id\" do\n  @article = Article.find params['id']\n  last_modified @article.updated_at\n  etag @article.sha1\n  erb :article\nend\n```\n\nIt is also possible to use a\n[weak ETag](https://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation):\n\n```ruby\netag @article.sha1, :weak\n```\n\nThese helpers will not do any caching for you, but rather feed the necessary\ninformation to your cache. If you are looking for a quick\nreverse-proxy caching solution, try\n[rack-cache](https://github.com/rtomayko/rack-cache#readme):\n\n```ruby\nrequire \"rack/cache\"\nrequire \"sinatra\"\n\nuse Rack::Cache\n\nget '/' do\n  cache_control :public, :max_age => 36000\n  sleep 5\n  \"hello\"\nend\n```\n\nUse the `:static_cache_control` setting (see [below](#cache-control)) to add\n`Cache-Control` header info to static files.\n\nAccording to RFC 2616, your application should behave differently if the\nIf-Match or If-None-Match header is set to `*`, depending on whether the\nresource requested is already in existence. Sinatra assumes resources for\nsafe (like get) and idempotent (like put) requests are already in existence,\nwhereas other resources (for instance post requests) are treated as new\nresources. You can change this behavior by passing in a `:new_resource`\noption:\n\n```ruby\nget '/create' do\n  etag '', :new_resource => true\n  Article.create\n  erb :new_article\nend\n```\n\nIf you still want to use a weak ETag, pass in a `:kind` option:\n\n```ruby\netag '', :new_resource => true, :kind => :weak\n```\n\n### Sending Files\n\nTo return the contents of a file as the response, you can use the `send_file`\nhelper method:\n\n```ruby\nget '/' do\n  send_file 'foo.png'\nend\n```\n\nIt also takes options:\n\n```ruby\nsend_file 'foo.png', :type => :jpg\n```\n\nThe options are:\n\n<dl>\n  <dt>filename</dt>\n    <dd>File name to be used in the response,\n    defaults to the real file name.</dd>\n  <dt>last_modified</dt>\n    <dd>Value for Last-Modified header, defaults to the file's mtime.</dd>\n\n  <dt>type</dt>\n    <dd>Value for Content-Type header, guessed from the file extension if\n    missing.</dd>\n\n  <dt>disposition</dt>\n    <dd>\n      Value for Content-Disposition header, possible values: <tt>nil</tt>\n      (default), <tt>:attachment</tt> and <tt>:inline</tt>\n    </dd>\n\n  <dt>length</dt>\n    <dd>Value for Content-Length header, defaults to file size.</dd>\n\n  <dt>status</dt>\n    <dd>\n      Status code to be sent. Useful when sending a static file as an error\n      page. If supported by the Rack handler, other means than streaming\n      from the Ruby process will be used. If you use this helper method,\n      Sinatra will automatically handle range requests.\n    </dd>\n</dl>\n\n### Accessing the Request Object\n\nThe incoming request object can be accessed from request level (filter,\nroutes, error handlers) through the `request` method:\n\n```ruby\n# app running on http://example.com/example\nget '/foo' do\n  t = %w[text/css text/html application/javascript]\n  request.accept              # ['text/html', '*/*']\n  request.accept? 'text/xml'  # true\n  request.preferred_type(t)   # 'text/html'\n  request.body                # request body sent by the client (see below)\n  request.scheme              # \"http\"\n  request.script_name         # \"/example\"\n  request.path_info           # \"/foo\"\n  request.port                # 80\n  request.request_method      # \"GET\"\n  request.query_string        # \"\"\n  request.content_length      # length of request.body\n  request.media_type          # media type of request.body\n  request.host                # \"example.com\"\n  request.get?                # true (similar methods for other verbs)\n  request.form_data?          # false\n  request[\"some_param\"]       # value of some_param parameter. [] is a shortcut to the params hash.\n  request.referrer            # the referrer of the client or '/'\n  request.user_agent          # user agent (used by :agent condition)\n  request.cookies             # hash of browser cookies\n  request.xhr?                # is this an ajax request?\n  request.url                 # \"http://example.com/example/foo\"\n  request.path                # \"/example/foo\"\n  request.ip                  # client IP address\n  request.secure?             # false (would be true over ssl)\n  request.forwarded?          # true (if running behind a reverse proxy)\n  request.env                 # raw env hash handed in by Rack\nend\n```\n\nSome options, like `script_name` or `path_info`, can also be written:\n\n```ruby\nbefore { request.path_info = \"/\" }\n\nget \"/\" do\n  \"all requests end up here\"\nend\n```\n\nThe `request.body` is an IO or StringIO object:\n\n```ruby\npost \"/api\" do\n  request.body.rewind  # in case someone already read it\n  data = JSON.parse request.body.read\n  \"Hello #{data['name']}!\"\nend\n```\n\n### Attachments\n\nYou can use the `attachment` helper to tell the browser the response should\nbe stored on disk rather than displayed in the browser:\n\n```ruby\nget '/' do\n  attachment\n  \"store it!\"\nend\n```\n\nYou can also pass it a file name:\n\n```ruby\nget '/' do\n  attachment \"info.txt\"\n  \"store it!\"\nend\n```\n\n### Dealing with Date and Time\n\nSinatra offers a `time_for` helper method that generates a Time object from\nthe given value. It is also able to convert `DateTime`, `Date` and similar\nclasses:\n\n```ruby\nget '/' do\n  pass if Time.now > time_for('Dec 23, 2016')\n  \"still time\"\nend\n```\n\nThis method is used internally by `expires`, `last_modified` and akin. You\ncan therefore easily extend the behavior of those methods by overriding\n`time_for` in your application:\n\n```ruby\nhelpers do\n  def time_for(value)\n    case value\n    when :yesterday then Time.now - 24*60*60\n    when :tomorrow  then Time.now + 24*60*60\n    else super\n    end\n  end\nend\n\nget '/' do\n  last_modified :yesterday\n  expires :tomorrow\n  \"hello\"\nend\n```\n\n### Looking Up Template Files\n\nThe `find_template` helper is used to find template files for rendering:\n\n```ruby\nfind_template settings.views, 'foo', Tilt[:haml] do |file|\n  puts \"could be #{file}\"\nend\n```\n\nThis is not really useful. But it is useful that you can actually override\nthis method to hook in your own lookup mechanism. For instance, if you want\nto be able to use more than one view directory:\n\n```ruby\nset :views, ['views', 'templates']\n\nhelpers do\n  def find_template(views, name, engine, &block)\n    Array(views).each { |v| super(v, name, engine, &block) }\n  end\nend\n```\n\nAnother example would be using different directories for different engines:\n\n```ruby\nset :views, :haml => 'templates', :default => 'views'\n\nhelpers do\n  def find_template(views, name, engine, &block)\n    _, folder = views.detect { |k,v| engine == Tilt[k] }\n    folder ||= views[:default]\n    super(folder, name, engine, &block)\n  end\nend\n```\n\nYou can also easily wrap this up in an extension and share it with others!\n\nNote that `find_template` does not check if the file really exists but\nrather calls the given block for all possible paths. This is not a\nperformance issue, since `render` will use `break` as soon as a file is\nfound. Also, template locations (and content) will be cached if you are not\nrunning in development mode. You should keep that in mind if you write a\nreally crazy method.\n\n## Configuration\n\nRun once, at startup, in any environment:\n\n```ruby\nconfigure do\n  # setting one option\n  set :option, 'value'\n\n  # setting multiple options\n  set :a => 1, :b => 2\n\n  # same as `set :option, true`\n  enable :option\n\n  # same as `set :option, false`\n  disable :option\n\n  # you can also have dynamic settings with blocks\n  set(:css_dir) { File.join(views, 'css') }\nend\n```\n\nRun only when the environment (`APP_ENV` environment variable) is set to\n`:production`:\n\n```ruby\nconfigure :production do\n  ...\nend\n```\n\nRun when the environment is set to either `:production` or `:test`:\n\n```ruby\nconfigure :production, :test do\n  ...\nend\n```\n\nYou can access those options via `settings`:\n\n```ruby\nconfigure do\n  set :foo, 'bar'\nend\n\nget '/' do\n  settings.foo? # => true\n  settings.foo  # => 'bar'\n  ...\nend\n```\n\n### Configuring attack protection\n\nSinatra is using\n[Rack::Protection](https://github.com/sinatra/sinatra/tree/main/rack-protection#readme) to\ndefend your application against common, opportunistic attacks. You can\neasily disable this behavior (which will open up your application to tons\nof common vulnerabilities):\n\n```ruby\ndisable :protection\n```\n\nTo skip a single defense layer, set `protection` to an options hash:\n\n```ruby\nset :protection, :except => :path_traversal\n```\nYou can also hand in an array in order to disable a list of protections:\n\n```ruby\nset :protection, :except => [:path_traversal, :remote_token]\n```\n\nBy default, Sinatra will only set up session based protection if `:sessions`\nhave been enabled. See '[Using Sessions](#using-sessions)'. Sometimes you may want to set up\nsessions \"outside\" of the Sinatra app, such as in the config.ru or with a\nseparate `Rack::Builder` instance. In that case, you can still set up session\nbased protection by passing the `:session` option:\n\n```ruby\nset :protection, :session => true\n```\n\n### Available Settings\n\n<dl>\n  <dt>absolute_redirects</dt>\n    <dd>\n      If disabled, Sinatra will allow relative redirects, however, Sinatra\n      will no longer conform with RFC 2616 (HTTP 1.1), which only allows\n      absolute redirects.\n    </dd>\n    <dd>\n      Enable if your app is running behind a reverse proxy that has not been\n      set up properly. Note that the <tt>url</tt> helper will still produce\n      absolute URLs, unless you pass in <tt>false</tt> as the second\n      parameter.\n    </dd>\n    <dd>Disabled by default.</dd>\n\n  <dt>add_charset</dt>\n    <dd>\n      Mime types the <tt>content_type</tt> helper will automatically add the\n      charset info to. You should add to it rather than overriding this\n      option: <tt>settings.add_charset << \"application/foobar\"</tt>\n    </dd>\n\n  <dt>app_file</dt>\n    <dd>\n      Path to the main application file, used to detect project root, views\n      and public folder and inline templates.\n    </dd>\n\n  <dt>bind</dt>\n    <dd>\n      IP address to bind to (default: <tt>0.0.0.0</tt> <em>or</em>\n      <tt>localhost</tt> if your `environment` is set to development). Only\n      used for built-in server.\n    </dd>\n\n  <dt>default_content_type</dt>\n  <dd>\n    Content-Type to assume if unknown (defaults to <tt>\"text/html\"</tt>). Set\n    to <tt>nil</tt> to not set a default Content-Type on every response; when\n    configured so, you must set the Content-Type manually when emitting content\n    or the user-agent will have to sniff it (or, if <tt>nosniff</tt> is enabled\n    in Rack::Protection::XSSHeader, assume <tt>application/octet-stream</tt>).\n  </dd>\n\n  <dt>default_encoding</dt>\n    <dd>Encoding to assume if unknown (defaults to <tt>\"utf-8\"</tt>).</dd>\n\n  <dt>dump_errors</dt>\n    <dd>Display errors in the log. Enabled by default unless environment is \"test\".</dd>\n\n  <dt>environment</dt>\n    <dd>\n      Current environment. Defaults to <tt>ENV['APP_ENV']</tt>, or\n      <tt>\"development\"</tt> if not available.\n    </dd>\n\n  <dt>host_authorization</dt>\n  <dd>\n    <p>\n      You can pass a hash of options to <tt>host_authorization</tt>,\n      to be used by the <tt>Rack::Protection::HostAuthorization</tt> middleware.\n    </p>\n    <p>\n      The middleware can block requests with unrecognized hostnames, to prevent DNS rebinding\n      and other host header attacks. It checks the <tt>Host</tt>, <tt>X-Forwarded-Host</tt>\n      and <tt>Forwarded</tt> headers.\n    </p>\n    <p>\n      Useful options are:\n      <ul>\n        <li><tt>permitted_hosts</tt> \u2013 an array of hostnames (and <tt>IPAddr</tt> objects) your app recognizes\n          <ul>\n            <li>in the <tt>development</tt> environment, it is set to <tt>.localhost</tt>, <tt>.test</tt> and any IPv4/IPv6 address</li>\n            <li>if empty, any hostname is permitted (the default for any other environment)</li>\n          </ul>\n        </li>\n        <li><tt>status</tt> \u2013 the HTTP status code used in the response when a request is blocked (defaults to <tt>403</tt>)</li>\n        <li><tt>message</tt> \u2013 the body used in the response when a request is blocked (defaults to <tt>Host not permitted</tt>)</li>\n        <li><tt>allow_if</tt> \u2013 supply a <tt>Proc</tt> to use custom allow/deny logic, the proc is passed the request environment</li>\n      </ul>\n    </p>\n  </dd>\n\n  <dt>logging</dt>\n    <dd>Use the logger.</dd>\n\n  <dt>lock</dt>\n    <dd>\n      Places a lock around every request, only running processing on request\n      per Ruby process concurrently.\n    </dd>\n    <dd>Enabled if your app is not thread-safe. Disabled by default.</dd>\n\n  <dt>method_override</dt>\n    <dd>\n      Use <tt>_method</tt> magic to allow put/delete forms in browsers that\n      don't support it.\n    </dd>\n\n  <dt>mustermann_opts</dt>\n  <dd>\n    A default hash of options to pass to Mustermann.new when compiling routing\n    paths.\n  </dd>\n\n  <dt>port</dt>\n    <dd>Port to listen on. Only used for built-in server.</dd>\n\n  <dt>prefixed_redirects</dt>\n    <dd>\n      Whether or not to insert <tt>request.script_name</tt> into redirects\n      if no absolute path is given. That way <tt>redirect '/foo'</tt> would\n        behave like <tt>redirect to('/foo')</tt>. Disabled by default.\n    </dd>\n\n  <dt>protection</dt>\n    <dd>\n      Whether or not to enable web attack protections. See protection section\n      above.\n    </dd>\n\n  <dt>public_dir</dt>\n    <dd>Alias for <tt>public_folder</tt>. See below.</dd>\n\n  <dt>public_folder</dt>\n    <dd>\n      Path to the folder public files are served from. Only used if static\n      file serving is enabled (see <tt>static</tt> setting below). Inferred\n      from <tt>app_file</tt> setting if not set.\n    </dd>\n\n  <dt>quiet</dt>\n    <dd>\n      Disables logs generated by Sinatra's start and stop commands.\n      <tt>false</tt> by default.\n    </dd>\n\n  <dt>reload_templates</dt>\n    <dd>\n      Whether or not to reload templates between requests. Enabled in\n      development mode.\n    </dd>\n\n  <dt>root</dt>\n    <dd>\n      Path to project root folder. Inferred from <tt>app_file</tt> setting\n      if not set.\n    </dd>\n\n  <dt>raise_errors</dt>\n    <dd>\n      Raise unhandled errors (will stop application). Enabled by default when\n      <tt>environment</tt> is set to <tt>\"test\"</tt>, disabled otherwise.\n    </dd>\n    <dd>\n      Any explicitly defined error handlers always override this setting. See \n      the \"Error\" section below.\n    </dd>\n\n  <dt>run</dt>\n    <dd>\n      If enabled, Sinatra will handle starting the web server. Do not\n      enable if using rackup or other means.\n    </dd>\n\n  <dt>running</dt>\n    <dd>Is the built-in server running now? Do not change this setting!</dd>\n\n  <dt>server</dt>\n    <dd>\n      Server or list of servers to use for built-in server. Order indicates\n      priority, default depends on Ruby implementation.\n    </dd>\n\n  <dt>server_settings</dt>\n    <dd>\n      You can pass a hash of options to <tt>server_settings</tt>,\n      such as <tt>Host</tt> or <tt>Port</tt>.\n    </dd>\n\n  <dt>sessions</dt>\n    <dd>\n      Enable cookie-based sessions support using\n      <tt>Rack::Session::Cookie</tt>. See 'Using Sessions' section for more\n      information.\n    </dd>\n\n  <dt>session_store</dt>\n    <dd>\n      The Rack session middleware used. Defaults to\n      <tt>Rack::Session::Cookie</tt>. See 'Using Sessions' section for more\n      information.\n    </dd>\n\n  <dt>show_exceptions</dt>\n    <dd>\n      Show a stack trace in the browser when an exception happens. Enabled by\n      default when <tt>environment</tt> is set to <tt>\"development\"</tt>,\n      disabled otherwise.\n    </dd>\n    <dd>\n      Can also be set to <tt>:after_handler</tt> to trigger app-specified\n      error handling before showing a stack trace in the browser.\n    </dd>\n\n  <dt>static</dt>\n    <dd>Whether Sinatra should handle serving static files.</dd>\n    <dd>Disable when using a server able to do this on its own.</dd>\n    <dd>Disabling will boost performance.</dd>\n    <dd>\n      Enabled by default in classic style, disabled for modular apps.\n    </dd>\n\n  <dt>static_cache_control</dt>\n    <dd>\n      When Sinatra is serving static files, set this to add\n      <tt>Cache-Control</tt> headers to the responses. Uses the\n      <tt>cache_control</tt> helper. Disabled by default.\n    </dd>\n    <dd>\n      Use an explicit array when setting multiple values:\n      <tt>set :static_cache_control, [:public, :max_age => 300]</tt>\n    </dd>\n\n  <dt>threaded</dt>\n    <dd>\n      If set to <tt>true</tt>, will tell server to use\n      <tt>EventMachine.defer</tt> for processing the request.\n    </dd>\n\n  <dt>traps</dt>\n    <dd>Whether Sinatra should handle system signals.</dd>\n\n  <dt>views</dt>\n    <dd>\n      Path to the views folder. Inferred from <tt>app_file</tt> setting if\n      not set.\n    </dd>\n\n  <dt>x_cascade</dt>\n    <dd>\n      Whether or not to set the X-Cascade header if no route matches.\n      Defaults to <tt>true</tt>.\n    </dd>\n</dl>\n\n## Lifecycle Events\n\nThere are 2 lifecycle events currently exposed by Sinatra. One when the server starts and one when it stops.\n\nThey can be used like this:\n\n```ruby\non_start do\n  puts \"===== Booting up =====\"\nend\n\non_stop do\n  puts \"===== Shutting down =====\"\nend\n```\n\nNote that these callbacks only work when using Sinatra to start the web server.\n\n## Environments\n\nThere are three predefined `environments`: `\"development\"`,\n`\"production\"` and `\"test\"`. Environments can be set through the\n`APP_ENV` environment variable. The default value is `\"development\"`.\nIn the `\"development\"` environment all templates are reloaded between\nrequests, and special `not_found` and `error` handlers display stack\ntraces in your browser. In the `\"production\"` and `\"test\"` environments,\ntemplates are cached by default.\n\nTo run different environments, set the `APP_ENV` environment variable:\n\n```shell\nAPP_ENV=production ruby my_app.rb\n```\n\nYou can use predefined methods: `development?`, `test?` and `production?` to\ncheck the current environment setting:\n\n```ruby\nget '/' do\n  if settings.development?\n    \"development!\"\n  else\n    \"not development!\"\n  end\nend\n```\n\n## Error Handling\n\nError handlers run within the same context as routes and before filters,\nwhich means you get all the goodies it has to offer, like `haml`, `erb`,\n`halt`, etc.\n\n### Not Found\n\nWhen a `Sinatra::NotFound` exception is raised, or the response's status\ncode is 404, the `not_found` handler is invoked:\n\n```ruby\nnot_found do\n  'This is nowhere to be found.'\nend\n```\n\n### Error\n\nThe `error` handler is invoked any time an exception is raised from a route\nblock or a filter. But note in development it will only run if you set the\nshow exceptions option to `:after_handler`:\n\n```ruby\nset :show_exceptions, :after_handler\n```\n\nA catch-all error handler can be defined with `error` and a block:\n\n```ruby\nerror do\n  'Sorry there was a nasty error'\nend\n```\n\nThe exception object can be obtained from the `sinatra.error` Rack variable:\n\n```ruby\nerror do\n  'Sorry there was a nasty error - ' + env['sinatra.error'].message\nend\n```\n\nPass an error class as an argument to create handlers for custom errors:\n\n```ruby\nerror MyCustomError do\n  'So what happened was...' + env['sinatra.error'].message\nend\n```\n\nThen, if this happens:\n\n```ruby\nget '/' do\n  raise MyCustomError, 'something bad'\nend\n```\n\nYou get this:\n\n```\nSo what happened was... something bad\n```\n\nAlternatively, you can install an error handler for a status code:\n\n```ruby\nerror 403 do\n  'Access forbidden'\nend\n\nget '/secret' do\n  403\nend\n```\n\nOr a range:\n\n```ruby\nerror 400..510 do\n  'Boom'\nend\n```\n\nSinatra installs special `not_found` and `error` handlers when\nrunning under the development environment to display nice stack traces\nand additional debugging information in your browser.\n\n### Behavior with `raise_errors` option\n\nWhen `raise_errors` option is `true`, errors that are unhandled are raised \noutside of the application. Additionally, any errors that would have been \ncaught by the catch-all error handler are raised.\n\nFor example, consider the following configuration:\n\n```ruby\n# First handler\nerror MyCustomError do\n  'A custom message'\nend\n\n# Second handler\nerror do\n  'A catch-all message'\nend\n```\n\nIf `raise_errors` is `false`:\n\n* When `MyCustomError` or descendant is raised, the first handler is invoked.\n  The HTTP response body will contain `\"A custom message\"`.\n* When any other error is raised, the second handler is invoked. The HTTP \n  response body will contain `\"A catch-all message\"`.\n\nIf `raise_errors` is `true`:\n\n* When `MyCustomError` or descendant is raised, the behavior is identical to \n  when `raise_errors` is `false`, described above.\n* When any other error is raised, the second handler is *not* invoked, and \n  the error is raised outside of the application.\n  * If the environment is `production`, the HTTP response body will contain \n    a generic error message, e.g. `\"An unhandled lowlevel error occurred. The\n    application logs may have details.\"`\n  * If the environment is not `production`, the HTTP response body will contain\n    the verbose error backtrace.\n  * Regardless of environment, if `show_exceptions` is set to `:after_handler`, \n    the HTTP response body will contain the verbose error backtrace.\n\nIn the `test` environment, `raise_errors` is set to `true` by default. This \nmeans that in order to write a test for a catch-all error handler, \n`raise_errors` must temporarily be set to `false` for that particular test.\n\n## Rack Middleware\n\nSinatra rides on [Rack](https://rack.github.io/), a minimal standard\ninterface for Ruby web frameworks. One of Rack's most interesting\ncapabilities for application developers is support for \"middleware\" --\ncomponents that sit between the server and your application monitoring\nand/or manipulating the HTTP request/response to provide various types\nof common functionality.\n\nSinatra makes building Rack middleware pipelines a cinch via a top-level\n`use` method:\n\n```ruby\nrequire 'sinatra'\nrequire 'my_custom_middleware'\n\nuse Rack::Lint\nuse MyCustomMiddleware\n\nget '/hello' do\n  'Hello World'\nend\n```\n\nThe semantics of `use` are identical to those defined for the\n[Rack::Builder](https://www.rubydoc.info/github/rack/rack/main/Rack/Builder) DSL\n(most frequently used from rackup files). For example, the `use` method\naccepts multiple/variable args as well as blocks:\n\n```ruby\nuse Rack::Auth::Basic do |username, password|\n  username == 'admin' && password == 'secret'\nend\n```\n\nRack is distributed with a variety of standard middleware for logging,\ndebugging, URL routing, authentication, and session handling. Sinatra uses\nmany of these components automatically based on configuration so you\ntypically don't have to `use` them explicitly.\n\nYou can find useful middleware in\n[rack](https://github.com/rack/rack/tree/main/lib/rack),\n[rack-contrib](https://github.com/rack/rack-contrib#readme),\nor in the [Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware).\n\n## Testing\n\nSinatra tests can be written using any Rack-based testing library or\nframework.\n[Rack::Test](https://www.rubydoc.info/github/rack/rack-test/main/frames)\nis recommended:\n\n```ruby\nrequire 'my_sinatra_app'\nrequire 'minitest/autorun'\nrequire 'rack/test'\n\nclass MyAppTest < Minitest::Test\n  include Rack::Test::Methods\n\n  def app\n    Sinatra::Application\n  end\n\n  def test_my_default\n    get '/'\n    assert_equal 'Hello World!', last_response.body\n  end\n\n  def test_with_params\n    get '/meet', :name => 'Frank'\n    assert_equal 'Hello Frank!', last_response.body\n  end\n\n  def test_with_user_agent\n    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'\n    assert_equal \"You're using Songbird!\", last_response.body\n  end\nend\n```\n\nNote: If you are using Sinatra in the modular style, replace\n`Sinatra::Application` above with the class name of your app.\n\n## Sinatra::Base - Middleware, Libraries, and Modular Apps\n\nDefining your app at the top-level works well for micro-apps but has\nconsiderable drawbacks when building reusable components such as Rack\nmiddleware, Rails metal, simple libraries with a server component, or even\nSinatra extensions. The top-level assumes a micro-app style configuration\n(e.g., a single application file, `./public` and `./views`\ndirectories, logging, exception detail page, etc.). That's where\n`Sinatra::Base` comes into play:\n\n```ruby\nrequire 'sinatra/base'\n\nclass MyApp < Sinatra::Base\n  set :sessions, true\n  set :foo, 'bar'\n\n  get '/' do\n    'Hello world!'\n  end\nend\n```\n\nThe methods available to `Sinatra::Base` subclasses are exactly the same\nas those available via the top-level DSL. Most top-level apps can be\nconverted to `Sinatra::Base` components with two modifications:\n\n* Your file should require `sinatra/base` instead of `sinatra`;\n  otherwise, all of Sinatra's DSL methods are imported into the main\n  namespace.\n* Put your app's routes, error handlers, filters, and options in a subclass\n  of `Sinatra::Base`.\n\n`Sinatra::Base` is a blank slate. Most options are disabled by default,\nincluding the built-in server. See [Configuring\nSettings](http://www.sinatrarb.com/configuration.html) for details on\navailable options and their behavior. If you want behavior more similar\nto when you define your app at the top level (also known as Classic\nstyle), you can subclass `Sinatra::Application`:\n\n```ruby\nrequire 'sinatra/base'\n\nclass MyApp < Sinatra::Application\n  get '/' do\n    'Hello world!'\n  end\nend\n```\n\n### Modular vs. Classic Style\n\nContrary to common belief, there is nothing wrong with the classic\nstyle. If it suits your application, you do not have to switch to a\nmodular application.\n\nThe main disadvantage of using the classic style rather than the modular\nstyle is that you will only have one Sinatra application per Ruby\nprocess. If you plan to use more than one, switch to the modular style.\nThere is no reason you cannot mix the modular and classic styles.\n\nIf switching from one style to the other, you should be aware of\nslightly different default settings:\n\n<table>\n  <tr>\n    <th>Setting</th>\n    <th>Classic</th>\n    <th>Modular</th>\n    <th>Modular</th>\n  </tr>\n\n  <tr>\n    <td>app_file</td>\n    <td>file loading sinatra</td>\n    <td>file subclassing Sinatra::Base</td>\n    <td>file subclassing Sinatra::Application</td>\n  </tr>\n\n  <tr>\n    <td>run</td>\n    <td>$0 == app_file</td>\n    <td>false</td>\n    <td>false</td>\n  </tr>\n\n  <tr>\n    <td>logging</td>\n    <td>true</td>\n    <td>false</td>\n    <td>true</td>\n  </tr>\n\n  <tr>\n    <td>method_override</td>\n    <td>true</td>\n    <td>false</td>\n    <td>true</td>\n  </tr>\n\n  <tr>\n    <td>inline_templates</td>\n    <td>true</td>\n    <td>false</td>\n    <td>true</td>\n  </tr>\n\n  <tr>\n    <td>static</td>\n    <td>true</td>\n    <td>File.exist?(public_folder)</td>\n    <td>true</td>\n  </tr>\n</table>\n\n### Serving a Modular Application\n\nThere are two common options for starting a modular app, actively\nstarting with `run!`:\n\n```ruby\n# my_app.rb\nrequire 'sinatra/base'\n\nclass MyApp < Sinatra::Base\n  # ... app code here ...\n\n  # start the server if ruby file executed directly\n  run! if app_file == $0\nend\n```\n\nStart with:\n\n```shell\nruby my_app.rb\n```\n\nOr with a `config.ru` file, which allows using any Rack handler:\n\n```ruby\n# config.ru (run with rackup)\nrequire './my_app'\nrun MyApp\n```\n\nRun:\n\n```shell\nrackup -p 4567\n```\n\n### Using a Classic Style Application with a config.ru\n\nWrite your app file:\n\n```ruby\n# app.rb\nrequire 'sinatra'\n\nget '/' do\n  'Hello world!'\nend\n```\n\nAnd a corresponding `config.ru`:\n\n```ruby\nrequire './app'\nrun Sinatra::Application\n```\n\n### When to use a config.ru?\n\nA `config.ru` file is recommended if:\n\n* You want to deploy with a different Rack handler (Passenger, Unicorn,\n  Heroku, ...).\n* You want to use more than one subclass of `Sinatra::Base`.\n* You want to use Sinatra only for middleware, and not as an endpoint.\n\n**There is no need to switch to a `config.ru` simply because you\nswitched to the modular style, and you don't have to use the modular\nstyle for running with a `config.ru`.**\n\n### Using Sinatra as Middleware\n\nNot only is Sinatra able to use other Rack middleware, any Sinatra\napplication can, in turn, be added in front of any Rack endpoint as\nmiddleware itself. This endpoint could be another Sinatra application,\nor any other Rack-based application (Rails/Hanami/Roda/...):\n\n```ruby\nrequire 'sinatra/base'\n\nclass LoginScreen < Sinatra::Base\n  enable :sessions\n\n  get('/login') { haml :login }\n\n  post('/login') do\n    if params['name'] == 'admin' && params['password'] == 'admin'\n      session['user_name'] = params['name']\n    else\n      redirect '/login'\n    end\n  end\nend\n\nclass MyApp < Sinatra::Base\n  # middleware will run before filters\n  use LoginScreen\n\n  before do\n    unless session['user_name']\n      halt \"Access denied, please <a href='/login'>login</a>.\"\n    end\n  end\n\n  get('/') { \"Hello #{session['user_name']}.\" }\nend\n```\n\n### Dynamic Application Creation\n\nSometimes you want to create new applications at runtime without having to\nassign them to a constant. You can do this with `Sinatra.new`:\n\n```ruby\nrequire 'sinatra/base'\nmy_app = Sinatra.new { get('/') { \"hi\" } }\nmy_app.run!\n```\n\nIt takes the application to inherit from as an optional argument:\n\n```ruby\n# config.ru (run with rackup)\nrequire 'sinatra/base'\n\ncontroller = Sinatra.new do\n  enable :logging\n  helpers MyHelpers\nend\n\nmap('/a') do\n  run Sinatra.new(controller) { get('/') { 'a' } }\nend\n\nmap('/b') do\n  run Sinatra.new(controller) { get('/') { 'b' } }\nend\n```\n\nThis is especially useful for testing Sinatra extensions or using Sinatra in\nyour own library.\n\nThis also makes using Sinatra as middleware extremely easy:\n\n```ruby\nrequire 'sinatra/base'\n\nuse Sinatra do\n  get('/') { ... }\nend\n\nrun RailsProject::Application\n```\n\n## Scopes and Binding\n\nThe scope you are currently in determines what methods and variables are\navailable.\n\n### Application/Class Scope\n\nEvery Sinatra application corresponds to a subclass of `Sinatra::Base`.\nIf you are using the top-level DSL (`require 'sinatra'`), then this\nclass is `Sinatra::Application`, otherwise it is the subclass you\ncreated explicitly. At the class level, you have methods like `get` or\n`before`, but you cannot access the `request` or `session` objects, as\nthere is only a single application class for all requests.\n\nOptions created via `set` are methods at class level:\n\n```ruby\nclass MyApp < Sinatra::Base\n  # Hey, I'm in the application scope!\n  set :foo, 42\n  foo # => 42\n\n  get '/foo' do\n    # Hey, I'm no longer in the application scope!\n  end\nend\n```\n\nYou have the application scope binding inside:\n\n* Your application class body\n* Methods defined by extensions\n* The block passed to `helpers`\n* Procs/blocks used as a value for `set`\n* The block passed to `Sinatra.new`\n\nYou can reach the scope object (the class) like this:\n\n* Via the object passed to configure blocks (`configure { |c| ... }`)\n* `settings` from within the request scope\n\n### Request/Instance Scope\n\nFor every incoming request, a new instance of your application class is\ncreated, and all handler blocks run in that scope. From within this scope you\ncan access the `request` and `session` objects or call rendering methods like\n`erb` or `haml`. You can access the application scope from within the request\nscope via the `settings` helper:\n\n```ruby\nclass MyApp < Sinatra::Base\n  # Hey, I'm in the application scope!\n  get '/define_route/:name' do\n    # Request scope for '/define_route/:name'\n    @value = 42\n\n    settings.get(\"/#{params['name']}\") do\n      # Request scope for \"/#{params['name']}\"\n      @value # => nil (not the same request)\n    end\n\n    \"Route defined!\"\n  end\nend\n```\n\nYou have the request scope binding inside:\n\n* get, head, post, put, delete, options, patch, link and unlink blocks\n* before and after filters\n* helper methods\n* templates/views\n\n### Delegation Scope\n\nThe delegation scope just forwards methods to the class scope. However, it\ndoes not behave exactly like the class scope, as you do not have the class\nbinding. Only methods explicitly marked for delegation are available, and you\ndo not share variables/state with the class scope (read: you have a different\n`self`). You can explicitly add method delegations by calling\n`Sinatra::Delegator.delegate :method_name`.\n\nYou have the delegate scope binding inside:\n\n* The top-level binding, if you did `require \"sinatra\"`\n* An object extended with the `Sinatra::Delegator` mixin\n\nHave a look at the code for yourself: here's the\n[Sinatra::Delegator mixin](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)\nbeing [extending the main object](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30).\n\n## Command Line\n\nSinatra applications can be run directly:\n\n```shell\nruby myapp.rb [-h] [-x] [-q] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]\n```\n\nOptions are:\n\n```\n-h # help\n-p # set the port (default is 4567)\n-o # set the host (default is 0.0.0.0)\n-e # set the environment (default is development)\n-s # specify rack server/handler (default is puma)\n-q # turn on quiet mode for server (default is off)\n-x # turn on the mutex lock (default is off)\n```\n\n### Multi-threading\n\n_Paraphrasing from\n[this StackOverflow answer](https://stackoverflow.com/a/6282999/5245129)\nby Konstantin_\n\nSinatra doesn't impose any concurrency model but leaves that to the\nunderlying Rack handler (server) like Puma or Falcon. Sinatra\nitself is thread-safe, so there won't be any problem if the Rack handler\nuses a threaded model of concurrency.\n\n## Requirement\n\nThe following Ruby versions are officially supported:\n<dl>\n  <dt>Ruby</dt>\n  <dd>\n    <a href=\"https://www.ruby-lang.org/en/downloads/\">The stable releases</a> are fully supported and recommended.\n  </dd>\n\n  <dt>TruffleRuby</dt>\n  <dd>\n    The latest stable release of TruffleRuby is supported.\n  </dd>\n\n  <dt>JRuby</dt>\n  <dd>\n    The latest stable release of JRuby is supported. It is not\n    recommended to use C extensions with JRuby.\n  </dd>\n</dl>\n\nVersions of Ruby before 2.7.8 are no longer supported as of Sinatra 4.0.0.\n\nSinatra should work on any operating system supported by the chosen Ruby\nimplementation.\n\nRunning Sinatra on a not officially supported Ruby flavor means that if things only break there we assume it's not our issue but theirs.\n\n## The Bleeding Edge\n\nIf you would like to use Sinatra's latest bleeding-edge code, feel free\nto run your application against the main branch, it should be rather\nstable.\n\nWe also push out prerelease gems from time to time, so you can do a\n\n```shell\ngem install sinatra --pre\n```\n\nto get some of the latest features.\n\n### With Bundler\n\nIf you want to run your application with the latest Sinatra, using\n[Bundler](https://bundler.io) is the recommended way.\n\nFirst, install bundler, if you haven't:\n\n```shell\ngem install bundler\n```\n\nThen, in your project directory, create a `Gemfile`:\n\n```ruby\nsource 'https://rubygems.org'\ngem 'sinatra', :github => 'sinatra/sinatra'\n\n# other dependencies\ngem 'haml'                    # for instance, if you use haml\n```\n\nNote that you will have to list all your application's dependencies in\nthe `Gemfile`. Sinatra's direct dependencies (Rack and Tilt) will,\nhowever, be automatically fetched and added by Bundler.\n\nNow you can run your app like this:\n\n```shell\nbundle exec ruby myapp.rb\n```\n\n## Versioning\n\nSinatra follows [Semantic Versioning](https://semver.org/), both SemVer and\nSemVerTag.\n\n## Further Reading\n\n* [Project Website](https://sinatrarb.com/) - Additional documentation,\n  news, and links to other resources.\n* [Contributing](https://sinatrarb.com/contributing) - Find a bug? Need\n  help? Have a patch?\n* [Issue tracker](https://github.com/sinatra/sinatra/issues)\n* [Twitter](https://twitter.com/sinatra)\n* [Mailing List](https://groups.google.com/forum/#!forum/sinatrarb)\n* IRC: [#sinatra](irc://chat.freenode.net/#sinatra) on [Freenode](https://freenode.net)\n* [Sinatra & Friends](https://discord.gg/ncjsfsNHh7) on Discord\n* [Sinatra Book](https://github.com/sinatra/sinatra-book) - Cookbook Tutorial\n* [Sinatra Recipes](http://recipes.sinatrarb.com/) - Community contributed\n  recipes\n* API documentation for the [latest release](https://www.rubydoc.info/gems/sinatra)\n  or the [current HEAD](https://www.rubydoc.info/github/sinatra/sinatra) on\n  [RubyDoc](https://www.rubydoc.info/)\n* [CI Actions](https://github.com/sinatra/sinatra/actions)\n",
        "releases": []
    }
}
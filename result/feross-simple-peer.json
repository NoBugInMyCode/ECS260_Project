{
    "https://api.github.com/repos/feross/simple-peer": {
        "forks": 979,
        "watchers": 7509,
        "stars": 7509,
        "languages": {
            "JavaScript": 82245
        },
        "commits": [
            "2022-02-17T18:28:29Z",
            "2022-02-17T18:26:37Z",
            "2022-02-17T18:24:04Z",
            "2022-02-17T18:21:49Z",
            "2022-02-17T18:21:29Z",
            "2022-02-14T04:13:46Z",
            "2021-07-14T23:36:21Z",
            "2021-07-14T23:36:08Z",
            "2021-07-14T23:35:13Z",
            "2021-07-12T04:18:15Z",
            "2021-07-05T04:18:09Z",
            "2021-06-29T04:13:39Z",
            "2021-04-22T00:55:46Z",
            "2021-04-22T00:39:22Z",
            "2021-04-22T00:39:14Z",
            "2021-04-22T00:30:07Z",
            "2021-04-22T00:19:35Z",
            "2021-04-22T00:14:19Z",
            "2021-04-22T00:12:21Z",
            "2021-04-22T00:09:55Z",
            "2021-04-13T01:55:50Z",
            "2021-04-13T01:52:18Z",
            "2021-04-13T01:46:17Z",
            "2021-04-13T01:45:35Z",
            "2021-04-13T01:24:06Z",
            "2021-04-13T01:21:20Z",
            "2021-03-18T01:39:16Z",
            "2021-03-18T01:38:09Z",
            "2021-03-18T01:37:04Z",
            "2021-03-17T22:19:12Z"
        ],
        "creation_date": "2014-06-26T18:46:23Z",
        "contributors": 30,
        "topics": [
            "browser",
            "data-channels",
            "javascript",
            "nodejs",
            "p2p",
            "peer-connection",
            "webrtc"
        ],
        "subscribers": 147,
        "readme": "# simple-peer [![ci][ci-image]][ci-url] [![coveralls][coveralls-image]][coveralls-url] [![npm][npm-image]][npm-url] [![downloads][downloads-image]][downloads-url] [![javascript style guide][standard-image]][standard-url] [![javascript style guide][sauce-image]][sauce-url]\n\n[ci-image]: https://img.shields.io/github/workflow/status/feross/simple-peer/ci/master\n[ci-url]: https://github.com/feross/simple-peer/actions\n[coveralls-image]: https://coveralls.io/repos/github/feross/simple-peer/badge.svg?branch=master\n[coveralls-url]: https://coveralls.io/github/feross/simple-peer?branch=master\n[npm-image]: https://img.shields.io/npm/v/simple-peer.svg\n[npm-url]: https://npmjs.org/package/simple-peer\n[downloads-image]: https://img.shields.io/npm/dm/simple-peer.svg\n[downloads-url]: https://npmjs.org/package/simple-peer\n[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg\n[standard-url]: https://standardjs.com\n[sauce-image]: https://saucelabs.com/buildstatus/simple-peer\n[sauce-url]: https://saucelabs.com/u/simple-peer\n\n#### Simple WebRTC video, voice, and data channels\n\n<h5 align=\"center\">\n  Sponsored by&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"http://dfinity.org/\"><img src=\"https://cdn.rawgit.com/feross/simple-peer/master/img/dfinity-sponsor.png\" alt=\"DFINITY\" width=250 valign=\"middle\"></a>\n</h5>\n\n> We are hiring a peer-to-peer WebRTC mobile Web application expert.\n>\n> [DFINITY](http://dfinity.org/) is building an exciting peer-to-peer WebRTC-based mobile Web app to help improve democracy on the Internet Computer blockchain. The mobile web app connects groups of up to four people in a peer-to-peer WebRTC audio and video call so that they can mutually prove unique personhood.\n>\n> We are looking for a software engineer or consultant who can help us solve (platform-dependent) reliability issues of our implementation. We are interested in applicants with substantial WebRTC experience for mobile Web apps, experience with different communication patterns (e.g., peer-to-peer, server relay), and substantial problem-solving skills. Having experience in automated testing of this type of applications is a plus. Pay is extremely competitive for the right expertise. For details, please see the [full job description](https://boards.greenhouse.io/dfinity/jobs/5910101002?gh_src=c28327ae2us). \n\n## features\n\n- concise, **node.js style** API for [WebRTC](https://en.wikipedia.org/wiki/WebRTC)\n- **works in node and the browser!**\n- supports **video/voice streams**\n- supports **data channel**\n  - text and binary data\n  - node.js [duplex stream](http://nodejs.org/api/stream.html) interface\n- supports advanced options like:\n  - enable/disable [trickle ICE candidates](http://webrtchacks.com/trickle-ice/)\n  - manually set config options\n  - transceivers and renegotiation\n\nThis package is used by [WebTorrent](https://webtorrent.io) and [many others](#who-is-using-simple-peer).\n\n- [install](#install)\n- [examples](#usage)\n  * [A simpler example](#a-simpler-example)\n  * [data channels](#data-channels)\n  * [video/voice](#videovoice)\n  * [dynamic video/voice](#dynamic-videovoice)\n  * [in node](#in-node)\n- [api](#api)\n- [events](#events)\n- [error codes](#error-codes)\n- [connecting more than 2 peers?](#connecting-more-than-2-peers)\n- [memory usage](#memory-usage)\n- [connection does not work on some networks?](#connection-does-not-work-on-some-networks)\n- [Who is using `simple-peer`?](#who-is-using-simple-peer)\n- [license](#license)\n\n## install\n\n```\nnpm install simple-peer\n```\n\nThis package works in the browser with [browserify](https://browserify.org). If\nyou do not use a bundler, you can use the `simplepeer.min.js` standalone script\ndirectly in a `<script>` tag. This exports a `SimplePeer` constructor on\n`window`. Wherever you see `Peer` in the examples below, substitute that with\n`SimplePeer`.\n\n## usage\n\nLet's create an html page that lets you manually connect two peers:\n\n```html\n<html>\n  <body>\n    <style>\n      #outgoing {\n        width: 600px;\n        word-wrap: break-word;\n        white-space: normal;\n      }\n    </style>\n    <form>\n      <textarea id=\"incoming\"></textarea>\n      <button type=\"submit\">submit</button>\n    </form>\n    <pre id=\"outgoing\"></pre>\n    <script src=\"simplepeer.min.js\"></script>\n    <script>\n      const p = new SimplePeer({\n        initiator: location.hash === '#1',\n        trickle: false\n      })\n\n      p.on('error', err => console.log('error', err))\n\n      p.on('signal', data => {\n        console.log('SIGNAL', JSON.stringify(data))\n        document.querySelector('#outgoing').textContent = JSON.stringify(data)\n      })\n\n      document.querySelector('form').addEventListener('submit', ev => {\n        ev.preventDefault()\n        p.signal(JSON.parse(document.querySelector('#incoming').value))\n      })\n\n      p.on('connect', () => {\n        console.log('CONNECT')\n        p.send('whatever' + Math.random())\n      })\n\n      p.on('data', data => {\n        console.log('data: ' + data)\n      })\n    </script>\n  </body>\n</html>\n```\n\nVisit `index.html#1` from one browser (the initiator) and `index.html` from another\nbrowser (the receiver).\n\nAn \"offer\" will be generated by the initiator. Paste this into the receiver's form and\nhit submit. The receiver generates an \"answer\". Paste this into the initiator's form and\nhit submit.\n\nNow you have a direct P2P connection between two browsers!\n\n### A simpler example\n\nThis example create two peers **in the same web page**.\n\nIn a real-world application, *you would never do this*. The sender and receiver `Peer`\ninstances would exist in separate browsers. A \"signaling server\" (usually implemented with\nwebsockets) would be used to exchange signaling data between the two browsers until a\npeer-to-peer connection is established.\n\n### data channels\n\n```js\nvar Peer = require('simple-peer')\n\nvar peer1 = new Peer({ initiator: true })\nvar peer2 = new Peer()\n\npeer1.on('signal', data => {\n  // when peer1 has signaling data, give it to peer2 somehow\n  peer2.signal(data)\n})\n\npeer2.on('signal', data => {\n  // when peer2 has signaling data, give it to peer1 somehow\n  peer1.signal(data)\n})\n\npeer1.on('connect', () => {\n  // wait for 'connect' event before using the data channel\n  peer1.send('hey peer2, how is it going?')\n})\n\npeer2.on('data', data => {\n  // got a data channel message\n  console.log('got a message from peer1: ' + data)\n})\n```\n\n### video/voice\n\nVideo/voice is also super simple! In this example, peer1 sends video to peer2.\n\n```js\nvar Peer = require('simple-peer')\n\n// get video/voice stream\nnavigator.mediaDevices.getUserMedia({\n  video: true,\n  audio: true\n}).then(gotMedia).catch(() => {})\n\nfunction gotMedia (stream) {\n  var peer1 = new Peer({ initiator: true, stream: stream })\n  var peer2 = new Peer()\n\n  peer1.on('signal', data => {\n    peer2.signal(data)\n  })\n\n  peer2.on('signal', data => {\n    peer1.signal(data)\n  })\n\n  peer2.on('stream', stream => {\n    // got remote video stream, now let's show it in a video tag\n    var video = document.querySelector('video')\n\n    if ('srcObject' in video) {\n      video.srcObject = stream\n    } else {\n      video.src = window.URL.createObjectURL(stream) // for older browsers\n    }\n\n    video.play()\n  })\n}\n```\n\nFor two-way video, simply pass a `stream` option into both `Peer` constructors. Simple!\n\nPlease notice that `getUserMedia` only works in [pages loaded via **https**](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Encryption_based_security).\n\n### dynamic video/voice\n\nIt is also possible to establish a data-only connection at first, and later add\na video/voice stream, if desired.\n\n```js\nvar Peer = require('simple-peer') // create peer without waiting for media\n\nvar peer1 = new Peer({ initiator: true }) // you don't need streams here\nvar peer2 = new Peer()\n\npeer1.on('signal', data => {\n  peer2.signal(data)\n})\n\npeer2.on('signal', data => {\n  peer1.signal(data)\n})\n\npeer2.on('stream', stream => {\n  // got remote video stream, now let's show it in a video tag\n  var video = document.querySelector('video')\n\n  if ('srcObject' in video) {\n    video.srcObject = stream\n  } else {\n    video.src = window.URL.createObjectURL(stream) // for older browsers\n  }\n\n  video.play()\n})\n\nfunction addMedia (stream) {\n  peer1.addStream(stream) // <- add streams to peer dynamically\n}\n\n// then, anytime later...\nnavigator.mediaDevices.getUserMedia({\n  video: true,\n  audio: true\n}).then(addMedia).catch(() => {})\n```\n\n### in node\n\nTo use this library in node, pass in `opts.wrtc` as a parameter (see [the constructor options](#peer--new-peeropts)):\n\n```js\nvar Peer = require('simple-peer')\nvar wrtc = require('wrtc')\n\nvar peer1 = new Peer({ initiator: true, wrtc: wrtc })\nvar peer2 = new Peer({ wrtc: wrtc })\n```\n\n## api\n\n### `peer = new Peer([opts])`\n\nCreate a new WebRTC peer connection.\n\nA \"data channel\" for text/binary communication is always established, because it's cheap and often useful. For video/voice communication, pass the `stream` option.\n\nIf `opts` is specified, then the default options (shown below) will be overridden.\n\n```\n{\n  initiator: false,\n  channelConfig: {},\n  channelName: '<random string>',\n  config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478?transport=udp' }] },\n  offerOptions: {},\n  answerOptions: {},\n  sdpTransform: function (sdp) { return sdp },\n  stream: false,\n  streams: [],\n  trickle: true,\n  allowHalfTrickle: false,\n  wrtc: {}, // RTCPeerConnection/RTCSessionDescription/RTCIceCandidate\n  objectMode: false\n}\n```\n\nThe options do the following:\n\n- `initiator` - set to `true` if this is the initiating peer\n- `channelConfig` - custom webrtc data channel configuration (used by [`createDataChannel`](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel))\n- `channelName` - custom webrtc data channel name\n- `config` - custom webrtc configuration (used by [`RTCPeerConnection`](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection) constructor)\n- `offerOptions` - custom offer options (used by [`createOffer`](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer) method)\n- `answerOptions` - custom answer options (used by [`createAnswer`](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createAnswer) method)\n- `sdpTransform` - function to transform the generated SDP signaling data (for advanced users)\n- `stream` - if video/voice is desired, pass stream returned from [`getUserMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n- `streams` - an array of MediaStreams returned from [`getUserMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n- `trickle` - set to `false` to disable [trickle ICE](http://webrtchacks.com/trickle-ice/) and get a single 'signal' event (slower)\n- `wrtc` - custom webrtc implementation, mainly useful in node to specify in the [wrtc](https://npmjs.com/package/wrtc) package. Contains an object with the properties:\n  - [`RTCPeerConnection`](https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection)\n  - [`RTCSessionDescription`](https://www.w3.org/TR/webrtc/#dom-rtcsessiondescription)\n  - [`RTCIceCandidate`](https://www.w3.org/TR/webrtc/#dom-rtcicecandidate)\n\n- `objectMode` - set to `true` to create the stream in [Object Mode](https://nodejs.org/api/stream.html#stream_object_mode). In this mode, incoming string data is not automatically converted to `Buffer` objects.\n\n### `peer.signal(data)`\n\nCall this method whenever the remote peer emits a `peer.on('signal')` event.\n\nThe `data` will encapsulate a webrtc offer, answer, or ice candidate. These messages help\nthe peers to eventually establish a direct connection to each other. The contents of these\nstrings are an implementation detail that can be ignored by the user of this module;\nsimply pass the data from 'signal' events to the remote peer and call `peer.signal(data)`\nto get connected.\n\n### `peer.send(data)`\n\nSend text/binary data to the remote peer. `data` can be any of several types: `String`,\n`Buffer` (see [buffer](https://github.com/feross/buffer)), `ArrayBufferView` (`Uint8Array`,\netc.), `ArrayBuffer`, or `Blob` (in browsers that support it).\n\nNote: If this method is called before the `peer.on('connect')` event has fired, then an exception will be thrown. Use `peer.write(data)` (which is inherited from the node.js [duplex stream](http://nodejs.org/api/stream.html) interface) if you want this data to be buffered instead.\n\n### `peer.addStream(stream)`\n\nAdd a `MediaStream` to the connection.\n\n### `peer.removeStream(stream)`\n\nRemove a `MediaStream` from the connection.\n\n### `peer.addTrack(track, stream)`\n\nAdd a `MediaStreamTrack` to the connection. Must also pass the `MediaStream` you want to attach it to.\n\n### `peer.removeTrack(track, stream)`\n\nRemove a `MediaStreamTrack` from the connection. Must also pass the `MediaStream` that it was attached to.\n\n### `peer.replaceTrack(oldTrack, newTrack, stream)`\n\nReplace a `MediaStreamTrack` with another track. Must also pass the `MediaStream` that the old track was attached to.\n\n### `peer.addTransceiver(kind, init)`\n\nAdd a `RTCRtpTransceiver` to the connection. Can be used to add transceivers before adding tracks. Automatically called as neccesary by `addTrack`.\n\n### `peer.destroy([err])`\n\nDestroy and cleanup this peer connection.\n\nIf the optional `err` parameter is passed, then it will be emitted as an `'error'`\nevent on the stream.\n\n### `Peer.WEBRTC_SUPPORT`\n\nDetect native WebRTC support in the javascript environment.\n\n```js\nvar Peer = require('simple-peer')\n\nif (Peer.WEBRTC_SUPPORT) {\n  // webrtc support!\n} else {\n  // fallback\n}\n```\n\n### duplex stream\n\n`Peer` objects are instances of `stream.Duplex`. They behave very similarly to a\n`net.Socket` from the node core `net` module. The duplex stream reads/writes to the data\nchannel.\n\n```js\nvar peer = new Peer(opts)\n// ... signaling ...\npeer.write(new Buffer('hey'))\npeer.on('data', function (chunk) {\n  console.log('got a chunk', chunk)\n})\n```\n\n## events\n\n`Peer` objects are instance of `EventEmitter`. Take a look at the [nodejs events documentation](https://nodejs.org/api/events.html) for more information.\n\nExample of removing all registered **close**-event listeners:\n```js\npeer.removeAllListeners('close')\n```\n\n### `peer.on('signal', data => {})`\n\nFired when the peer wants to send signaling data to the remote peer.\n\n**It is the responsibility of the application developer (that's you!) to get this data to\nthe other peer.** This usually entails using a websocket signaling server. This data is an\n`Object`, so  remember to call `JSON.stringify(data)` to serialize it first. Then, simply\ncall `peer.signal(data)` on the remote peer.\n\n(Be sure to listen to this event immediately to avoid missing it. For `initiator: true`\npeers, it fires right away. For `initatior: false` peers, it fires when the remote\noffer is received.)\n\n### `peer.on('connect', () => {})`\n\nFired when the peer connection and data channel are ready to use.\n\n### `peer.on('data', data => {})`\n\nReceived a message from the remote peer (via the data channel).\n\n`data` will be either a `String` or a `Buffer/Uint8Array` (see [buffer](https://github.com/feross/buffer)).\n\n### `peer.on('stream', stream => {})`\n\nReceived a remote video stream, which can be displayed in a video tag:\n\n```js\npeer.on('stream', stream => {\n  var video = document.querySelector('video')\n  if ('srcObject' in video) {\n    video.srcObject = stream\n  } else {\n    video.src = window.URL.createObjectURL(stream)\n  }\n  video.play()\n})\n```\n\n### `peer.on('track', (track, stream) => {})`\n\nReceived a remote audio/video track. Streams may contain multiple tracks.\n\n### `peer.on('close', () => {})`\n\nCalled when the peer connection has closed.\n\n### `peer.on('error', (err) => {})`\n\nFired when a fatal error occurs. Usually, this means bad signaling data was received from the remote peer.\n\n`err` is an `Error` object.\n\n## error codes\n\nErrors returned by the `error` event have an `err.code` property that will indicate the origin of the failure.\n\nPossible error codes:\n- `ERR_WEBRTC_SUPPORT`\n- `ERR_CREATE_OFFER`\n- `ERR_CREATE_ANSWER`\n- `ERR_SET_LOCAL_DESCRIPTION`\n- `ERR_SET_REMOTE_DESCRIPTION`\n- `ERR_ADD_ICE_CANDIDATE`\n- `ERR_ICE_CONNECTION_FAILURE`\n- `ERR_SIGNALING`\n- `ERR_DATA_CHANNEL`\n- `ERR_CONNECTION_FAILURE`\n\n\n## connecting more than 2 peers?\n\nThe simplest way to do that is to create a full-mesh topology. That means that every peer\nopens a connection to every other peer. To illustrate:\n\n![full mesh topology](img/full-mesh.png)\n\nTo broadcast a message, just iterate over all the peers and call `peer.send`.\n\nSo, say you have 3 peers. Then, when a peer wants to send some data it must send it 2\ntimes, once to each of the other peers. So you're going to want to be a bit careful about\nthe size of the data you send.\n\nFull mesh topologies don't scale well when the number of peers is very large. The total\nnumber of edges in the network will be ![full mesh formula](img/full-mesh-formula.png)\nwhere `n` is the number of peers.\n\nFor clarity, here is the code to connect 3 peers together:\n\n#### Peer 1\n\n```js\n// These are peer1's connections to peer2 and peer3\nvar peer2 = new Peer({ initiator: true })\nvar peer3 = new Peer({ initiator: true })\n\npeer2.on('signal', data => {\n  // send this signaling data to peer2 somehow\n})\n\npeer2.on('connect', () => {\n  peer2.send('hi peer2, this is peer1')\n})\n\npeer2.on('data', data => {\n  console.log('got a message from peer2: ' + data)\n})\n\npeer3.on('signal', data => {\n  // send this signaling data to peer3 somehow\n})\n\npeer3.on('connect', () => {\n  peer3.send('hi peer3, this is peer1')\n})\n\npeer3.on('data', data => {\n  console.log('got a message from peer3: ' + data)\n})\n```\n\n#### Peer 2\n\n```js\n// These are peer2's connections to peer1 and peer3\nvar peer1 = new Peer()\nvar peer3 = new Peer({ initiator: true })\n\npeer1.on('signal', data => {\n  // send this signaling data to peer1 somehow\n})\n\npeer1.on('connect', () => {\n  peer1.send('hi peer1, this is peer2')\n})\n\npeer1.on('data', data => {\n  console.log('got a message from peer1: ' + data)\n})\n\npeer3.on('signal', data => {\n  // send this signaling data to peer3 somehow\n})\n\npeer3.on('connect', () => {\n  peer3.send('hi peer3, this is peer2')\n})\n\npeer3.on('data', data => {\n  console.log('got a message from peer3: ' + data)\n})\n```\n\n#### Peer 3\n\n```js\n// These are peer3's connections to peer1 and peer2\nvar peer1 = new Peer()\nvar peer2 = new Peer()\n\npeer1.on('signal', data => {\n  // send this signaling data to peer1 somehow\n})\n\npeer1.on('connect', () => {\n  peer1.send('hi peer1, this is peer3')\n})\n\npeer1.on('data', data => {\n  console.log('got a message from peer1: ' + data)\n})\n\npeer2.on('signal', data => {\n  // send this signaling data to peer2 somehow\n})\n\npeer2.on('connect', () => {\n  peer2.send('hi peer2, this is peer3')\n})\n\npeer2.on('data', data => {\n  console.log('got a message from peer2: ' + data)\n})\n```\n\n## memory usage\n\nIf you call `peer.send(buf)`, `simple-peer` is not keeping a reference to `buf`\nand sending the buffer at some later point in time. We immediately call\n`channel.send()` on the data channel. So it should be fine to mutate the buffer\nright afterward.\n\nHowever, beware that `peer.write(buf)` (a writable stream method) does not have\nthe same contract. It will potentially buffer the data and call\n`channel.send()` at a future point in time, so definitely don't assume it's\nsafe to mutate the buffer.\n\n\n## connection does not work on some networks?\n\nIf a direct connection fails, in particular, because of NAT traversal and/or firewalls,\nWebRTC ICE uses an intermediary (relay) TURN server. In other words, ICE will first use\nSTUN with UDP to directly connect peers and, if that fails, will fall back to a TURN relay\nserver.\n\nIn order to use a TURN server, you must specify the `config` option to the `Peer`\nconstructor. See the API docs above.\n\n[![js-standard-style](https://cdn.rawgit.com/feross/standard/master/badge.svg)](https://github.com/feross/standard)\n\n\n## Who is using `simple-peer`?\n\n- [WebTorrent](http://webtorrent.io) - Streaming torrent client in the browser\n- [Virus Cafe](https://virus.cafe) - Make a friend in 2 minutes\n- [Instant.io](https://instant.io) - Secure, anonymous, streaming file transfer\n- [Zencastr](https://zencastr.com) - Easily record your remote podcast interviews in studio quality.\n- [Friends](https://github.com/moose-team/friends) - Peer-to-peer chat powered by the web\n- [Socket.io-p2p](https://github.com/socketio/socket.io-p2p) - Official Socket.io P2P communication library\n- [ScreenCat](https://maxogden.github.io/screencat/) - Screen sharing + remote collaboration app\n- [WebCat](https://www.npmjs.com/package/webcat) - P2P pipe across the web using Github private/public key for auth\n- [RTCCat](https://www.npmjs.com/package/rtcat) - WebRTC netcat\n- [PeerNet](https://www.npmjs.com/package/peernet) - Peer-to-peer gossip network using randomized algorithms\n- [PusherTC](http://pushertc.herokuapp.com) - Video chat with using Pusher. See [guide](http://blog.carbonfive.com/2014/10/16/webrtc-made-simple/).\n- [lxjs-chat](https://github.com/feross/lxjs-chat) - Omegle-like video chat site\n- [Whiteboard](https://github.com/feross/whiteboard) - P2P Whiteboard powered by WebRTC and WebTorrent\n- [Peer Calls](https://peercalls.com) - WebRTC group video calling. Create a room. Share the link.\n- [Netsix](https://mmorainville.github.io/netsix-gh-pages/) - Send videos to your friends using WebRTC so that they can watch them right away.\n- [Stealthy](https://www.stealthy.im) - Stealthy is a decentralized, end-to-end encrypted, p2p chat application.\n- [oorja.io](https://github.com/akshayKMR/oorja) - Effortless video-voice chat with realtime collaborative features. Extensible using react components \ud83d\ude4c\n- [TalktoMe](https://talktome.universal-apps.xyz) - Skype alternative for audio/video conferencing based on WebRTC, but without the loss of packets.\n- [CDNBye](https://github.com/cdnbye/hlsjs-p2p-engine) - CDNBye implements WebRTC datachannel to scale live/vod video streaming by peer-to-peer network using bittorrent-like protocol\n- [Detox](https://github.com/Detox) - Overlay network for distributed anonymous P2P communications entirely in the browser\n- [Metastream](https://github.com/samuelmaddock/metastream) - Watch streaming media with friends.\n- [firepeer](https://github.com/natzcam/firepeer) - secure signalling and authentication using firebase realtime database\n- [Genet](https://github.com/elavoie/webrtc-tree-overlay) - Fat-tree overlay to scale the number of concurrent WebRTC connections to a single source ([paper](https://arxiv.org/abs/1904.11402)).\n- [WebRTC Connection Testing](https://github.com/elavoie/webrtc-connection-testing) - Quickly test direct connectivity between all pairs of participants ([demo](https://webrtc-connection-testing.herokuapp.com/)).\n- [Firstdate.co](https://firstdate.co) - Online video dating for actually meeting people and not just messaging them\n- [TensorChat](https://github.com/EhsaanIqbal/tensorchat) - It's simple - Create. Share. Chat.\n- [On/Office](https://onoffice.app) - View your desktop in a WebVR-powered environment\n- [Cyph](https://www.cyph.com) - Cryptographically secure messaging and social networking service, providing an extreme level of privacy combined with best-in-class ease of use\n- [Ciphora](https://github.com/HR/ciphora) - A peer-to-peer end-to-end encrypted messaging chat app.\n- [Whisthub](https://www.whisthub.com) - Online card game Color Whist with the possibility to start a video chat while playing.\n- [Brie.fi/ng](https://brie.fi/ng) - Secure anonymous video chat\n- [Peer.School](https://github.com/holtwick/peer2school) - Simple virtual classroom starting from the 1st class including video chat and real time whiteboard\n- [FileFire](https://filefire.ca) - Transfer large files and folders at high speed without size limits.\n- [safeShare](https://github.com/vj-abishek/airdrop) - Transfer files easily with text and voice communication.\n- [CubeChat](https://cubechat.io) - Party in 3D \ud83c\udf89\n- [Homely School](https://homelyschool.com) - A virtual schooling system\n- [AnyDrop](https://anydrop.io) - Cross-platform AirDrop alternative [with an Android app available at Google Play](https://play.google.com/store/apps/details?id=com.benjijanssens.anydrop)\n- [Share-Anywhere](https://share-anywhere.com/) - Cross-platform file transfer\n- [QuaranTime.io](https://quarantime.io/) - The Activity board-game in video!\n- [Trango](https://web.trango.io) - Cross-platform calling and file sharing solution.\n- [P2PT](https://github.com/subins2000/p2pt) - Use WebTorrent trackers as signalling servers for making WebRTC connections\n- [Dots](https://github.com/subins2000/vett) - Online multiplayer Dots & Boxes game. [Play Here!](https://vett.space)\n- [simple-peer-files](https://github.com/subins2000/simple-peer-files) - A simple library to easily transfer files over WebRTC. Has a feature to resume file transfer after uploader interruption.\n- [WebDrop.Space](https://WebDrop.Space) - Share files and messages across devices. Cross-platform, no installation alternative to AirDrop, Xender. [Source Code](https://github.com/subins2000/WebDrop)\n- [Speakrandom](https://speakrandom.com) - Voice-chat social network using simple-peer to create audio conferences!\n- [Deskreen](https://deskreen.com) - A desktop app that helps you to turn any device into a secondary screen for your computer. It uses simple-peer for sharing entire computer screen to any device with a web browser.\n\n\n\n- *Your app here! - send a PR!*\n\n## license\n\nMIT. Copyright (c) [Feross Aboukhadijeh](http://feross.org).\n",
        "releases": []
    }
}
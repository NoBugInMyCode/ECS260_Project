{
    "https://api.github.com/repos/reduxjs/redux-thunk": {
        "forks": 1042,
        "watchers": 17765,
        "stars": 17765,
        "languages": {
            "TypeScript": 15306,
            "JavaScript": 777
        },
        "commits": [
            "2024-10-10T17:24:00Z",
            "2024-09-12T13:59:05Z",
            "2024-08-17T18:01:54Z",
            "2024-08-16T13:52:23Z",
            "2024-07-12T22:57:22Z",
            "2024-03-22T15:50:35Z",
            "2024-03-21T18:02:49Z",
            "2024-03-11T18:38:17Z",
            "2024-03-10T03:53:48Z",
            "2024-03-09T12:04:37Z",
            "2024-02-22T04:38:58Z",
            "2024-02-22T01:08:06Z",
            "2024-02-21T22:57:21Z",
            "2024-02-21T22:40:40Z",
            "2024-02-21T22:39:42Z",
            "2023-12-05T10:35:53Z",
            "2023-12-05T10:33:36Z",
            "2023-12-04T23:19:38Z",
            "2023-12-04T13:50:37Z",
            "2023-12-04T13:49:19Z",
            "2023-12-04T13:43:44Z",
            "2023-12-04T04:40:59Z",
            "2023-12-04T04:39:58Z",
            "2023-12-04T04:19:30Z",
            "2023-12-04T04:18:42Z",
            "2023-11-16T04:22:46Z",
            "2023-11-16T04:21:11Z",
            "2023-11-16T04:15:25Z",
            "2023-11-16T04:15:12Z",
            "2023-11-16T04:08:30Z"
        ],
        "creation_date": "2015-07-13T13:33:08Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 170,
        "readme": "# Redux Thunk\n\nThunk [middleware](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware) for Redux. It allows writing functions with logic inside that can interact with a Redux store's `dispatch` and `getState` methods.\n\nFor complete usage instructions and useful patterns, see the [Redux docs **Writing Logic with Thunks** page](https://redux.js.org/usage/writing-logic-thunks).\n\n![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/reduxjs/redux-thunk/test.yml?branch=master)\n[![npm version](https://img.shields.io/npm/v/redux-thunk.svg?style=flat-square)](https://www.npmjs.com/package/redux-thunk)\n[![npm downloads](https://img.shields.io/npm/dm/redux-thunk.svg?style=flat-square)](https://www.npmjs.com/package/redux-thunk)\n\n## Installation and Setup\n\n### Redux Toolkit\n\nIf you're using [our official Redux Toolkit package](https://redux-toolkit.js.org) as recommended, there's nothing to install - RTK's `configureStore` API already adds the thunk middleware by default:\n\n```js\nimport { configureStore } from '@reduxjs/toolkit'\n\nimport todosReducer from './features/todos/todosSlice'\nimport filtersReducer from './features/filters/filtersSlice'\n\nconst store = configureStore({\n  reducer: {\n    todos: todosReducer,\n    filters: filtersReducer,\n  },\n})\n\n// The thunk middleware was automatically added\n```\n\n### Manual Setup\n\nIf you're using the basic Redux `createStore` API and need to set this up manually, first add the `redux-thunk` package:\n\n```sh\nnpm install redux-thunk\n\nyarn add redux-thunk\n```\n\nThe thunk middleware is a named export.\n\n<details>\n<summary><b>More Details: Importing the thunk middleware</b></summary>\n\nIf you're using ES modules:\n\n```js\nimport { thunk } from 'redux-thunk'\n```\n\nIf you use Redux Thunk in a CommonJS environment:\n\n```js\nconst { thunk } = require('redux-thunk')\n```\n\n</details>\n\nThen, to enable Redux Thunk, use\n[`applyMiddleware()`](https://redux.js.org/api/applymiddleware):\n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport { thunk } from 'redux-thunk'\nimport rootReducer from './reducers/index'\n\nconst store = createStore(rootReducer, applyMiddleware(thunk))\n```\n\n### Injecting a Custom Argument\n\nSince 2.1.0, Redux Thunk supports injecting a custom argument into the thunk middleware. This is typically useful for cases like using an API service layer that could be swapped out for a mock service in tests.\n\nFor Redux Toolkit, the `getDefaultMiddleware` callback inside of `configureStore` lets you pass in a custom `extraArgument`:\n\n```js\nimport { configureStore } from '@reduxjs/toolkit'\nimport rootReducer from './reducer'\nimport { myCustomApiService } from './api'\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware({\n      thunk: {\n        extraArgument: myCustomApiService,\n      },\n    }),\n})\n\n// later\nfunction fetchUser(id) {\n  // The `extraArgument` is the third arg for thunk functions\n  return (dispatch, getState, api) => {\n    // you can use api here\n  }\n}\n```\n\nIf you need to pass in multiple values, combine them into a single object:\n\n```js\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware({\n      thunk: {\n        extraArgument: {\n          api: myCustomApiService,\n          otherValue: 42,\n        },\n      },\n    }),\n})\n\n// later\nfunction fetchUser(id) {\n  return (dispatch, getState, { api, otherValue }) => {\n    // you can use api and something else here\n  }\n}\n```\n\nIf you're setting up the store by hand, the named export `withExtraArgument()` function should be used to generate the correct thunk middleware:\n\n```js\nconst store = createStore(reducer, applyMiddleware(withExtraArgument(api)))\n```\n\n## Why Do I Need This?\n\nWith a plain basic Redux store, you can only do simple synchronous updates by\ndispatching an action. Middleware extends the store's abilities, and lets you\nwrite async logic that interacts with the store.\n\nThunks are the recommended middleware for basic Redux side effects logic,\nincluding complex synchronous logic that needs access to the store, and simple\nasync logic like AJAX requests.\n\nFor more details on why thunks are useful, see:\n\n- **Redux docs: Writing Logic with Thunks**  \n  https://redux.js.org/usage/writing-logic-thunks  \n  The official usage guide page on thunks. Covers why they exist, how the thunk middleware works, and useful patterns for using thunks.\n\n- **Stack Overflow: Dispatching Redux Actions with a Timeout**  \n  http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559  \n  Dan Abramov explains the basics of managing async behavior in Redux, walking\n  through a progressive series of approaches (inline async calls, async action\n  creators, thunk middleware).\n\n- **Stack Overflow: Why do we need middleware for async flow in Redux?**  \n  http://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594  \n  Dan Abramov gives reasons for using thunks and async middleware, and some\n  useful patterns for using thunks.\n\n- **What the heck is a \"thunk\"?**  \n  https://daveceddia.com/what-is-a-thunk/  \n  A quick explanation for what the word \"thunk\" means in general, and for Redux\n  specifically.\n\n- **Thunks in Redux: The Basics**  \n  https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60  \n  A detailed look at what thunks are, what they solve, and how to use them.\n\nYou may also want to read the\n**[Redux FAQ entry on choosing which async middleware to use](https://redux.js.org/faq/actions#what-async-middleware-should-i-use-how-do-you-decide-between-thunks-sagas-observables-or-something-else)**.\n\nWhile the thunk middleware is not directly included with the Redux core library,\nit is used by default in our\n**[`@reduxjs/toolkit` package](https://github.com/reduxjs/redux-toolkit)**.\n\n## Motivation\n\nRedux Thunk [middleware](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware)\nallows you to write action creators that return a function instead of an action.\nThe thunk can be used to delay the dispatch of an action, or to dispatch only if\na certain condition is met. The inner function receives the store methods\n`dispatch` and `getState` as parameters.\n\nAn action creator that returns a function to perform asynchronous dispatch:\n\n```js\nconst INCREMENT_COUNTER = 'INCREMENT_COUNTER'\n\nfunction increment() {\n  return {\n    type: INCREMENT_COUNTER,\n  }\n}\n\nfunction incrementAsync() {\n  return dispatch => {\n    setTimeout(() => {\n      // Yay! Can invoke sync or async actions with `dispatch`\n      dispatch(increment())\n    }, 1000)\n  }\n}\n```\n\nAn action creator that returns a function to perform conditional dispatch:\n\n```js\nfunction incrementIfOdd() {\n  return (dispatch, getState) => {\n    const { counter } = getState()\n\n    if (counter % 2 === 0) {\n      return\n    }\n\n    dispatch(increment())\n  }\n}\n```\n\n## What\u2019s a thunk?!\n\nA [thunk](https://en.wikipedia.org/wiki/Thunk) is a function that wraps an\nexpression to delay its evaluation.\n\n```js\n// calculation of 1 + 2 is immediate\n// x === 3\nlet x = 1 + 2\n\n// calculation of 1 + 2 is delayed\n// foo can be called later to perform the calculation\n// foo is a thunk!\nlet foo = () => 1 + 2\n```\n\nThe term [originated](https://en.wikipedia.org/wiki/Thunk#cite_note-1) as a\nhumorous past-tense version of \"think\".\n\n## Composition\n\nAny return value from the inner function will be available as the return value\nof `dispatch` itself. This is convenient for orchestrating an asynchronous\ncontrol flow with thunk action creators dispatching each other and returning\nPromises to wait for each other\u2019s completion:\n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport { thunk } from 'redux-thunk'\nimport rootReducer from './reducers'\n\n// Note: this API requires redux@>=3.1.0\nconst store = createStore(rootReducer, applyMiddleware(thunk))\n\nfunction fetchSecretSauce() {\n  return fetch('https://www.google.com/search?q=secret+sauce')\n}\n\n// These are the normal action creators you have seen so far.\n// The actions they return can be dispatched without any middleware.\n// However, they only express \u201cfacts\u201d and not the \u201casync flow\u201d.\n\nfunction makeASandwich(forPerson, secretSauce) {\n  return {\n    type: 'MAKE_SANDWICH',\n    forPerson,\n    secretSauce,\n  }\n}\n\nfunction apologize(fromPerson, toPerson, error) {\n  return {\n    type: 'APOLOGIZE',\n    fromPerson,\n    toPerson,\n    error,\n  }\n}\n\nfunction withdrawMoney(amount) {\n  return {\n    type: 'WITHDRAW',\n    amount,\n  }\n}\n\n// Even without middleware, you can dispatch an action:\nstore.dispatch(withdrawMoney(100))\n\n// But what do you do when you need to start an asynchronous action,\n// such as an API call, or a router transition?\n\n// Meet thunks.\n// A thunk in this context is a function that can be dispatched to perform async\n// activity and can dispatch actions and read state.\n// This is an action creator that returns a thunk:\nfunction makeASandwichWithSecretSauce(forPerson) {\n  // We can invert control here by returning a function - the \"thunk\".\n  // When this function is passed to `dispatch`, the thunk middleware will intercept it,\n  // and call it with `dispatch` and `getState` as arguments.\n  // This gives the thunk function the ability to run some logic, and still interact with the store.\n  return function (dispatch) {\n    return fetchSecretSauce().then(\n      sauce => dispatch(makeASandwich(forPerson, sauce)),\n      error => dispatch(apologize('The Sandwich Shop', forPerson, error)),\n    )\n  }\n}\n\n// Thunk middleware lets me dispatch thunk async actions\n// as if they were actions!\n\nstore.dispatch(makeASandwichWithSecretSauce('Me'))\n\n// It even takes care to return the thunk\u2019s return value\n// from the dispatch, so I can chain Promises as long as I return them.\n\nstore.dispatch(makeASandwichWithSecretSauce('My partner')).then(() => {\n  console.log('Done!')\n})\n\n// In fact I can write action creators that dispatch\n// actions and async actions from other action creators,\n// and I can build my control flow with Promises.\n\nfunction makeSandwichesForEverybody() {\n  return function (dispatch, getState) {\n    if (!getState().sandwiches.isShopOpen) {\n      // You don\u2019t have to return Promises, but it\u2019s a handy convention\n      // so the caller can always call .then() on async dispatch result.\n\n      return Promise.resolve()\n    }\n\n    // We can dispatch both plain object actions and other thunks,\n    // which lets us compose the asynchronous actions in a single flow.\n\n    return dispatch(makeASandwichWithSecretSauce('My Grandma'))\n      .then(() =>\n        Promise.all([\n          dispatch(makeASandwichWithSecretSauce('Me')),\n          dispatch(makeASandwichWithSecretSauce('My wife')),\n        ]),\n      )\n      .then(() => dispatch(makeASandwichWithSecretSauce('Our kids')))\n      .then(() =>\n        dispatch(\n          getState().myMoney > 42\n            ? withdrawMoney(42)\n            : apologize('Me', 'The Sandwich Shop'),\n        ),\n      )\n  }\n}\n\n// This is very useful for server side rendering, because I can wait\n// until data is available, then synchronously render the app.\n\nstore\n  .dispatch(makeSandwichesForEverybody())\n  .then(() =>\n    response.send(ReactDOMServer.renderToString(<MyApp store={store} />)),\n  )\n\n// I can also dispatch a thunk async action from a component\n// any time its props change to load the missing data.\n\nimport { connect } from 'react-redux'\nimport { Component } from 'react'\n\nclass SandwichShop extends Component {\n  componentDidMount() {\n    this.props.dispatch(makeASandwichWithSecretSauce(this.props.forPerson))\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.forPerson !== this.props.forPerson) {\n      this.props.dispatch(makeASandwichWithSecretSauce(this.props.forPerson))\n    }\n  }\n\n  render() {\n    return <p>{this.props.sandwiches.join('mustard')}</p>\n  }\n}\n\nexport default connect(state => ({\n  sandwiches: state.sandwiches,\n}))(SandwichShop)\n```\n\n## License\n\nMIT\n",
        "releases": [
            {
                "name": "v3.1.0",
                "date": "2023-12-04T13:57:13Z"
            },
            {
                "name": "v3.0.0-rc.0",
                "date": "2023-11-17T03:52:58Z"
            },
            {
                "name": "v3.0.0-beta.0",
                "date": "2023-08-26T21:26:17Z"
            },
            {
                "name": "v3.0.0-alpha.3",
                "date": "2023-04-03T17:43:24Z"
            },
            {
                "name": "v3.0.0-alpha.1",
                "date": "2023-01-21T02:40:15Z"
            },
            {
                "name": "v2.4.2",
                "date": "2022-11-04T01:59:17Z"
            },
            {
                "name": "v2.4.1",
                "date": "2021-11-26T20:21:09Z"
            },
            {
                "name": "v2.4.0",
                "date": "2021-10-26T01:19:05Z"
            },
            {
                "name": "v2.3.0",
                "date": "2018-05-28T18:48:26Z"
            },
            {
                "name": "v2.2.0",
                "date": "2017-01-18T08:14:57Z"
            },
            {
                "name": "v2.1.2",
                "date": "2017-01-18T08:14:19Z"
            },
            {
                "name": "v2.1.1",
                "date": "2017-01-18T06:19:56Z"
            },
            {
                "name": "v2.1.0",
                "date": "2016-05-10T15:13:54Z"
            },
            {
                "name": "v2.0.1",
                "date": "2016-03-06T13:17:48Z"
            },
            {
                "name": "v2.0.0",
                "date": "2016-03-06T13:07:11Z"
            },
            {
                "name": "v1.0.3",
                "date": "2015-12-28T22:31:05Z"
            },
            {
                "name": "v1.0.2",
                "date": "2015-12-14T08:59:05Z"
            },
            {
                "name": "v1.0.1",
                "date": "2015-12-13T20:21:58Z"
            },
            {
                "name": "v1.0.0",
                "date": "2015-09-17T17:25:40Z"
            },
            {
                "name": "v0.1.0",
                "date": "2015-07-13T13:34:46Z"
            }
        ]
    }
}
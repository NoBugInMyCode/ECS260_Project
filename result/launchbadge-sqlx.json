{
    "https://api.github.com/repos/launchbadge/sqlx": {
        "forks": 1309,
        "watchers": 13940,
        "stars": 13940,
        "languages": {
            "Rust": 2243719,
            "Python": 11846,
            "Shell": 3537,
            "Dockerfile": 2031,
            "PLpgSQL": 1665,
            "TSQL": 383
        },
        "commits": [
            "2025-01-16T01:08:16Z",
            "2025-01-15T16:41:57Z",
            "2025-01-04T16:38:57Z",
            "2025-01-09T04:17:59Z",
            "2025-01-07T00:00:18Z",
            "2025-01-04T05:24:04Z",
            "2025-01-04T04:28:57Z",
            "2025-01-03T08:26:09Z",
            "2024-12-25T01:00:40Z",
            "2024-12-23T00:48:54Z",
            "2024-12-16T17:21:57Z",
            "2024-12-20T15:07:36Z",
            "2024-12-17T13:42:28Z",
            "2024-12-12T20:52:30Z",
            "2024-12-09T12:23:14Z",
            "2024-12-12T20:43:22Z",
            "2024-11-28T03:00:13Z",
            "2024-11-28T00:39:18Z",
            "2024-11-27T22:49:08Z",
            "2024-11-27T22:45:46Z",
            "2024-11-27T22:14:00Z",
            "2024-11-27T21:56:01Z",
            "2024-11-27T21:52:23Z",
            "2024-11-27T21:51:52Z",
            "2024-11-27T21:48:34Z",
            "2024-11-27T21:35:42Z",
            "2024-11-26T19:01:33Z",
            "2024-11-26T19:01:18Z",
            "2024-11-26T19:00:05Z",
            "2024-11-26T18:59:47Z"
        ],
        "creation_date": "2019-12-28T10:40:57Z",
        "contributors": 30,
        "topics": [
            "async",
            "await",
            "mariadb",
            "mysql",
            "postgres",
            "postgresql",
            "rust",
            "sql",
            "sqlite"
        ],
        "subscribers": 65,
        "readme": "<h1 align=\"center\">SQLx</h1>\n<div align=\"center\">\n <strong>\n   \ud83e\uddf0 The Rust SQL Toolkit\n </strong>\n</div>\n\n<br />\n\n<div align=\"center\">\n  <!-- Github Actions -->\n  <a href=\"https://github.com/launchbadge/sqlx/actions/workflows/sqlx.yml?query=branch%3Amain\">\n    <img src=\"https://img.shields.io/github/actions/workflow/status/launchbadge/sqlx/sqlx.yml?branch=main&style=flat-square\" alt=\"actions status\" /></a>\n  <!-- Version -->\n  <a href=\"https://crates.io/crates/sqlx\">\n    <img src=\"https://img.shields.io/crates/v/sqlx.svg?style=flat-square\"\n    alt=\"Crates.io version\" /></a>\n  <!-- Discord -->\n  <a href=\"https://discord.gg/uuruzJ7\">\n  <img src=\"https://img.shields.io/discord/665528275556106240?style=flat-square\" alt=\"chat\" /></a>\n  <!-- Docs -->\n  <a href=\"https://docs.rs/sqlx\">\n  <img src=\"https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square\" alt=\"docs.rs docs\" /></a>\n  <!-- Downloads -->\n  <a href=\"https://crates.io/crates/sqlx\">\n    <img src=\"https://img.shields.io/crates/d/sqlx.svg?style=flat-square\" alt=\"Download\" />\n  </a>\n</div>\n\n<div align=\"center\">\n  <h4>\n    <a href=\"#install\">\n      Install\n    </a>\n    <span> | </span>\n    <a href=\"#usage\">\n      Usage\n    </a>\n    <span> | </span>\n    <a href=\"https://docs.rs/sqlx\">\n      Docs\n    </a>\n    <span> | </span>\n    <a href=\"https://github.com/launchbadge/sqlx/wiki/Ecosystem\">\n      Ecosystem\n    </a>    \n    <span> | </span>\n    <a href=\"https://discord.gg/uuruzJ7\">\n      Discord\n    </a>\n  </h4>\n</div>\n\n<br />\n\n<div align=\"center\">\n  <small>Built with \u2764\ufe0f by <a href=\"https://launchbadge.com\">The LaunchBadge team</a></small>\n</div>\n\n<br />\n\n<div align=\"center\">\n    <h5>Have a question? Be sure to <a href=\"FAQ.md\">check the FAQ first!</a></h5>\n</div>\n\n<br />\n\nSQLx is an async, pure Rust<sub>\u2020</sub> SQL crate featuring compile-time checked queries without a DSL.\n\n-   **Truly Asynchronous**. Built from the ground-up using async/await for maximum concurrency.\n\n-   **Compile-time checked queries** (if you want). See [SQLx is not an ORM](#sqlx-is-not-an-orm).\n\n-   **Database Agnostic**. Support for [PostgreSQL], [MySQL], [MariaDB], [SQLite].\n    -   [MSSQL] was supported prior to version 0.7, but has been removed pending a full rewrite of the driver as part of our [SQLx Pro initiative].\n\n-   **Pure Rust**. The Postgres and MySQL/MariaDB drivers are written in pure Rust using **zero** unsafe<sub>\u2020\u2020</sub> code.\n\n-   **Runtime Agnostic**. Works on different runtimes ([`async-std`] / [`tokio`] / [`actix`]) and TLS backends ([`native-tls`], [`rustls`]).\n\n<small><small>\n\n\u2020 The SQLite driver uses the libsqlite3 C library as SQLite is an embedded database (the only way\nwe could be pure Rust for SQLite is by porting _all_ of SQLite to Rust).\n\n\u2020\u2020 SQLx uses `#![forbid(unsafe_code)]` unless the `sqlite` feature is enabled.\nThe SQLite driver directly invokes the SQLite3 API via `libsqlite3-sys`, which requires `unsafe`.\n\n</small></small>\n\n[postgresql]: http://postgresql.org/\n[sqlite]: https://sqlite.org/\n[mysql]: https://www.mysql.com/\n[mariadb]: https://www.mariadb.org/\n[mssql]: https://www.microsoft.com/en-us/sql-server\n[SQLx Pro initiative]: https://github.com/launchbadge/sqlx/discussions/1616\n\n---\n\n-   Cross-platform. Being native Rust, SQLx will compile anywhere Rust is supported.\n\n-   Built-in connection pooling with `sqlx::Pool`.\n\n-   Row streaming. Data is read asynchronously from the database and decoded on demand.\n\n-   Automatic statement preparation and caching. When using the high-level query API (`sqlx::query`), statements are\n    prepared and cached per connection.\n\n-   Simple (unprepared) query execution including fetching results into the same `Row` types used by\n    the high-level API. Supports batch execution and returns results from all statements.\n\n-   Transport Layer Security (TLS) where supported ([MySQL], [MariaDB] and [PostgreSQL]).\n\n-   Asynchronous notifications using `LISTEN` and `NOTIFY` for [PostgreSQL].\n\n-   Nested transactions with support for save points.\n\n-   `Any` database driver for changing the database driver at runtime. An `AnyPool` connects to the driver indicated by the URL scheme.\n\n## Install\n\nSQLx is compatible with the [`async-std`], [`tokio`], and [`actix`] runtimes; and, the [`native-tls`] and [`rustls`] TLS backends. When adding the dependency, you must choose a runtime feature that is `runtime` + `tls`.\n\n[`async-std`]: https://github.com/async-rs/async-std\n[`tokio`]: https://github.com/tokio-rs/tokio\n[`actix`]: https://github.com/actix/actix-net\n[`native-tls`]: https://crates.io/crates/native-tls\n[`rustls`]: https://crates.io/crates/rustls\n\n```toml\n# Cargo.toml\n[dependencies]\n# PICK ONE OF THE FOLLOWING:\n\n# tokio (no TLS)\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\" ] }\n# tokio + native-tls\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-native-tls\" ] }\n# tokio + rustls with ring and WebPKI CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-ring-webpki\" ] }\n# tokio + rustls with ring and platform's native CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-ring-native-roots\" ] }\n# tokio + rustls with aws-lc-rs\nsqlx = { version = \"0.8\", features = [ \"runtime-tokio\", \"tls-rustls-aws-lc-rs\" ] }\n\n# async-std (no TLS)\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\" ] }\n# async-std + native-tls\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-native-tls\" ] }\n# async-std + rustls with ring and WebPKI CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-ring-webpki\" ] }\n# async-std + rustls with ring and platform's native CA certificates\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-ring-native-roots\" ] }\n# async-std + rustls with aws-lc-rs\nsqlx = { version = \"0.8\", features = [ \"runtime-async-std\", \"tls-rustls-aws-lc-rs\" ] }\n```\n\n#### Cargo Feature Flags\n\nFor backward-compatibility reasons, the runtime and TLS features can either be chosen together as a single feature,\nor separately.\n\nFor forward compatibility, you should use the separate runtime and TLS features as the combination features may\nbe removed in the future.\n\n-   `runtime-async-std`: Use the `async-std` runtime without enabling a TLS backend.\n\n-   `runtime-async-std-native-tls`: Use the `async-std` runtime and `native-tls` TLS backend (SOFT-DEPRECATED).\n\n-   `runtime-async-std-rustls`: Use the `async-std` runtime and `rustls` TLS backend (SOFT-DEPRECATED).\n\n-   `runtime-tokio`: Use the `tokio` runtime without enabling a TLS backend.\n\n-   `runtime-tokio-native-tls`: Use the `tokio` runtime and `native-tls` TLS backend (SOFT-DEPRECATED).\n\n-   `runtime-tokio-rustls`: Use the `tokio` runtime and `rustls` TLS backend (SOFT-DEPRECATED).\n\n    - Actix-web is fully compatible with Tokio and so a separate runtime feature is no longer needed.\n\n-   `tls-native-tls`: Use the `native-tls` TLS backend (OpenSSL on *nix, SChannel on Windows, Secure Transport on macOS).\n\n-   `tls-rustls`: Use the `rustls` TLS backend (cross-platform backend, only supports TLS 1.2 and 1.3).\n\n-   `postgres`: Add support for the Postgres database server.\n\n-   `mysql`: Add support for the MySQL/MariaDB database server.\n\n-   `mssql`: Add support for the MSSQL database server.\n\n-   `sqlite`: Add support for the self-contained [SQLite](https://sqlite.org/) database engine with SQLite bundled and statically-linked.\n\n-   `sqlite-unbundled`: The same as above (`sqlite`), but link SQLite from the system instead of the bundled version.\n    * Allows updating SQLite independently of SQLx or using forked versions.\n    * You must have SQLite installed on the system or provide a path to the library at build time.\n       See [the `rusqlite` README](https://github.com/rusqlite/rusqlite?tab=readme-ov-file#notes-on-building-rusqlite-and-libsqlite3-sys) for details.\n    * May result in link errors if the SQLite version is too old. Version `3.20.0` or newer is recommended.\n    * Can increase build time due to the use of bindgen.\n\n-   `any`: Add support for the `Any` database driver, which can proxy to a database driver at runtime.\n\n-   `derive`: Add support for the derive family macros, those are `FromRow`, `Type`, `Encode`, `Decode`.\n\n-   `macros`: Add support for the `query*!` macros, which allows compile-time checked queries.\n\n-   `migrate`: Add support for the migration management and `migrate!` macro, which allow compile-time embedded migrations.\n\n-   `uuid`: Add support for UUID (in Postgres).\n\n-   `chrono`: Add support for date and time types from `chrono`.\n\n-   `time`: Add support for date and time types from `time` crate (alternative to `chrono`, which is preferred by `query!` macro, if both enabled)\n\n-   `bstr`: Add support for `bstr::BString`.\n\n-   `bigdecimal`: Add support for `NUMERIC` using the `bigdecimal` crate.\n\n-   `rust_decimal`: Add support for `NUMERIC` using the `rust_decimal` crate.\n\n-   `ipnetwork`: Add support for `INET` and `CIDR` (in postgres) using the `ipnetwork` crate.\n\n-   `json`: Add support for `JSON` and `JSONB` (in postgres) using the `serde_json` crate.\n\n-   Offline mode is now always enabled. See [sqlx-cli/README.md][readme-offline].\n\n[readme-offline]: sqlx-cli/README.md#enable-building-in-offline-mode-with-query\n\n## SQLx is not an ORM!\n\nSQLx supports **compile-time checked queries**. It does not, however, do this by providing a Rust\nAPI or DSL (domain-specific language) for building queries. Instead, it provides macros that take\nregular SQL as input and ensure that it is valid for your database. The way this works is that\nSQLx connects to your development DB at compile time to have the database itself verify (and return\nsome info on) your SQL queries. This has some potentially surprising implications:\n\n- Since SQLx never has to parse the SQL string itself, any syntax that the development DB accepts\n  can be used (including things added by database extensions)\n- Due to the different amount of information databases let you retrieve about queries, the extent of\n  SQL verification you get from the query macros depends on the database\n\n**If you are looking for an (asynchronous) ORM,** you can check out our new [Ecosystem wiki page](https://github.com/launchbadge/sqlx/wiki/Ecosystem#orms)!\n\n[`ormx`]: https://crates.io/crates/ormx\n[`SeaORM`]: https://github.com/SeaQL/sea-orm\n## Usage\n\nSee the `examples/` folder for more in-depth usage.\n\n### Quickstart\n\n```rust\nuse sqlx::postgres::PgPoolOptions;\n// use sqlx::mysql::MySqlPoolOptions;\n// etc.\n\n#[async_std::main] // Requires the `attributes` feature of `async-std`\n// or #[tokio::main]\n// or #[actix_web::main]\nasync fn main() -> Result<(), sqlx::Error> {\n    // Create a connection pool\n    //  for MySQL/MariaDB, use MySqlPoolOptions::new()\n    //  for SQLite, use SqlitePoolOptions::new()\n    //  etc.\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(\"postgres://postgres:password@localhost/test\").await?;\n\n    // Make a simple query to return the given parameter (use a question mark `?` instead of `$1` for MySQL/MariaDB)\n    let row: (i64,) = sqlx::query_as(\"SELECT $1\")\n        .bind(150_i64)\n        .fetch_one(&pool).await?;\n\n    assert_eq!(row.0, 150);\n\n    Ok(())\n}\n```\n\n\n### Connecting\n\nA single connection can be established using any of the database connection types and calling `connect()`.\n\n```rust\nuse sqlx::Connection;\n\nlet conn = SqliteConnection::connect(\"sqlite::memory:\").await?;\n```\n\nGenerally, you will want to instead create a connection pool (`sqlx::Pool`) for the application to\nregulate how many server-side connections it's using.\n\n```rust\nlet pool = MySqlPool::connect(\"mysql://user:pass@host/database\").await?;\n```\n\n### Querying\n\nIn SQL, queries can be separated into prepared (parameterized) or unprepared (simple). Prepared queries have their\nquery plan _cached_, use a binary mode of communication (lower bandwidth and faster decoding), and utilize parameters\nto avoid SQL injection. Unprepared queries are simple and intended only for use where a prepared statement\nwill not work, such as various database commands (e.g., `PRAGMA` or `SET` or `BEGIN`).\n\nSQLx supports all operations with both types of queries. In SQLx, a `&str` is treated as an unprepared query,\nand a `Query` or `QueryAs` struct is treated as a prepared query.\n\n```rust\n// low-level, Executor trait\nconn.execute(\"BEGIN\").await?; // unprepared, simple query\nconn.execute(sqlx::query(\"DELETE FROM table\")).await?; // prepared, cached query\n```\n\nWe should prefer to use the high-level `query` interface whenever possible. To make this easier, there are finalizers\non the type to avoid the need to wrap with an executor.\n\n```rust\nsqlx::query(\"DELETE FROM table\").execute(&mut conn).await?;\nsqlx::query(\"DELETE FROM table\").execute(&pool).await?;\n```\n\nThe `execute` query finalizer returns the number of affected rows, if any, and drops all received results.\nIn addition, there are `fetch`, `fetch_one`, `fetch_optional`, and `fetch_all` to receive results.\n\nThe `Query` type returned from `sqlx::query` will return `Row<'conn>` from the database. Column values can be accessed\nby ordinal or by name with `row.get()`. As the `Row` retains an immutable borrow on the connection, only one\n`Row` may exist at a time.\n\nThe `fetch` query finalizer returns a stream-like type that iterates through the rows in the result sets.\n\n```rust\n// provides `try_next`\nuse futures::TryStreamExt;\n// provides `try_get`\nuse sqlx::Row;\n\nlet mut rows = sqlx::query(\"SELECT * FROM users WHERE email = ?\")\n    .bind(email)\n    .fetch(&mut conn);\n\nwhile let Some(row) = rows.try_next().await? {\n    // map the row into a user-defined domain type\n    let email: &str = row.try_get(\"email\")?;\n}\n```\n\nTo assist with mapping the row into a domain type, one of two idioms may be used:\n\n```rust\nlet mut stream = sqlx::query(\"SELECT * FROM users\")\n    .map(|row: PgRow| {\n        // map the row into a user-defined domain type\n    })\n    .fetch(&mut conn);\n```\n\n```rust\n#[derive(sqlx::FromRow)]\nstruct User { name: String, id: i64 }\n\nlet mut stream = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = ? OR name = ?\")\n    .bind(user_email)\n    .bind(user_name)\n    .fetch(&mut conn);\n```\n\nInstead of a stream of results, we can use `fetch_one` or `fetch_optional` to request one required or optional result\nfrom the database.\n\n### Compile-time verification\n\nWe can use the macro, `sqlx::query!` to achieve compile-time syntactic and semantic verification of the SQL, with\nan output to an anonymous record type where each SQL column is a Rust field (using raw identifiers where needed).\n\n```rust\nlet countries = sqlx::query!(\n        \"\nSELECT country, COUNT(*) as count\nFROM users\nGROUP BY country\nWHERE organization = ?\n        \",\n        organization\n    )\n    .fetch_all(&pool) // -> Vec<{ country: String, count: i64 }>\n    .await?;\n\n// countries[0].country\n// countries[0].count\n```\n\nDifferences from `query()`:\n\n-   The input (or bind) parameters must be given all at once (and they are compile-time validated to be\n    the right number and the right type).\n\n-   The output type is an anonymous record. In the above example the type would be similar to:\n\n    ```rust\n    { country: String, count: i64 }\n    ```\n\n-   The `DATABASE_URL` environment variable must be set at build time to a database which it can prepare\n    queries against; the database does not have to contain any data but must be the same\n    kind (MySQL, Postgres, etc.) and have the same schema as the database you will be connecting to at runtime.\n\n    For convenience, you can use [a `.env` file][dotenv]<sup>1</sup> to set DATABASE_URL so that you don't have to pass it every time:\n\n    ```\n    DATABASE_URL=mysql://localhost/my_database\n    ```\n\n[dotenv]: https://github.com/dotenv-rs/dotenv#examples\n\nThe biggest downside to `query!()` is that the output type cannot be named (due to Rust not\nofficially supporting anonymous records). To address that, there is a `query_as!()` macro that is\nmostly identical except that you can name the output type.\n\n```rust\n// no traits are needed\nstruct Country { country: String, count: i64 }\n\nlet countries = sqlx::query_as!(Country,\n        \"\nSELECT country, COUNT(*) as count\nFROM users\nGROUP BY country\nWHERE organization = ?\n        \",\n        organization\n    )\n    .fetch_all(&pool) // -> Vec<Country>\n    .await?;\n\n// countries[0].country\n// countries[0].count\n```\n\nTo avoid the need of having a development database around to compile the project even when no\nmodifications (to the database-accessing parts of the code) are done, you can enable \"offline mode\"\nto cache the results of the SQL query analysis using the `sqlx` command-line tool. See\n[sqlx-cli/README.md](./sqlx-cli/README.md#enable-building-in-offline-mode-with-query).\n\nCompile-time verified queries do quite a bit of work at compile time. Incremental actions like\n`cargo check` and `cargo build` can be significantly faster when using an optimized build by\nputting the following in your `Cargo.toml` (More information in the\n[Profiles section](https://doc.rust-lang.org/cargo/reference/profiles.html) of The Cargo Book)\n\n```toml\n[profile.dev.package.sqlx-macros]\nopt-level = 3\n```\n\n<sup>1</sup> The `dotenv` crate itself appears abandoned as of [December 2021](https://github.com/dotenv-rs/dotenv/issues/74)\nso we now use the `dotenvy` crate instead. The file format is the same.\n\n## Safety\n\nThis crate uses `#![forbid(unsafe_code)]` to ensure everything is implemented in 100% Safe Rust.\n\nIf the `sqlite` feature is enabled, this is downgraded to `#![deny(unsafe_code)]` with `#![allow(unsafe_code)]` on the\n`sqlx::sqlite` module. There are several places where we interact with the C SQLite API. We try to document each call for the invariants we're assuming. We absolutely welcome auditing of, and feedback on, our unsafe code usage.\n\n## License\n\nLicensed under either of\n\n-   Apache License, Version 2.0\n    ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)\n-   MIT license\n    ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)\n\nat your option.\n\n## Contribution\n\nUnless you explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the work by you, as defined in the Apache-2.0 license, shall be\ndual licensed as above, without any additional terms or conditions.\n",
        "releases": []
    }
}
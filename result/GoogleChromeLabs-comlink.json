{
    "https://api.github.com/repos/GoogleChromeLabs/comlink": {
        "forks": 396,
        "watchers": 11586,
        "stars": 11586,
        "languages": {
            "TypeScript": 33728,
            "JavaScript": 31759,
            "Dockerfile": 575,
            "Shell": 62
        },
        "commits": [
            "2024-11-07T12:29:48Z",
            "2024-11-07T12:28:09Z",
            "2024-01-24T16:52:00Z",
            "2024-01-18T21:45:02Z",
            "2023-02-02T21:54:17Z",
            "2023-02-02T21:53:46Z",
            "2023-02-01T06:03:32Z",
            "2023-02-01T05:15:10Z",
            "2023-01-30T22:39:26Z",
            "2023-01-30T22:39:00Z",
            "2023-01-26T22:17:29Z",
            "2023-01-26T22:09:17Z",
            "2021-12-08T00:37:15Z",
            "2023-01-25T17:22:13Z",
            "2023-01-25T02:24:28Z",
            "2023-01-24T23:05:14Z",
            "2023-01-24T23:04:57Z",
            "2023-01-24T22:04:11Z",
            "2023-01-24T21:59:51Z",
            "2023-01-24T20:07:40Z",
            "2023-01-24T19:45:33Z",
            "2023-01-24T19:25:06Z",
            "2023-01-24T19:28:37Z",
            "2023-01-24T12:10:19Z",
            "2023-01-23T19:54:34Z",
            "2023-01-23T19:53:43Z",
            "2023-01-20T00:03:51Z",
            "2023-01-19T23:54:48Z",
            "2023-01-19T19:37:08Z",
            "2023-01-19T16:50:59Z"
        ],
        "creation_date": "2017-09-06T11:43:38Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 96,
        "readme": "# Comlink\n\nComlink makes [WebWorkers][webworker] enjoyable. Comlink is a **tiny library (1.1kB)**, that removes the mental barrier of thinking about `postMessage` and hides the fact that you are working with workers.\n\nAt a more abstract level it is an RPC implementation for `postMessage` and [ES6 Proxies][es6 proxy].\n\n```\n$ npm install --save comlink\n```\n\n![Comlink in action](https://user-images.githubusercontent.com/234957/54164510-cdab2d80-4454-11e9-92d0-7356aa6c5746.png)\n\n## Browsers support & bundle size\n\n![Chrome 56+](https://img.shields.io/badge/Chrome-56+-green.svg?style=flat-square)\n![Edge 15+](https://img.shields.io/badge/Edge-15+-green.svg?style=flat-square)\n![Firefox 52+](https://img.shields.io/badge/Firefox-52+-green.svg?style=flat-square)\n![Opera 43+](https://img.shields.io/badge/Opera-43+-green.svg?style=flat-square)\n![Safari 10.1+](https://img.shields.io/badge/Safari-10.1+-green.svg?style=flat-square)\n![Samsung Internet 6.0+](https://img.shields.io/badge/Samsung_Internet-6.0+-green.svg?style=flat-square)\n\nBrowsers without [ES6 Proxy] support can use the [proxy-polyfill].\n\n**Size**: ~2.5k, ~1.2k gzip\u2019d, ~1.1k brotli\u2019d\n\n## Introduction\n\nOn mobile phones, and especially on low-end mobile phones, it is important to keep the main thread as idle as possible so it can respond to user interactions quickly and provide a jank-free experience. **The UI thread ought to be for UI work only**. WebWorkers are a web API that allow you to run code in a separate thread. To communicate with another thread, WebWorkers offer the `postMessage` API. You can send JavaScript objects as messages using `myWorker.postMessage(someObject)`, triggering a `message` event inside the worker.\n\nComlink turns this messaged-based API into a something more developer-friendly by providing an RPC implementation: Values from one thread can be used within the other thread (and vice versa) just like local values.\n\n## Examples\n\n### [Running a simple function](./docs/examples/01-simple-example)\n\n**main.js**\n\n```javascript\nimport * as Comlink from \"https://unpkg.com/comlink/dist/esm/comlink.mjs\";\nasync function init() {\n  const worker = new Worker(\"worker.js\");\n  // WebWorkers use `postMessage` and therefore work with Comlink.\n  const obj = Comlink.wrap(worker);\n  alert(`Counter: ${await obj.counter}`);\n  await obj.inc();\n  alert(`Counter: ${await obj.counter}`);\n}\ninit();\n```\n\n**worker.js**\n\n```javascript\nimportScripts(\"https://unpkg.com/comlink/dist/umd/comlink.js\");\n// importScripts(\"../../../dist/umd/comlink.js\");\n\nconst obj = {\n  counter: 0,\n  inc() {\n    this.counter++;\n  },\n};\n\nComlink.expose(obj);\n```\n\n### [Callbacks](./docs/examples/02-callback-example)\n\n**main.js**\n\n```javascript\nimport * as Comlink from \"https://unpkg.com/comlink/dist/esm/comlink.mjs\";\n// import * as Comlink from \"../../../dist/esm/comlink.mjs\";\nfunction callback(value) {\n  alert(`Result: ${value}`);\n}\nasync function init() {\n  const remoteFunction = Comlink.wrap(new Worker(\"worker.js\"));\n  await remoteFunction(Comlink.proxy(callback));\n}\ninit();\n```\n\n**worker.js**\n\n```javascript\nimportScripts(\"https://unpkg.com/comlink/dist/umd/comlink.js\");\n// importScripts(\"../../../dist/umd/comlink.js\");\n\nasync function remoteFunction(cb) {\n  await cb(\"A string from a worker\");\n}\n\nComlink.expose(remoteFunction);\n```\n\n### [`SharedWorker`](./docs/examples/07-sharedworker-example)\n\nWhen using Comlink with a [`SharedWorker`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker) you have to:\n\n1. Use the [`port`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/port) property, of the `SharedWorker` instance, when calling `Comlink.wrap`.\n2. Call `Comlink.expose` within the [`onconnect`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope/onconnect) callback of the shared worker.\n\n**Pro tip:** You can access DevTools for any shared worker currently running in Chrome by going to: **chrome://inspect/#workers**\n\n**main.js**\n\n```javascript\nimport * as Comlink from \"https://unpkg.com/comlink/dist/esm/comlink.mjs\";\nasync function init() {\n  const worker = new SharedWorker(\"worker.js\");\n  /**\n   * SharedWorkers communicate via the `postMessage` function in their `port` property.\n   * Therefore you must use the SharedWorker's `port` property when calling `Comlink.wrap`.\n   */\n  const obj = Comlink.wrap(worker.port);\n  alert(`Counter: ${await obj.counter}`);\n  await obj.inc();\n  alert(`Counter: ${await obj.counter}`);\n}\ninit();\n```\n\n**worker.js**\n\n```javascript\nimportScripts(\"https://unpkg.com/comlink/dist/umd/comlink.js\");\n// importScripts(\"../../../dist/umd/comlink.js\");\n\nconst obj = {\n  counter: 0,\n  inc() {\n    this.counter++;\n  },\n};\n\n/**\n * When a connection is made into this shared worker, expose `obj`\n * via the connection `port`.\n */\nonconnect = function (event) {\n  const port = event.ports[0];\n\n  Comlink.expose(obj, port);\n};\n\n// Single line alternative:\n// onconnect = (e) => Comlink.expose(obj, e.ports[0]);\n```\n\n**For additional examples, please see the [docs/examples](./docs/examples) directory in the project.**\n\n## API\n\n### `Comlink.wrap(endpoint)` and `Comlink.expose(value, endpoint?, allowedOrigins?)`\n\nComlink\u2019s goal is to make _exposed_ values from one thread available in the other. `expose` exposes `value` on `endpoint`, where `endpoint` is a [`postMessage`-like interface][endpoint] and `allowedOrigins` is an array of\nRegExp or strings defining which origins should be allowed access (defaults to special case of `['*']` for all origins).\n\n`wrap` wraps the _other_ end of the message channel and returns a proxy. The proxy will have all properties and functions of the exposed value, but access and invocations are inherently asynchronous. This means that a function that returns a number will now return _a promise_ for a number. **As a rule of thumb: If you are using the proxy, put `await` in front of it.** Exceptions will be caught and re-thrown on the other side.\n\n### `Comlink.transfer(value, transferables)` and `Comlink.proxy(value)`\n\nBy default, every function parameter, return value and object property value is copied, in the sense of [structured cloning]. Structured cloning can be thought of as deep copying, but has some limitations. See [this table][structured clone table] for details.\n\nIf you want a value to be transferred rather than copied \u2014 provided the value is or contains a [`Transferable`][transferable] \u2014 you can wrap the value in a `transfer()` call and provide a list of transferable values:\n\n```js\nconst data = new Uint8Array([1, 2, 3, 4, 5]);\nawait myProxy.someFunction(Comlink.transfer(data, [data.buffer]));\n```\n\nLastly, you can use `Comlink.proxy(value)`. When using this Comlink will neither copy nor transfer the value, but instead send a proxy. Both threads now work on the same value. This is useful for callbacks, for example, as functions are neither structured cloneable nor transferable.\n\n```js\nmyProxy.onready = Comlink.proxy((data) => {\n  /* ... */\n});\n```\n\n### Transfer handlers and event listeners\n\nIt is common that you want to use Comlink to add an event listener, where the event source is on another thread:\n\n```js\nbutton.addEventListener(\"click\", myProxy.onClick.bind(myProxy));\n```\n\nWhile this won\u2019t throw immediately, `onClick` will never actually be called. This is because [`Event`][event] is neither structured cloneable nor transferable. As a workaround, Comlink offers transfer handlers.\n\nEach function parameter and return value is given to _all_ registered transfer handlers. If one of the event handler signals that it can process the value by returning `true` from `canHandle()`, it is now responsible for serializing the value to structured cloneable data and for deserializing the value. A transfer handler has be set up on _both sides_ of the message channel. Here\u2019s an example transfer handler for events:\n\n```js\nComlink.transferHandlers.set(\"EVENT\", {\n  canHandle: (obj) => obj instanceof Event,\n  serialize: (ev) => {\n    return [\n      {\n        target: {\n          id: ev.target.id,\n          classList: [...ev.target.classList],\n        },\n      },\n      [],\n    ];\n  },\n  deserialize: (obj) => obj,\n});\n```\n\nNote that this particular transfer handler won\u2019t create an actual `Event`, but just an object that has the `event.target.id` and `event.target.classList` property. Often, this is enough. If not, the transfer handler can be easily augmented to provide all necessary data.\n\n### `Comlink.releaseProxy`\n\nEvery proxy created by Comlink has the `[releaseProxy]()` method.\nCalling it will detach the proxy and the exposed object from the message channel, allowing both ends to be garbage collected.\n\n```js\nconst proxy = Comlink.wrap(port);\n// ... use the proxy ...\nproxy[Comlink.releaseProxy]();\n```\n\nIf the browser supports the [WeakRef proposal], `[releaseProxy]()` will be called automatically when the proxy created by `wrap()` gets garbage collected.\n\n### `Comlink.finalizer`\n\nIf an exposed object has a property `[Comlink.finalizer]`, the property will be invoked as a function when the proxy is being released. This can happen either through a manual invocation of `[releaseProxy]()` or automatically during garbage collection if the runtime supports the [WeakRef proposal] (see `Comlink.releaseProxy` above). Note that when the finalizer function is invoked, the endpoint is closed and no more communication can happen.\n\n### `Comlink.createEndpoint`\n\nEvery proxy created by Comlink has the `[createEndpoint]()` method.\nCalling it will return a new `MessagePort`, that has been hooked up to the same object as the proxy that `[createEndpoint]()` has been called on.\n\n```js\nconst port = myProxy[Comlink.createEndpoint]();\nconst newProxy = Comlink.wrap(port);\n```\n\n### `Comlink.windowEndpoint(window, context = self, targetOrigin = \"*\")`\n\nWindows and Web Workers have a slightly different variants of `postMessage`. If you want to use Comlink to communicate with an iframe or another window, you need to wrap it with `windowEndpoint()`.\n\n`window` is the window that should be communicate with. `context` is the `EventTarget` on which messages _from_ the `window` can be received (often `self`). `targetOrigin` is passed through to `postMessage` and allows to filter messages by origin. For details, see the documentation for [`Window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\n\nFor a usage example, take a look at the non-worker examples in the `docs` folder.\n\n## TypeScript\n\nComlink does provide TypeScript types. When you `expose()` something of type `T`, the corresponding `wrap()` call will return something of type `Comlink.Remote<T>`. While this type has been battle-tested over some time now, it is implemented on a best-effort basis. There are some nuances that are incredibly hard if not impossible to encode correctly in TypeScript\u2019s type system. It _may_ sometimes be necessary to force a certain type using `as unknown as <type>`.\n\n## Node\n\nComlink works with Node\u2019s [`worker_threads`][worker_threads] module. Take a look at the example in the `docs` folder.\n\n[webworker]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n[umd]: https://github.com/umdjs/umd\n[transferable]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects\n[messageport]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n[examples]: https://github.com/GoogleChromeLabs/comlink/tree/master/docs/examples\n[dist]: https://github.com/GoogleChromeLabs/comlink/tree/master/dist\n[delivrjs]: https://cdn.jsdelivr.net/\n[es6 proxy]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n[proxy-polyfill]: https://github.com/GoogleChrome/proxy-polyfill\n[endpoint]: src/protocol.ts\n[structured cloning]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n[structured clone table]: structured-clone-table.md\n[event]: https://developer.mozilla.org/en-US/docs/Web/API/Event\n[worker_threads]: https://nodejs.org/api/worker_threads.html\n[weakref proposal]: https://github.com/tc39/proposal-weakrefs\n\n## Additional Resources\n\n- [Simplify Web Worker code with Comlink](https://davidea.st/articles/comlink-simple-web-worker)\n\n---\n\nLicense Apache-2.0\n",
        "releases": [
            {
                "name": "v4.4.2",
                "date": "2024-11-07T12:36:34Z"
            },
            {
                "name": "v4.4.1",
                "date": "2023-02-05T11:50:07Z"
            },
            {
                "name": "v4.4.0",
                "date": "2023-02-05T11:49:19Z"
            },
            {
                "name": "",
                "date": "2021-05-12T11:30:08Z"
            },
            {
                "name": "",
                "date": "2020-04-28T11:29:12Z"
            },
            {
                "name": "",
                "date": "2020-04-27T16:21:45Z"
            },
            {
                "name": "",
                "date": "2019-12-06T11:42:52Z"
            },
            {
                "name": "",
                "date": "2019-10-11T08:50:15Z"
            },
            {
                "name": "",
                "date": "2019-10-08T10:04:49Z"
            },
            {
                "name": "",
                "date": "2019-07-22T09:36:50Z"
            }
        ]
    }
}
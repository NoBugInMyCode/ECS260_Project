{
    "https://api.github.com/repos/DapperLib/Dapper": {
        "forks": 3673,
        "watchers": 17684,
        "stars": 17684,
        "languages": {
            "C#": 1135458,
            "PowerShell": 1598,
            "Batchfile": 247
        },
        "commits": [
            "2024-11-01T00:38:20Z",
            "2024-10-31T07:23:21Z",
            "2024-10-17T12:27:42Z",
            "2024-10-13T08:31:25Z",
            "2024-10-09T10:15:28Z",
            "2024-10-08T12:23:18Z",
            "2024-10-08T12:23:00Z",
            "2024-10-07T12:00:15Z",
            "2024-10-07T11:50:42Z",
            "2024-07-03T12:32:18Z",
            "2024-04-30T19:28:19Z",
            "2024-04-30T19:23:51Z",
            "2024-04-28T09:25:21Z",
            "2024-04-28T09:07:12Z",
            "2024-04-28T09:04:28Z",
            "2024-04-26T08:03:21Z",
            "2024-04-26T08:02:37Z",
            "2024-04-26T07:50:49Z",
            "2024-04-26T07:49:47Z",
            "2024-04-13T08:07:53Z",
            "2024-04-12T11:12:02Z",
            "2024-04-12T10:57:42Z",
            "2024-04-12T10:13:05Z",
            "2024-04-12T08:43:31Z",
            "2024-04-12T08:41:32Z",
            "2024-04-12T08:17:59Z",
            "2024-04-12T08:13:24Z",
            "2024-03-07T12:19:30Z",
            "2024-03-06T20:58:21Z",
            "2024-03-06T14:59:19Z"
        ],
        "creation_date": "2011-04-14T08:42:59Z",
        "contributors": 30,
        "topics": [
            "ado-net",
            "dapper",
            "sql"
        ],
        "subscribers": 928,
        "readme": "Dapper - a simple object mapper for .Net\n========================================\n[![Build status](https://ci.appveyor.com/api/projects/status/8rbgoxqio76ynj4h?svg=true)](https://ci.appveyor.com/project/StackExchange/dapper)\n\nRelease Notes\n-------------\nLocated at [https://github.com/DapperLib/Dapper/releases](https://github.com/DapperLib/Dapper/releases/)\n\nPackages\n--------\n\nMyGet Pre-release feed: https://www.myget.org/gallery/dapper\n\n| Package | NuGet Stable | NuGet Pre-release | Downloads | MyGet |\n| ------- | ------------ | ----------------- | --------- | ----- |\n| [Dapper](https://www.nuget.org/packages/Dapper/) | [![Dapper](https://img.shields.io/nuget/v/Dapper.svg)](https://www.nuget.org/packages/Dapper/) | [![Dapper](https://img.shields.io/nuget/vpre/Dapper.svg)](https://www.nuget.org/packages/Dapper/) | [![Dapper](https://img.shields.io/nuget/dt/Dapper.svg)](https://www.nuget.org/packages/Dapper/) | [![Dapper MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper) |\n| [Dapper.EntityFramework](https://www.nuget.org/packages/Dapper.EntityFramework/) | [![Dapper.EntityFramework](https://img.shields.io/nuget/v/Dapper.EntityFramework.svg)](https://www.nuget.org/packages/Dapper.EntityFramework/) | [![Dapper.EntityFramework](https://img.shields.io/nuget/vpre/Dapper.EntityFramework.svg)](https://www.nuget.org/packages/Dapper.EntityFramework/) | [![Dapper.EntityFramework](https://img.shields.io/nuget/dt/Dapper.EntityFramework.svg)](https://www.nuget.org/packages/Dapper.EntityFramework/) | [![Dapper.EntityFramework MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.EntityFramework.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper.EntityFramework) |\n| [Dapper.EntityFramework.StrongName](https://www.nuget.org/packages/Dapper.EntityFramework.StrongName/) | [![Dapper.EntityFramework.StrongName](https://img.shields.io/nuget/v/Dapper.EntityFramework.StrongName.svg)](https://www.nuget.org/packages/Dapper.EntityFramework.StrongName/) | [![Dapper.EntityFramework.StrongName](https://img.shields.io/nuget/vpre/Dapper.EntityFramework.StrongName.svg)](https://www.nuget.org/packages/Dapper.EntityFramework.StrongName/) | [![Dapper.EntityFramework.StrongName](https://img.shields.io/nuget/dt/Dapper.EntityFramework.StrongName.svg)](https://www.nuget.org/packages/Dapper.EntityFramework.StrongName/) | [![Dapper.EntityFramework.StrongName MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.EntityFramework.StrongName.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper.EntityFramework.StrongName) |\n| [Dapper.Rainbow](https://www.nuget.org/packages/Dapper.Rainbow/) | [![Dapper.Rainbow](https://img.shields.io/nuget/v/Dapper.Rainbow.svg)](https://www.nuget.org/packages/Dapper.Rainbow/) | [![Dapper.Rainbow](https://img.shields.io/nuget/vpre/Dapper.Rainbow.svg)](https://www.nuget.org/packages/Dapper.Rainbow/) | [![Dapper.Rainbow](https://img.shields.io/nuget/dt/Dapper.Rainbow.svg)](https://www.nuget.org/packages/Dapper.Rainbow/) | [![Dapper.Rainbow MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.Rainbow.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper.Rainbow) |\n| [Dapper.SqlBuilder](https://www.nuget.org/packages/Dapper.SqlBuilder/) | [![Dapper.SqlBuilder](https://img.shields.io/nuget/v/Dapper.SqlBuilder.svg)](https://www.nuget.org/packages/Dapper.SqlBuilder/) | [![Dapper.SqlBuilder](https://img.shields.io/nuget/vpre/Dapper.SqlBuilder.svg)](https://www.nuget.org/packages/Dapper.SqlBuilder/) | [![Dapper.SqlBuilder](https://img.shields.io/nuget/dt/Dapper.SqlBuilder.svg)](https://www.nuget.org/packages/Dapper.SqlBuilder/) | [![Dapper.SqlBuilder MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.SqlBuilder.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper.SqlBuilder) |\n| [Dapper.StrongName](https://www.nuget.org/packages/Dapper.StrongName/) | [![Dapper.StrongName](https://img.shields.io/nuget/v/Dapper.StrongName.svg)](https://www.nuget.org/packages/Dapper.StrongName/) | [![Dapper.StrongName](https://img.shields.io/nuget/vpre/Dapper.StrongName.svg)](https://www.nuget.org/packages/Dapper.StrongName/) | [![Dapper.StrongName](https://img.shields.io/nuget/dt/Dapper.StrongName.svg)](https://www.nuget.org/packages/Dapper.StrongName/) | [![Dapper.StrongName MyGet](https://img.shields.io/myget/dapper/vpre/Dapper.StrongName.svg)](https://www.myget.org/feed/dapper/package/nuget/Dapper.StrongName) |\n\nPackage Purposes:\n* Dapper\n  * The core library\n* Dapper.EntityFramework\n  * Extension handlers for EntityFramework\n* Dapper.EntityFramework.StrongName\n  * Extension handlers for EntityFramework\n* Dapper.Rainbow\n  * Micro-ORM implemented on Dapper, provides CRUD helpers ([readme](Dapper.Rainbow/readme.md))\n* Dapper.SqlBuilder\n  * Component for building SQL queries dynamically and composably\n\nSponsors\n--------\n\nDapper was originally developed for and by Stack Overflow, but is F/OSS. Sponsorship is welcome and invited - see the sponsor link at the top of the page.\nA huge thanks to everyone (individuals or organisations) who have sponsored Dapper, but a massive thanks in particular to:\n\n- [Dapper Plus](https://dapper-plus.net/) is a major sponsor and is proud to contribute to the development of Dapper ([read more](https://dapperlib.github.io/Dapper/dapperplus))\n- [AWS](https://github.com/aws) who sponsored Dapper from Oct 2023 via the [.NET on AWS Open Source Software Fund](https://github.com/aws/dotnet-foss)\n\n<a href=\"https://dapper-plus.net/\"><img width=\"728\" height=\"90\" alt=\"Dapper Plus logo\" src=\"https://raw.githubusercontent.com/DapperLib/Dapper/main/docs/dapper-sponsor.png\" /></a>\n\nFeatures\n--------\nDapper is a [NuGet library](https://www.nuget.org/packages/Dapper) that you can add in to your project that will enhance your ADO.NET connections via\nextension methods on your `DbConnection` instance. This provides a simple and efficient API for invoking SQL, with support for both synchronous and\nasynchronous data access, and allows both buffered and non-buffered queries.\n\nIt provides multiple helpers, but the key APIs are:\n\n``` csharp\n// insert/update/delete etc\nvar count  = connection.Execute(sql [, args]);\n\n// multi-row query\nIEnumerable<T> rows = connection.Query<T>(sql [, args]);\n\n// single-row query ({Single|First}[OrDefault])\nT row = connection.QuerySingle<T>(sql [, args]);\n```\n\nwhere `args` can be (among other things):\n\n- a simple POCO (including anonyomous types) for named parameters\n- a `Dictionary<string,object>`\n- a `DynamicParameters` instance\n\nExecute a query and map it to a list of typed objects\n-------------------------------------------------------\n\n``` csharp\npublic class Dog\n{\n    public int? Age { get; set; }\n    public Guid Id { get; set; }\n    public string Name { get; set; }\n    public float? Weight { get; set; }\n\n    public int IgnoredProperty { get { return 1; } }\n}\n\nvar guid = Guid.NewGuid();\nvar dog = connection.Query<Dog>(\"select Age = @Age, Id = @Id\", new { Age = (int?)null, Id = guid });\n\nAssert.Equal(1,dog.Count());\nAssert.Null(dog.First().Age);\nAssert.Equal(guid, dog.First().Id);\n```\n\nExecute a query and map it to a list of dynamic objects\n-------------------------------------------------------\n\nThis method will execute SQL and return a dynamic list.\n\nExample usage:\n\n```csharp\nvar rows = connection.Query(\"select 1 A, 2 B union all select 3, 4\").AsList();\n\nAssert.Equal(1, (int)rows[0].A);\nAssert.Equal(2, (int)rows[0].B);\nAssert.Equal(3, (int)rows[1].A);\nAssert.Equal(4, (int)rows[1].B);\n```\n\nExecute a Command that returns no results\n-----------------------------------------\n\nExample usage:\n\n```csharp\nvar count = connection.Execute(@\"\n  set nocount on\n  create table #t(i int)\n  set nocount off\n  insert #t\n  select @a a union all select @b\n  set nocount on\n  drop table #t\", new {a=1, b=2 });\nAssert.Equal(2, count);\n```\n\nExecute a Command multiple times\n--------------------------------\n\nThe same signature also allows you to conveniently and efficiently execute a command multiple times (for example to bulk-load data)\n\nExample usage:\n\n```csharp\nvar count = connection.Execute(@\"insert MyTable(colA, colB) values (@a, @b)\",\n    new[] { new { a=1, b=1 }, new { a=2, b=2 }, new { a=3, b=3 } }\n  );\nAssert.Equal(3, count); // 3 rows inserted: \"1,1\", \"2,2\" and \"3,3\"\n```\n\nAnother example usage when you _already_ have an existing collection:\n```csharp\nvar foos = new List<Foo>\n{\n    { new Foo { A = 1, B = 1 } }\n    { new Foo { A = 2, B = 2 } }\n    { new Foo { A = 3, B = 3 } }\n};\n\nvar count = connection.Execute(@\"insert MyTable(colA, colB) values (@a, @b)\", foos);\nAssert.Equal(foos.Count, count);\n```\n\nThis works for any parameter that implements `IEnumerable<T>` for some T.\n\nPerformance\n-----------\n\nA key feature of Dapper is performance. The following metrics show how long it takes to execute a `SELECT` statement against a DB (in various config, each labeled) and map the data returned to objects.\n\nThe benchmarks can be found in [Dapper.Tests.Performance](https://github.com/DapperLib/Dapper/tree/main/benchmarks/Dapper.Tests.Performance) (contributions welcome!) and can be run via:\n```bash\ndotnet run --project .\\benchmarks\\Dapper.Tests.Performance\\ -c Release -f net8.0 -- -f * --join\n```\nOutput from the latest run is:\n``` ini\nBenchmarkDotNet v0.13.7, Windows 10 (10.0.19045.3693/22H2/2022Update)\nIntel Core i7-3630QM CPU 2.40GHz (Ivy Bridge), 1 CPU, 8 logical and 4 physical cores\n.NET SDK 8.0.100\n  [Host]   : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX\n  ShortRun : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX\n\n```\n|                 ORM |                         Method |       Return |      Mean |    StdDev |     Error |    Gen0 |   Gen1 |   Gen2 | Allocated |\n|-------------------- |------------------------------- |------------- |----------:|----------:|----------:|--------:|-------:|-------:|----------:|\n| Dapper cache impact |        ExecuteParameters_Cache |         Void |  96.75 us |  0.668 us |  1.010 us |  0.6250 |      - |      - |    2184 B |\n| Dapper cache impact |     QueryFirstParameters_Cache |         Void |  96.86 us |  0.493 us |  0.746 us |  0.8750 |      - |      - |    2824 B |\n|          Hand Coded |                     SqlCommand |         Post | 119.70 us |  0.706 us |  1.067 us |  1.3750 | 1.0000 | 0.1250 |    7584 B |\n|          Hand Coded |                      DataTable |      dynamic | 126.64 us |  1.239 us |  1.873 us |  3.0000 |      - |      - |    9576 B |\n|          SqlMarshal |                     SqlCommand |         Post | 132.36 us |  1.008 us |  1.523 us |  2.0000 | 1.0000 | 0.2500 |   11529 B |\n|              Dapper |         QueryFirstOrDefault<T> |         Post | 133.73 us |  1.301 us |  2.186 us |  1.7500 | 1.5000 |      - |   11608 B |\n|              Mighty |                 Query<dynamic> |      dynamic | 133.92 us |  1.075 us |  1.806 us |  2.0000 | 1.7500 |      - |   12710 B |\n|          LINQ to DB |                       Query<T> |         Post | 134.24 us |  1.068 us |  1.614 us |  1.7500 | 1.2500 |      - |   10904 B |\n|              RepoDB |                ExecuteQuery<T> |         Post | 135.83 us |  1.839 us |  3.091 us |  1.7500 | 1.5000 |      - |   11649 B |\n|              Dapper |          'Query<T> (buffered)' |         Post | 136.14 us |  1.755 us |  2.653 us |  2.0000 | 1.5000 |      - |   11888 B |\n|              Mighty |                       Query<T> |         Post | 137.96 us |  1.485 us |  2.244 us |  2.2500 | 1.2500 |      - |   12201 B |\n|              Dapper |   QueryFirstOrDefault<dynamic> |      dynamic | 139.04 us |  1.507 us |  2.279 us |  3.5000 |      - |      - |   11648 B |\n|              Mighty |       SingleFromQuery<dynamic> |      dynamic | 139.74 us |  2.521 us |  3.811 us |  2.0000 | 1.7500 |      - |   12710 B |\n|              Dapper |    'Query<dynamic> (buffered)' |      dynamic | 140.13 us |  1.382 us |  2.090 us |  2.0000 | 1.5000 |      - |   11968 B |\n|        ServiceStack |                  SingleById<T> |         Post | 140.76 us |  1.147 us |  2.192 us |  2.5000 | 1.2500 | 0.2500 |   15248 B |\n|              Dapper |               'Contrib Get<T>' |         Post | 141.09 us |  1.394 us |  2.108 us |  2.0000 | 1.5000 |      - |   12440 B |\n|              Mighty |             SingleFromQuery<T> |         Post | 141.17 us |  1.941 us |  2.935 us |  1.7500 | 1.5000 |      - |   12201 B |\n|             Massive |              'Query (dynamic)' |      dynamic | 142.01 us |  4.957 us |  7.494 us |  2.0000 | 1.5000 |      - |   12342 B |\n|          LINQ to DB |             'First (Compiled)' |         Post | 144.59 us |  1.295 us |  1.958 us |  1.7500 | 1.5000 |      - |   12128 B |\n|              RepoDB |                  QueryField<T> |         Post | 148.31 us |  1.742 us |  2.633 us |  2.0000 | 1.5000 | 0.5000 |   13938 B |\n|                Norm |              'Read<> (tuples)' | ValueTuple`8 | 148.58 us |  2.172 us |  3.283 us |  2.0000 | 1.7500 |      - |   12745 B |\n|                Norm |      'Read<()> (named tuples)' | ValueTuple`8 | 150.60 us |  0.658 us |  1.106 us |  2.2500 | 2.0000 | 1.2500 |   14562 B |\n|              RepoDB |                       Query<T> |         Post | 152.34 us |  2.164 us |  3.271 us |  2.2500 | 1.5000 | 0.2500 |   14106 B |\n|              RepoDB |                QueryDynamic<T> |         Post | 154.15 us |  4.108 us |  6.210 us |  2.2500 | 1.7500 | 0.5000 |   13930 B |\n|              RepoDB |                  QueryWhere<T> |         Post | 155.90 us |  1.953 us |  3.282 us |  2.5000 | 0.5000 |      - |   14858 B |\n| Dapper cache impact |    ExecuteNoParameters_NoCache |         Void | 162.35 us |  1.584 us |  2.394 us |       - |      - |      - |     760 B |\n| Dapper cache impact |      ExecuteNoParameters_Cache |         Void | 162.42 us |  2.740 us |  4.142 us |       - |      - |      - |     760 B |\n| Dapper cache impact |   QueryFirstNoParameters_Cache |         Void | 164.35 us |  1.206 us |  1.824 us |  0.2500 |      - |      - |    1520 B |\n|      DevExpress.XPO |                  FindObject<T> |         Post | 165.87 us |  1.012 us |  1.934 us |  8.5000 |      - |      - |   28099 B |\n| Dapper cache impact | QueryFirstNoParameters_NoCache |         Void | 173.87 us |  1.178 us |  1.781 us |  0.5000 |      - |      - |    1576 B |\n|          LINQ to DB |                          First |         Post | 175.21 us |  2.292 us |  3.851 us |  2.0000 | 0.5000 |      - |   14041 B |\n|                EF 6 |                       SqlQuery |         Post | 175.36 us |  2.259 us |  3.415 us |  4.0000 | 0.7500 |      - |   24209 B |\n|                Norm |               'Read<> (class)' |         Post | 186.37 us |  1.305 us |  2.496 us |  3.0000 | 0.5000 |      - |   17579 B |\n|      DevExpress.XPO |              GetObjectByKey<T> |         Post | 186.78 us |  3.407 us |  5.151 us |  4.5000 | 1.0000 |      - |   30114 B |\n|              Dapper |  'Query<dynamic> (unbuffered)' |      dynamic | 194.62 us |  1.335 us |  2.019 us |  1.7500 | 1.5000 |      - |   12048 B |\n|              Dapper |        'Query<T> (unbuffered)' |         Post | 195.01 us |  0.888 us |  1.343 us |  2.0000 | 1.5000 |      - |   12008 B |\n|      DevExpress.XPO |                       Query<T> |         Post | 199.46 us |  5.500 us |  9.243 us | 10.0000 |      - |      - |   32083 B |\n|            Belgrade |                 FirstOrDefault |       Task`1 | 228.70 us |  2.181 us |  3.665 us |  4.5000 | 0.5000 |      - |   20555 B |\n|             EF Core |             'First (Compiled)' |         Post | 265.45 us | 17.745 us | 26.828 us |  2.0000 |      - |      - |    7521 B |\n|          NHibernate |                         Get<T> |         Post | 276.02 us |  8.029 us | 12.139 us |  6.5000 | 1.0000 |      - |   29885 B |\n|          NHibernate |                            HQL |         Post | 277.74 us | 13.032 us | 19.703 us |  8.0000 | 1.0000 |      - |   31886 B |\n|          NHibernate |                       Criteria |         Post | 300.22 us | 14.908 us | 28.504 us | 13.0000 | 1.0000 |      - |   57562 B |\n|                EF 6 |                          First |         Post | 310.55 us | 27.254 us | 45.799 us | 13.0000 |      - |      - |   43309 B |\n|             EF Core |                          First |         Post | 317.12 us |  1.354 us |  2.046 us |  3.5000 |      - |      - |   11306 B |\n|             EF Core |                       SqlQuery |         Post | 322.34 us | 23.990 us | 40.314 us |  5.0000 |      - |      - |   18195 B |\n|          NHibernate |                            SQL |         Post | 325.54 us |  3.937 us |  7.527 us | 22.0000 | 1.0000 |      - |   80007 B |\n|                EF 6 |          'First (No Tracking)' |         Post | 331.14 us | 27.760 us | 46.649 us | 12.0000 | 1.0000 |      - |   50237 B |\n|             EF Core |          'First (No Tracking)' |         Post | 337.82 us | 27.814 us | 46.740 us |  3.0000 | 1.0000 |      - |   17986 B |\n|          NHibernate |                           LINQ |         Post | 604.74 us |  5.549 us | 10.610 us | 10.0000 |      - |      - |   46061 B |\n| Dapper cache impact |      ExecuteParameters_NoCache |         Void | 623.42 us |  3.978 us |  6.684 us |  3.0000 | 2.0000 |      - |   10001 B |\n| Dapper cache impact |   QueryFirstParameters_NoCache |         Void | 630.77 us |  3.027 us |  4.576 us |  3.0000 | 2.0000 |      - |   10640 B |\n\nFeel free to submit patches that include other ORMs - when running benchmarks, be sure to compile in Release and not attach a debugger (<kbd>Ctrl</kbd>+<kbd>F5</kbd>).\n\nAlternatively, you might prefer Frans Bouma's [RawDataAccessBencher](https://github.com/FransBouma/RawDataAccessBencher) test suite or [OrmBenchmark](https://github.com/InfoTechBridge/OrmBenchmark).\n\nParameterized queries\n---------------------\n\nParameters are usually passed in as anonymous classes. This allows you to name your parameters easily and gives you the ability to simply cut-and-paste SQL snippets and run them in your db platform's Query analyzer.\n\n```csharp\nnew {A = 1, B = \"b\"} // A will be mapped to the param @A, B to the param @B\n```\nParameters can also be built up dynamically using the DynamicParameters class. This allows for building a dynamic SQL statement while still using parameters for safety and performance.\n\n```csharp\n    var sqlPredicates = new List<string>();\n    var queryParams = new DynamicParameters();\n    if (boolExpression)\n    {\n        sqlPredicates.Add(\"column1 = @param1\");\n        queryParams.Add(\"param1\", dynamicValue1, System.Data.DbType.Guid);\n    } else {\n        sqlPredicates.Add(\"column2 = @param2\");\n        queryParams.Add(\"param2\", dynamicValue2, System.Data.DbType.String);\n    }\n```\n\nDynamicParameters also supports copying multiple parameters from existing objects of different types.\n    \n```csharp\n    var queryParams = new DynamicParameters(objectOfType1);\n    queryParams.AddDynamicParams(objectOfType2);\n```\n    \nWhen an object that implements the `IDynamicParameters` interface passed into `Execute` or `Query` functions, parameter values will be extracted via this interface. Obviously, the most likely object class to use for this purpose would be the built-in `DynamicParameters` class.\n    \nList Support\n------------\nDapper allows you to pass in `IEnumerable<int>` and will automatically parameterize your query.\n\nFor example:\n\n```csharp\nconnection.Query<int>(\"select * from (select 1 as Id union all select 2 union all select 3) as X where Id in @Ids\", new { Ids = new int[] { 1, 2, 3 } });\n```\n\nWill be translated to:\n\n```csharp\nselect * from (select 1 as Id union all select 2 union all select 3) as X where Id in (@Ids1, @Ids2, @Ids3)\" // @Ids1 = 1 , @Ids2 = 2 , @Ids2 = 3\n```\n\nLiteral replacements\n------------\nDapper supports literal replacements for bool and numeric types.\n\n```csharp\nconnection.Query(\"select * from User where UserTypeId = {=Admin}\", new { UserTypeId.Admin });\n```\n\nThe literal replacement is not sent as a parameter; this allows better plans and filtered index usage but should usually be used sparingly and after testing. This feature is particularly useful when the value being injected\nis actually a fixed value (for example, a fixed \"category id\", \"status code\" or \"region\" that is specific to the query). For *live* data where you are considering literals, you might *also* want to consider and test provider-specific query hints like [`OPTIMIZE FOR UNKNOWN`](https://blogs.msdn.microsoft.com/sqlprogrammability/2008/11/26/optimize-for-unknown-a-little-known-sql-server-2008-feature/) with regular parameters.\n\nBuffered vs Unbuffered readers\n---------------------\nDapper's default behavior is to execute your SQL and buffer the entire reader on return. This is ideal in most cases as it minimizes shared locks in the db and cuts down on db network time.\n\nHowever when executing huge queries you may need to minimize memory footprint and only load objects as needed. To do so pass, `buffered: false` into the `Query` method.\n\nMulti Mapping\n---------------------\nDapper allows you to map a single row to multiple objects. This is a key feature if you want to avoid extraneous querying and eager load associations.\n\nExample:\n\nConsider 2 classes: `Post` and `User`\n\n```csharp\nclass Post\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n    public User Owner { get; set; }\n}\n\nclass User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```\n\nNow let us say that we want to map a query that joins both the posts and the users table. Until now if we needed to combine the result of 2 queries, we'd need a new object to express it but it makes more sense in this case to put the `User` object inside the `Post` object.\n\nThis is the use case for multi mapping. You tell dapper that the query returns a `Post` and a `User` object and then give it a function describing what you want to do with each of the rows containing both a `Post` and a `User` object. In our case, we want to take the user object and put it inside the post object. So we write the function:\n\n```csharp\n(post, user) => { post.Owner = user; return post; }\n```\n\nThe 3 type arguments to the `Query` method specify what objects dapper should use to deserialize the row and what is going to be returned. We're going to interpret both rows as a combination of `Post` and `User` and we're returning back a `Post` object. Hence the type declaration becomes\n\n```csharp\n<Post, User, Post>\n```\n\nEverything put together, looks like this:\n\n```csharp\nvar sql =\n@\"select * from #Posts p\nleft join #Users u on u.Id = p.OwnerId\nOrder by p.Id\";\n\nvar data = connection.Query<Post, User, Post>(sql, (post, user) => { post.Owner = user; return post;});\nvar post = data.First();\n\nAssert.Equal(\"Sams Post1\", post.Content);\nAssert.Equal(1, post.Id);\nAssert.Equal(\"Sam\", post.Owner.Name);\nAssert.Equal(99, post.Owner.Id);\n```\n\nDapper is able to split the returned row by making an assumption that your Id columns are named `Id` or `id`. If your primary key is different or you would like to split the row at a point other than `Id`, use the optional `splitOn` parameter.\n\nMultiple Results\n---------------------\nDapper allows you to process multiple result grids in a single query.\n\nExample:\n\n```csharp\nvar sql =\n@\"\nselect * from Customers where CustomerId = @id\nselect * from Orders where CustomerId = @id\nselect * from Returns where CustomerId = @id\";\n\nusing (var multi = connection.QueryMultiple(sql, new {id=selectedId}))\n{\n   var customer = multi.Read<Customer>().Single();\n   var orders = multi.Read<Order>().ToList();\n   var returns = multi.Read<Return>().ToList();\n   ...\n}\n```\n\nStored Procedures\n---------------------\nDapper fully supports stored procs:\n\n```csharp\nvar user = cnn.Query<User>(\"spGetUser\", new {Id = 1},\n        commandType: CommandType.StoredProcedure).SingleOrDefault();\n```\n\nIf you want something more fancy, you can do:\n\n```csharp\nvar p = new DynamicParameters();\np.Add(\"@a\", 11);\np.Add(\"@b\", dbType: DbType.Int32, direction: ParameterDirection.Output);\np.Add(\"@c\", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);\n\ncnn.Execute(\"spMagicProc\", p, commandType: CommandType.StoredProcedure);\n\nint b = p.Get<int>(\"@b\");\nint c = p.Get<int>(\"@c\");\n```\n\nAnsi Strings and varchar\n---------------------\nDapper supports varchar params, if you are executing a where clause on a varchar column using a param be sure to pass it in this way:\n\n```csharp\nQuery<Thing>(\"select * from Thing where Name = @Name\", new {Name = new DbString { Value = \"abcde\", IsFixedLength = true, Length = 10, IsAnsi = true }});\n```\n\nOn SQL Server it is crucial to use the unicode when querying unicode and ANSI when querying non unicode.\n\nType Switching Per Row\n---------------------\n\nUsually you'll want to treat all rows from a given table as the same data type. However, there are some circumstances where it's useful to be able to parse different rows as different data types. This is where `IDataReader.GetRowParser` comes in handy.\n\nImagine you have a database table named \"Shapes\" with the columns: `Id`, `Type`, and `Data`, and you want to parse its rows into `Circle`, `Square`, or `Triangle` objects based on the value of the Type column.\n\n```csharp\nvar shapes = new List<IShape>();\nusing (var reader = connection.ExecuteReader(\"select * from Shapes\"))\n{\n    // Generate a row parser for each type you expect.\n    // The generic type <IShape> is what the parser will return.\n    // The argument (typeof(*)) is the concrete type to parse.\n    var circleParser = reader.GetRowParser<IShape>(typeof(Circle));\n    var squareParser = reader.GetRowParser<IShape>(typeof(Square));\n    var triangleParser = reader.GetRowParser<IShape>(typeof(Triangle));\n\n    var typeColumnIndex = reader.GetOrdinal(\"Type\");\n\n    while (reader.Read())\n    {\n        IShape shape;\n        var type = (ShapeType)reader.GetInt32(typeColumnIndex);\n        switch (type)\n        {\n            case ShapeType.Circle:\n            \tshape = circleParser(reader);\n            \tbreak;\n            case ShapeType.Square:\n            \tshape = squareParser(reader);\n            \tbreak;\n            case ShapeType.Triangle:\n            \tshape = triangleParser(reader);\n            \tbreak;\n            default:\n            \tthrow new NotImplementedException();\n        }\n\n      \tshapes.Add(shape);\n    }\n}\n```\n\nUser Defined Variables in MySQL/MariaDB\n---------------------\nIn order to use Non-parameter SQL variables with MySql Connector, you have to add the following option to your connection string:\n\n`Allow User Variables=True`\n\nMake sure you don't provide Dapper with a property to map.\n\nLimitations and caveats\n---------------------\nDapper caches information about every query it runs, this allows it to materialize objects quickly and process parameters quickly. The current implementation caches this information in a `ConcurrentDictionary` object. Statements that are only used once are routinely flushed from this cache. Still, if you are generating SQL strings on the fly without using parameters it is possible you may hit memory issues.\n\nDapper's simplicity means that many features that ORMs ship with are stripped out. It worries about the 95% scenario, and gives you the tools you need most of the time. It doesn't attempt to solve every problem.\n\nWill Dapper work with my DB provider?\n---------------------\nDapper has no DB specific implementation details, it works across all .NET ADO providers including [SQLite](https://www.sqlite.org/), SQL CE, Firebird, Oracle, MariaDB, MySQL, PostgreSQL and SQL Server.\n\nDo you have a comprehensive list of examples?\n---------------------\nDapper has a comprehensive test suite in the [test project](https://github.com/DapperLib/Dapper/tree/main/tests/Dapper.Tests).\n\nWho is using this?\n---------------------\nDapper is in production use at [Stack Overflow](https://stackoverflow.com/).\n",
        "releases": [
            {
                "name": "2.1.44",
                "date": "2024-04-12T12:42:44Z"
            },
            {
                "name": "2.1.42",
                "date": "2024-04-12T10:23:44Z"
            },
            {
                "name": "2.1.37",
                "date": "2024-03-14T15:17:02Z"
            },
            {
                "name": "2.1.35",
                "date": "2024-03-06T15:08:18Z"
            },
            {
                "name": "2.1.28",
                "date": "2024-01-02T16:13:39Z"
            },
            {
                "name": "2.1.24",
                "date": "2023-11-23T09:30:26Z"
            },
            {
                "name": "2.1.21",
                "date": "2023-11-11T09:07:29Z"
            },
            {
                "name": "2.1.15",
                "date": "2023-10-19T12:52:19Z"
            },
            {
                "name": "2.1.11",
                "date": "2023-10-13T06:26:06Z"
            },
            {
                "name": "2.1.4",
                "date": "2023-09-13T20:52:44Z"
            },
            {
                "name": "2.1.1",
                "date": "2023-09-12T15:17:35Z"
            },
            {
                "name": "2.0.151",
                "date": "2023-08-18T09:51:46Z"
            },
            {
                "name": "2.0.143",
                "date": "2023-06-20T12:43:19Z"
            },
            {
                "name": "2.0.138",
                "date": "2023-06-09T15:32:01Z"
            }
        ]
    }
}
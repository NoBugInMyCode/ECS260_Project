{
    "https://api.github.com/repos/immutable-js/immutable-js": {
        "forks": 1782,
        "watchers": 32998,
        "stars": 32998,
        "languages": {
            "TypeScript": 375800,
            "JavaScript": 254662,
            "CSS": 8706,
            "Shell": 1114
        },
        "commits": [
            "2025-01-11T22:04:57Z",
            "2025-01-11T21:49:28Z",
            "2025-01-11T22:02:30Z",
            "2025-01-11T22:02:10Z",
            "2025-01-11T21:31:50Z",
            "2025-01-11T21:30:38Z",
            "2024-12-09T12:53:16Z",
            "2024-12-09T10:34:46Z",
            "2024-11-19T14:47:20Z",
            "2024-11-19T14:41:46Z",
            "2024-11-19T14:40:37Z",
            "2024-11-19T14:32:45Z",
            "2024-11-09T20:44:28Z",
            "2024-11-08T00:13:30Z",
            "2024-11-08T00:13:21Z",
            "2024-11-08T00:07:01Z",
            "2024-11-07T23:54:57Z",
            "2024-11-07T23:51:50Z",
            "2024-09-24T22:25:08Z",
            "2024-11-04T08:03:25Z",
            "2024-11-04T07:42:36Z",
            "2024-11-03T22:57:34Z",
            "2024-11-03T22:55:06Z",
            "2024-10-30T14:20:53Z",
            "2024-10-30T10:01:48Z",
            "2024-10-27T18:16:52Z",
            "2024-10-18T00:05:25Z",
            "2024-10-18T00:02:28Z",
            "2024-10-17T23:26:42Z",
            "2024-10-17T23:23:49Z"
        ],
        "creation_date": "2014-07-02T06:02:29Z",
        "contributors": 30,
        "topics": [],
        "subscribers": 501,
        "readme": "# Immutable collections for JavaScript\n\n[![Build Status](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain) [Chat on slack](https://immutable-js.slack.com)\n\n[Read the docs](https://immutable-js.com/docs/) and eat your vegetables.\n\nDocs are automatically generated from [README.md][] and [immutable.d.ts][].\nPlease contribute! Also, don't miss the [wiki][] which contains articles on\nadditional specific topics. Can't find something? Open an [issue][].\n\n**Table of contents:**\n\n- [Introduction](#introduction)\n- [Getting started](#getting-started)\n- [The case for Immutability](#the-case-for-immutability)\n- [JavaScript-first API](#javascript-first-api)\n- [Nested Structures](#nested-structures)\n- [Equality treats Collections as Values](#equality-treats-collections-as-values)\n- [Batching Mutations](#batching-mutations)\n- [Lazy Seq](#lazy-seq)\n- [Additional Tools and Resources](#additional-tools-and-resources)\n- [Contributing](#contributing)\n\n## Introduction\n\n[Immutable][] data cannot be changed once created, leading to much simpler\napplication development, no defensive copying, and enabling advanced memoization\nand change detection techniques with simple logic. [Persistent][] data presents\na mutative API which does not update the data in-place, but instead always\nyields new updated data.\n\nImmutable.js provides many Persistent Immutable data structures including:\n`List`, `Stack`, `Map`, `OrderedMap`, `Set`, `OrderedSet` and `Record`.\n\nThese data structures are highly efficient on modern JavaScript VMs by using\nstructural sharing via [hash maps tries][] and [vector tries][] as popularized\nby Clojure and Scala, minimizing the need to copy or cache data.\n\nImmutable.js also provides a lazy `Seq`, allowing efficient\nchaining of collection methods like `map` and `filter` without creating\nintermediate representations. Create some `Seq` with `Range` and `Repeat`.\n\nWant to hear more? Watch the presentation about Immutable.js:\n\n[![Immutable Data and React](website/public/Immutable-Data-and-React-YouTube.png)](https://youtu.be/I7IdS-PbEgI)\n\n[README.md]: https://github.com/immutable-js/immutable-js/blob/main/README.md\n[immutable.d.ts]: https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts\n[wiki]: https://github.com/immutable-js/immutable-js/wiki\n[issue]: https://github.com/immutable-js/immutable-js/issues\n[Persistent]: https://en.wikipedia.org/wiki/Persistent_data_structure\n[Immutable]: https://en.wikipedia.org/wiki/Immutable_object\n[hash maps tries]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie\n[vector tries]: https://hypirion.com/musings/understanding-persistent-vector-pt-1\n\n## Getting started\n\nInstall `immutable` using npm.\n\n```shell\n# using npm\nnpm install immutable\n\n# using Yarn\nyarn add immutable\n\n# using pnpm\npnpm add immutable\n\n# using Bun\nbun add immutable\n```\n\nThen require it into any module.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set('b', 50);\nmap1.get('b') + ' vs. ' + map2.get('b'); // 2 vs. 50\n```\n\n### Browser\n\nImmutable.js has no dependencies, which makes it predictable to include in a Browser.\n\nIt's highly recommended to use a module bundler like [webpack](https://webpack.js.org/),\n[rollup](https://rollupjs.org/), or\n[browserify](https://browserify.org/). The `immutable` npm module works\nwithout any additional consideration. All examples throughout the documentation\nwill assume use of this kind of tool.\n\nAlternatively, Immutable.js may be directly included as a script tag. Download\nor link to a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)\nor [jsDelivr](https://www.jsdelivr.com/package/npm/immutable).\n\nUse a script tag to directly add `Immutable` to the global scope:\n\n```html\n<script src=\"immutable.min.js\"></script>\n<script>\n  var map1 = Immutable.Map({ a: 1, b: 2, c: 3 });\n  var map2 = map1.set('b', 50);\n  map1.get('b'); // 2\n  map2.get('b'); // 50\n</script>\n```\n\nOr use an AMD-style loader (such as [RequireJS](https://requirejs.org/)):\n\n```js\nrequire(['./immutable.min.js'], function (Immutable) {\n  var map1 = Immutable.Map({ a: 1, b: 2, c: 3 });\n  var map2 = map1.set('b', 50);\n  map1.get('b'); // 2\n  map2.get('b'); // 50\n});\n```\n\n### Flow & TypeScript\n\nUse these Immutable collections and sequences as you would use native\ncollections in your [Flowtype](https://flowtype.org/) or [TypeScript](https://typescriptlang.org) programs while still taking\nadvantage of type generics, error detection, and auto-complete in your IDE.\n\nInstalling `immutable` via npm brings with it type definitions for Flow (v0.55.0 or higher)\nand TypeScript (v2.1.0 or higher), so you shouldn't need to do anything at all!\n\n#### Using TypeScript with Immutable.js v4\n\nImmutable.js type definitions embrace ES2015. While Immutable.js itself supports\nlegacy browsers and environments, its type definitions require TypeScript's 2015\nlib. Include either `\"target\": \"es2015\"` or `\"lib\": \"es2015\"` in your\n`tsconfig.json`, or provide `--target es2015` or `--lib es2015` to the\n`tsc` command.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set('b', 50);\nmap1.get('b') + ' vs. ' + map2.get('b'); // 2 vs. 50\n```\n\n#### Using TypeScript with Immutable.js v3 and earlier:\n\nPrevious versions of Immutable.js include a reference file which you can include\nvia relative path to the type definitions at the top of your file.\n\n```js\n///<reference path='./node_modules/immutable/dist/immutable.d.ts'/>\nimport { Map } from 'immutable';\nvar map1: Map<string, number>;\nmap1 = Map({ a: 1, b: 2, c: 3 });\nvar map2 = map1.set('b', 50);\nmap1.get('b'); // 2\nmap2.get('b'); // 50\n```\n\n## The case for Immutability\n\nMuch of what makes application development difficult is tracking mutation and\nmaintaining state. Developing with immutable data encourages you to think\ndifferently about how data flows through your application.\n\nSubscribing to data events throughout your application creates a huge overhead of\nbook-keeping which can hurt performance, sometimes dramatically, and creates\nopportunities for areas of your application to get out of sync with each other\ndue to easy to make programmer error. Since immutable data never changes,\nsubscribing to changes throughout the model is a dead-end and new data can only\never be passed from above.\n\nThis model of data flow aligns well with the architecture of [React][]\nand especially well with an application designed using the ideas of [Flux][].\n\nWhen data is passed from above rather than being subscribed to, and you're only\ninterested in doing work when something has changed, you can use equality.\n\nImmutable collections should be treated as _values_ rather than _objects_. While\nobjects represent some thing which could change over time, a value represents\nthe state of that thing at a particular instance of time. This principle is most\nimportant to understanding the appropriate use of immutable data. In order to\ntreat Immutable.js collections as values, it's important to use the\n`Immutable.is()` function or `.equals()` method to determine _value equality_\ninstead of the `===` operator which determines object _reference identity_.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = Map({ a: 1, b: 2, c: 3 });\nmap1.equals(map2); // true\nmap1 === map2; // false\n```\n\nNote: As a performance optimization Immutable.js attempts to return the existing\ncollection when an operation would result in an identical collection, allowing\nfor using `===` reference equality to determine if something definitely has not\nchanged. This can be extremely useful when used within a memoization function\nwhich would prefer to re-run the function if a deeper equality check could\npotentially be more costly. The `===` equality check is also used internally by\n`Immutable.is` and `.equals()` as a performance optimization.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set('b', 2); // Set to same value\nmap1 === map2; // true\n```\n\nIf an object is immutable, it can be \"copied\" simply by making another reference\nto it instead of copying the entire object. Because a reference is much smaller\nthan the object itself, this results in memory savings and a potential boost in\nexecution speed for programs which rely on copies (such as an undo-stack).\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst map = Map({ a: 1, b: 2, c: 3 });\nconst mapCopy = map; // Look, \"copies\" are free!\n```\n\n[React]: https://reactjs.org/\n[Flux]: https://facebook.github.io/flux/docs/in-depth-overview/\n\n\n## JavaScript-first API\n\nWhile Immutable.js is inspired by Clojure, Scala, Haskell and other functional\nprogramming environments, it's designed to bring these powerful concepts to\nJavaScript, and therefore has an Object-Oriented API that closely mirrors that\nof [ES2015][] [Array][], [Map][], and [Set][].\n\n[es2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\n[array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n[map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n[set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n\nThe difference for the immutable collections is that methods which would mutate\nthe collection, like `push`, `set`, `unshift` or `splice`, instead return a new\nimmutable collection. Methods which return new arrays, like `slice` or `concat`,\ninstead return new immutable collections.\n\n<!-- runkit:activate -->\n\n```js\nconst { List } = require('immutable');\nconst list1 = List([1, 2]);\nconst list2 = list1.push(3, 4, 5);\nconst list3 = list2.unshift(0);\nconst list4 = list1.concat(list2, list3);\nassert.equal(list1.size, 2);\nassert.equal(list2.size, 5);\nassert.equal(list3.size, 6);\nassert.equal(list4.size, 13);\nassert.equal(list4.get(0), 1);\n```\n\nAlmost all of the methods on [Array][] will be found in similar form on\n`Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][]\nfound on `Immutable.Set`, including collection operations like `forEach()`\nand `map()`.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst alpha = Map({ a: 1, b: 2, c: 3, d: 4 });\nalpha.map((v, k) => k.toUpperCase()).join();\n// 'A,B,C,D'\n```\n\n### Convert from raw JavaScript objects and arrays.\n\nDesigned to inter-operate with your existing JavaScript, Immutable.js\naccepts plain JavaScript Arrays and Objects anywhere a method expects a\n`Collection`.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map, List } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3, d: 4 });\nconst map2 = Map({ c: 10, a: 20, t: 30 });\nconst obj = { d: 100, o: 200, g: 300 };\nconst map3 = map1.merge(map2, obj);\n// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }\nconst list1 = List([1, 2, 3]);\nconst list2 = List([4, 5, 6]);\nconst array = [7, 8, 9];\nconst list3 = list1.concat(list2, array);\n// List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n```\n\nThis is possible because Immutable.js can treat any JavaScript Array or Object\nas a Collection. You can take advantage of this in order to get sophisticated\ncollection methods on JavaScript Objects, which otherwise have a very sparse\nnative API. Because Seq evaluates lazily and does not cache intermediate\nresults, these operations can be extremely efficient.\n\n<!-- runkit:activate -->\n\n```js\nconst { Seq } = require('immutable');\nconst myObject = { a: 1, b: 2, c: 3 };\nSeq(myObject)\n  .map(x => x * x)\n  .toObject();\n// { a: 1, b: 4, c: 9 }\n```\n\nKeep in mind, when using JS objects to construct Immutable Maps, that\nJavaScript Object properties are always strings, even if written in a quote-less\nshorthand, while Immutable Maps accept keys of any type.\n\n<!-- runkit:activate -->\n\n```js\nconst { fromJS } = require('immutable');\n\nconst obj = { 1: 'one' };\nconsole.log(Object.keys(obj)); // [ \"1\" ]\nconsole.log(obj['1'], obj[1]); // \"one\", \"one\"\n\nconst map = fromJS(obj);\nconsole.log(map.get('1'), map.get(1)); // \"one\", undefined\n```\n\nProperty access for JavaScript Objects first converts the key to a string, but\nsince Immutable Map keys can be of any type the argument to `get()` is\nnot altered.\n\n### Converts back to raw JavaScript objects.\n\nAll Immutable.js Collections can be converted to plain JavaScript Arrays and\nObjects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`.\nAll Immutable Collections also implement `toJSON()` allowing them to be passed\nto `JSON.stringify` directly. They also respect the custom `toJSON()` methods of\nnested objects.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map, List } = require('immutable');\nconst deep = Map({ a: 1, b: 2, c: List([3, 4, 5]) });\nconsole.log(deep.toObject()); // { a: 1, b: 2, c: List [ 3, 4, 5 ] }\nconsole.log(deep.toArray()); // [ 1, 2, List [ 3, 4, 5 ] ]\nconsole.log(deep.toJS()); // { a: 1, b: 2, c: [ 3, 4, 5 ] }\nJSON.stringify(deep); // '{\"a\":1,\"b\":2,\"c\":[3,4,5]}'\n```\n\n### Embraces ES2015\n\nImmutable.js supports all JavaScript environments, including legacy\nbrowsers (even IE11). However it also takes advantage of features added to\nJavaScript in [ES2015][], the latest standard version of JavaScript, including\n[Iterators][], [Arrow Functions][], [Classes][], and [Modules][]. It's inspired\nby the native [Map][] and [Set][] collections added to ES2015.\n\nAll examples in the Documentation are presented in ES2015. To run in all\nbrowsers, they need to be translated to ES5.\n\n```js\n// ES2015\nconst mapped = foo.map(x => x * x);\n// ES5\nvar mapped = foo.map(function (x) {\n  return x * x;\n});\n```\n\nAll Immutable.js collections are [Iterable][iterators], which allows them to be\nused anywhere an Iterable is expected, such as when spreading into an Array.\n\n<!-- runkit:activate -->\n\n```js\nconst { List } = require('immutable');\nconst aList = List([1, 2, 3]);\nconst anArray = [0, ...aList, 4, 5]; // [ 0, 1, 2, 3, 4, 5 ]\n```\n\nNote: A Collection is always iterated in the same order, however that order may\nnot always be well defined, as is the case for the `Map` and `Set`.\n\n[Iterators]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol\n[Arrow Functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n[Classes]: https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes\n[Modules]: https://www.2ality.com/2014/09/es6-modules-final.html\n\n\n## Nested Structures\n\nThe collections in Immutable.js are intended to be nested, allowing for deep\ntrees of data, similar to JSON.\n\n<!-- runkit:activate -->\n\n```js\nconst { fromJS } = require('immutable');\nconst nested = fromJS({ a: { b: { c: [3, 4, 5] } } });\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }\n```\n\nA few power-tools allow for reading and operating on nested data. The\nmost useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,\n`Map` and `OrderedMap`.\n\n<!-- runkit:activate -->\n\n```js\nconst { fromJS } = require('immutable');\nconst nested = fromJS({ a: { b: { c: [3, 4, 5] } } });\n\nconst nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\n\nconsole.log(nested2.getIn(['a', 'b', 'd'])); // 6\n\nconst nested3 = nested2.updateIn(['a', 'b', 'd'], value => value + 1);\nconsole.log(nested3);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }\n\nconst nested4 = nested3.updateIn(['a', 'b', 'c'], list => list.push(6));\n// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }\n```\n\n## Equality treats Collections as Values\n\nImmutable.js collections are treated as pure data _values_. Two immutable\ncollections are considered _value equal_ (via `.equals()` or `is()`) if they\nrepresent the same collection of values. This differs from JavaScript's typical\n_reference equal_ (via `===` or `==`) for Objects and Arrays which only\ndetermines if two variables represent references to the same object instance.\n\nConsider the example below where two identical `Map` instances are not\n_reference equal_ but are _value equal_.\n\n<!-- runkit:activate -->\n\n```js\n// First consider:\nconst obj1 = { a: 1, b: 2, c: 3 };\nconst obj2 = { a: 1, b: 2, c: 3 };\nobj1 !== obj2; // two different instances are always not equal with ===\n\nconst { Map, is } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = Map({ a: 1, b: 2, c: 3 });\nmap1 !== map2; // two different instances are not reference-equal\nmap1.equals(map2); // but are value-equal if they have the same values\nis(map1, map2); // alternatively can use the is() function\n```\n\nValue equality allows Immutable.js collections to be used as keys in Maps or\nvalues in Sets, and retrieved with different but equivalent collections:\n\n<!-- runkit:activate -->\n\n```js\nconst { Map, Set } = require('immutable');\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = Map({ a: 1, b: 2, c: 3 });\nconst set = Set().add(map1);\nset.has(map2); // true because these are value-equal\n```\n\nNote: `is()` uses the same measure of equality as [Object.is][] for scalar\nstrings and numbers, but uses value equality for Immutable collections,\ndetermining if both are immutable and all keys and values are equal\nusing the same measure of equality.\n\n[object.is]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\n#### Performance tradeoffs\n\nWhile value equality is useful in many circumstances, it has different\nperformance characteristics than reference equality. Understanding these\ntradeoffs may help you decide which to use in each case, especially when used\nto memoize some operation.\n\nWhen comparing two collections, value equality may require considering every\nitem in each collection, on an `O(N)` time complexity. For large collections of\nvalues, this could become a costly operation. Though if the two are not equal\nand hardly similar, the inequality is determined very quickly. In contrast, when\ncomparing two collections with reference equality, only the initial references\nto memory need to be compared which is not based on the size of the collections,\nwhich has an `O(1)` time complexity. Checking reference equality is always very\nfast, however just because two collections are not reference-equal does not rule\nout the possibility that they may be value-equal.\n\n#### Return self on no-op optimization\n\nWhen possible, Immutable.js avoids creating new objects for updates where no\nchange in _value_ occurred, to allow for efficient _reference equality_ checking\nto quickly determine if no change occurred.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst originalMap = Map({ a: 1, b: 2, c: 3 });\nconst updatedMap = originalMap.set('b', 2);\nupdatedMap === originalMap; // No-op .set() returned the original reference.\n```\n\nHowever updates which do result in a change will return a new reference. Each\nof these operations occur independently, so two similar updates will not return\nthe same reference:\n\n<!-- runkit:activate -->\n\n```js\nconst { Map } = require('immutable');\nconst originalMap = Map({ a: 1, b: 2, c: 3 });\nconst updatedMap = originalMap.set('b', 1000);\n// New instance, leaving the original immutable.\nupdatedMap !== originalMap;\nconst anotherUpdatedMap = originalMap.set('b', 1000);\n// Despite both the results of the same operation, each created a new reference.\nanotherUpdatedMap !== updatedMap;\n// However the two are value equal.\nanotherUpdatedMap.equals(updatedMap);\n```\n\n## Batching Mutations\n\n> If a tree falls in the woods, does it make a sound?\n>\n> If a pure function mutates some local data in order to produce an immutable\n> return value, is that ok?\n>\n> \u2014 Rich Hickey, Clojure\n\nApplying a mutation to create a new immutable object results in some overhead,\nwhich can add up to a minor performance penalty. If you need to apply a series\nof mutations locally before returning, Immutable.js gives you the ability to\ncreate a temporary mutable (transient) copy of a collection and apply a batch of\nmutations in a performant manner by using `withMutations`. In fact, this is\nexactly how Immutable.js applies complex mutations itself.\n\nAs an example, building `list2` results in the creation of 1, not 3, new\nimmutable Lists.\n\n<!-- runkit:activate -->\n\n```js\nconst { List } = require('immutable');\nconst list1 = List([1, 2, 3]);\nconst list2 = list1.withMutations(function (list) {\n  list.push(4).push(5).push(6);\n});\nassert.equal(list1.size, 3);\nassert.equal(list2.size, 6);\n```\n\nNote: Immutable.js also provides `asMutable` and `asImmutable`, but only\nencourages their use when `withMutations` will not suffice. Use caution to not\nreturn a mutable copy, which could result in undesired behavior.\n\n_Important!_: Only a select few methods can be used in `withMutations` including\n`set`, `push` and `pop`. These methods can be applied directly against a\npersistent data-structure where other methods like `map`, `filter`, `sort`,\nand `splice` will always return new immutable data-structures and never mutate\na mutable collection.\n\n## Lazy Seq\n\n`Seq` describes a lazy operation, allowing them to efficiently chain\nuse of all the higher-order collection methods (such as `map` and `filter`)\nby not creating intermediate collections.\n\n**Seq is immutable** \u2014 Once a Seq is created, it cannot be\nchanged, appended to, rearranged or otherwise modified. Instead, any mutative\nmethod called on a `Seq` will return a new `Seq`.\n\n**Seq is lazy** \u2014 `Seq` does as little work as necessary to respond to any\nmethod call. Values are often created during iteration, including implicit\niteration when reducing or converting to a concrete data structure such as\na `List` or JavaScript `Array`.\n\nFor example, the following performs no work, because the resulting\n`Seq`'s values are never iterated:\n\n```js\nconst { Seq } = require('immutable');\nconst oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8])\n  .filter(x => x % 2 !== 0)\n  .map(x => x * x);\n```\n\nOnce the `Seq` is used, it performs only the work necessary. In this\nexample, no intermediate arrays are ever created, filter is called three\ntimes, and map is only called once:\n\n```js\noddSquares.get(1); // 9\n```\n\nAny collection can be converted to a lazy Seq with `Seq()`.\n\n<!-- runkit:activate -->\n\n```js\nconst { Map, Seq } = require('immutable');\nconst map = Map({ a: 1, b: 2, c: 3 });\nconst lazySeq = Seq(map);\n```\n\n`Seq` allows for the efficient chaining of operations, allowing for the\nexpression of logic that can otherwise be very tedious:\n\n```js\nlazySeq\n  .flip()\n  .map(key => key.toUpperCase())\n  .flip();\n// Seq { A: 1, B: 2, C: 3 }\n```\n\nAs well as expressing logic that would otherwise seem memory or time\nlimited, for example `Range` is a special kind of Lazy sequence.\n\n<!-- runkit:activate -->\n\n```js\nconst { Range } = require('immutable');\nRange(1, Infinity)\n  .skip(1000)\n  .map(n => -n)\n  .filter(n => n % 2 === 0)\n  .take(2)\n  .reduce((r, n) => r * n, 1);\n// 1006008\n```\n\n## Comparison of filter(), groupBy(), and partition()\n\nThe `filter()`, `groupBy()`, and `partition()` methods are similar in that they\nall divide a collection into parts based on applying a function to each element.\nAll three call the predicate or grouping function once for each item in the\ninput collection.  All three return zero or more collections of the same type as\ntheir input.  The returned collections are always distinct from the input\n(according to `===`), even if the contents are identical.\n\nOf these methods, `filter()` is the only one that is lazy and the only one which\ndiscards items from the input collection. It is the simplest to use, and the\nfact that it returns exactly one collection makes it easy to combine with other\nmethods to form a pipeline of operations.\n\nThe `partition()` method is similar to an eager version of `filter()`, but it\nreturns two collections; the first contains the items that would have been\ndiscarded by `filter()`, and the second contains the items that would have been\nkept.  It always returns an array of exactly two collections, which can make it\neasier to use than `groupBy()`.  Compared to making two separate calls to\n`filter()`, `partition()` makes half as many calls it the predicate passed to\nit.\n\nThe `groupBy()` method is a more generalized version of `partition()` that can\ngroup by an arbitrary function rather than just a predicate.  It returns a map\nwith zero or more entries, where the keys are the values returned by the\ngrouping function, and the values are nonempty collections of the corresponding\narguments.  Although `groupBy()` is more powerful than `partition()`, it can be\nharder to use because it is not always possible predict in advance how many\nentries the returned map will have and what their keys will be.\n\n| Summary                       | `filter` | `partition` | `groupBy`      |\n|:------------------------------|:---------|:------------|:---------------|\n| ease of use                   | easiest  | moderate    | hardest        |\n| generality                    | least    | moderate    | most           |\n| laziness                      | lazy     | eager       | eager          |\n| # of returned sub-collections | 1        | 2           | 0 or more      |\n| sub-collections may be empty  | yes      | yes         | no             |\n| can discard items             | yes      | no          | no             |\n| wrapping container            | none     | array       | Map/OrderedMap |\n\n## Additional Tools and Resources\n\n- [Atom-store](https://github.com/jameshopkins/atom-store/)\n  - A Clojure-inspired atom implementation in Javascript with configurability\n    for external persistance.\n\n- [Chai Immutable](https://github.com/astorije/chai-immutable)\n  - If you are using the [Chai Assertion Library](https://chaijs.com/), this\n    provides a set of assertions to use against Immutable.js collections.\n\n- [Fantasy-land](https://github.com/fantasyland/fantasy-land)\n  - Specification for interoperability of common algebraic structures in JavaScript.\n\n- [Immutagen](https://github.com/pelotom/immutagen)\n  - A library for simulating immutable generators in JavaScript.\n\n- [Immutable-cursor](https://github.com/redbadger/immutable-cursor)\n  - Immutable cursors incorporating the Immutable.js interface over\n  Clojure-inspired atom.\n\n- [Immutable-ext](https://github.com/DrBoolean/immutable-ext)\n  - Fantasyland extensions for immutablejs\n\n- [Immutable-js-tools](https://github.com/madeinfree/immutable-js-tools)\n  - Util tools for immutable.js\n\n- [Immutable-Redux](https://github.com/gajus/redux-immutable)\n  - redux-immutable is used to create an equivalent function of Redux\n  combineReducers that works with Immutable.js state.\n\n- [Immutable-Treeutils](https://github.com/lukasbuenger/immutable-treeutils)\n  - Functional tree traversal helpers for ImmutableJS data structures.\n\n- [Irecord](https://github.com/ericelliott/irecord)\n  - An immutable store that exposes an RxJS observable. Great for React.\n\n- [Mudash](https://github.com/brianneisler/mudash)\n  - Lodash wrapper providing Immutable.JS support.\n\n- [React-Immutable-PropTypes](https://github.com/HurricaneJames/react-immutable-proptypes)\n  - PropType validators that work with Immutable.js.\n\n- [Redux-Immutablejs](https://github.com/indexiatech/redux-immutablejs)\n  - Redux Immutable facilities.\n\n- [Rxstate](https://github.com/yamalight/rxstate)\n  - Simple opinionated state management library based on RxJS and Immutable.js.\n\n- [Transit-Immutable-js](https://github.com/glenjamin/transit-immutable-js)\n  - Transit serialisation for Immutable.js.\n  - See also: [Transit-js](https://github.com/cognitect/transit-js)\n\nHave an additional tool designed to work with Immutable.js?\nSubmit a PR to add it to this list in alphabetical order.\n\n## Contributing\n\nUse [Github issues](https://github.com/immutable-js/immutable-js/issues) for requests.\n\nWe actively welcome pull requests, learn how to [contribute](https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md).\n\nImmutable.js is maintained within the [Contributor Covenant's Code of Conduct](https://www.contributor-covenant.org/version/2/0/code_of_conduct/).\n\n### Changelog\n\nChanges are tracked as [Github releases](https://github.com/immutable-js/immutable-js/releases).\n\n### License\n\nImmutable.js is [MIT-licensed](./LICENSE).\n\n### Thanks\n\n[Phil Bagwell](https://www.youtube.com/watch?v=K2NYwP90bNs), for his inspiration\nand research in persistent data structures.\n\n[Hugh Jackson](https://github.com/hughfdjackson/), for providing the npm package\nname. If you're looking for his unsupported package, see [this repository](https://github.com/hughfdjackson/immutable).\n",
        "releases": [
            {
                "name": "v5.0.3",
                "date": "2024-11-19T14:47:56Z"
            },
            {
                "name": "v5.0.2",
                "date": "2024-11-08T00:14:58Z"
            },
            {
                "name": "v5.0.1",
                "date": "2024-11-07T23:57:12Z"
            },
            {
                "name": "v5.0.0",
                "date": "2024-11-03T23:04:53Z"
            },
            {
                "name": "v5.0.0-rc.2",
                "date": "2024-10-17T23:16:04Z"
            },
            {
                "name": "v5.0.0-rc.1",
                "date": "2024-07-22T13:19:38Z"
            },
            {
                "name": "v4.3.7",
                "date": "2024-07-22T12:16:35Z"
            },
            {
                "name": "v4.3.6",
                "date": "2024-05-13T09:03:42Z"
            },
            {
                "name": "v5.0.0-beta.5",
                "date": "2024-01-26T20:00:51Z"
            },
            {
                "name": "v4.3.5",
                "date": "2024-01-26T10:34:19Z"
            },
            {
                "name": "5.0.0-beta.4",
                "date": "2023-08-28T12:52:53Z"
            },
            {
                "name": "5.0.0-beta.2",
                "date": "2023-08-25T13:53:10Z"
            },
            {
                "name": "4.3.4",
                "date": "2023-08-25T13:40:00Z"
            },
            {
                "name": "5.0.0-beta.1",
                "date": "2023-08-24T16:06:13Z"
            },
            {
                "name": "v4.3.3",
                "date": "2023-08-23T09:59:39Z"
            },
            {
                "name": "v4.3.2",
                "date": "2023-08-03T06:55:36Z"
            },
            {
                "name": "v4.3.1",
                "date": "2023-07-11T20:54:06Z"
            },
            {
                "name": "v4.3.0",
                "date": "2023-03-10T15:18:26Z"
            },
            {
                "name": "v4.2.4",
                "date": "2023-03-10T15:17:36Z"
            },
            {
                "name": "v4.2.3",
                "date": "2023-02-02T20:11:35Z"
            },
            {
                "name": "v4.2.2",
                "date": "2023-01-02T11:20:18Z"
            },
            {
                "name": "v4.2.1",
                "date": "2022-12-23T13:37:19Z"
            },
            {
                "name": "",
                "date": "2022-12-22T15:36:47Z"
            },
            {
                "name": "v4.1.0",
                "date": "2022-05-23T19:04:16Z"
            },
            {
                "name": "v4.0.0",
                "date": "2021-10-07T23:49:14Z"
            },
            {
                "name": "v4.0.0-rc.15",
                "date": "2021-09-16T22:55:18Z"
            },
            {
                "name": "4.0.0-rc.14",
                "date": "2021-07-07T23:54:07Z"
            },
            {
                "name": "4.0.0-rc.13",
                "date": "2021-07-07T22:46:25Z"
            },
            {
                "name": "",
                "date": "2018-10-30T23:33:34Z"
            },
            {
                "name": "",
                "date": "2018-10-27T02:38:18Z"
            },
            {
                "name": "",
                "date": "2018-09-19T21:05:14Z"
            },
            {
                "name": "",
                "date": "2017-10-18T01:27:47Z"
            },
            {
                "name": "",
                "date": "2017-10-17T04:52:53Z"
            },
            {
                "name": "",
                "date": "2017-10-05T16:54:36Z"
            },
            {
                "name": "",
                "date": "2017-10-05T10:50:24Z"
            },
            {
                "name": "",
                "date": "2017-10-05T07:00:32Z"
            },
            {
                "name": "",
                "date": "2017-10-05T05:08:28Z"
            },
            {
                "name": "",
                "date": "2017-10-05T06:49:25Z"
            },
            {
                "name": "",
                "date": "2017-09-30T03:38:26Z"
            },
            {
                "name": "",
                "date": "2017-03-13T02:51:55Z"
            },
            {
                "name": "",
                "date": "2017-03-11T03:13:48Z"
            },
            {
                "name": "",
                "date": "2016-04-18T22:04:01Z"
            },
            {
                "name": "",
                "date": "2016-04-16T00:32:34Z"
            },
            {
                "name": "",
                "date": "2015-12-16T06:03:11Z"
            },
            {
                "name": "",
                "date": "2015-09-02T22:41:34Z"
            },
            {
                "name": "",
                "date": "2015-06-17T21:20:58Z"
            },
            {
                "name": "",
                "date": "2015-05-20T02:40:46Z"
            },
            {
                "name": "",
                "date": "2015-04-10T19:21:13Z"
            },
            {
                "name": "",
                "date": "2015-03-29T20:29:12Z"
            },
            {
                "name": "",
                "date": "2015-03-27T05:29:06Z"
            },
            {
                "name": "",
                "date": "2015-03-08T01:02:52Z"
            },
            {
                "name": "",
                "date": "2015-03-07T22:24:44Z"
            },
            {
                "name": "",
                "date": "2015-01-12T23:05:12Z"
            },
            {
                "name": "",
                "date": "2015-01-12T21:11:59Z"
            },
            {
                "name": "",
                "date": "2015-01-12T17:27:37Z"
            },
            {
                "name": "",
                "date": "2015-01-07T03:31:30Z"
            },
            {
                "name": "",
                "date": "2014-12-18T22:29:20Z"
            },
            {
                "name": "",
                "date": "2014-12-16T23:25:12Z"
            },
            {
                "name": "",
                "date": "2014-11-24T02:59:47Z"
            },
            {
                "name": "",
                "date": "2014-11-15T07:18:29Z"
            },
            {
                "name": "",
                "date": "2014-11-15T00:13:56Z"
            },
            {
                "name": "",
                "date": "2014-11-12T18:50:54Z"
            },
            {
                "name": "",
                "date": "2014-11-05T22:16:29Z"
            },
            {
                "name": "",
                "date": "2014-11-01T02:56:15Z"
            },
            {
                "name": "",
                "date": "2014-10-29T17:52:35Z"
            },
            {
                "name": "3.0.0",
                "date": "2014-10-29T03:21:46Z"
            },
            {
                "name": "2.6.2",
                "date": "2014-10-28T17:32:16Z"
            },
            {
                "name": "",
                "date": "2014-10-24T17:56:19Z"
            },
            {
                "name": "2.6.0",
                "date": "2014-10-24T00:40:10Z"
            },
            {
                "name": "2.5.1",
                "date": "2014-10-22T00:10:14Z"
            },
            {
                "name": "2.5.0",
                "date": "2014-10-17T23:59:14Z"
            },
            {
                "name": "2.3.2",
                "date": "2014-10-13T22:22:22Z"
            },
            {
                "name": "2.3.0",
                "date": "2014-10-12T07:09:47Z"
            },
            {
                "name": "2.2.3",
                "date": "2014-10-11T08:01:01Z"
            },
            {
                "name": "2.2.2",
                "date": "2014-10-10T23:23:39Z"
            },
            {
                "name": "",
                "date": "2014-10-08T19:48:58Z"
            },
            {
                "name": "2.2.0",
                "date": "2014-10-08T19:12:11Z"
            },
            {
                "name": "2.1.0",
                "date": "2014-10-06T19:56:24Z"
            },
            {
                "name": "2.0.17",
                "date": "2014-09-02T20:09:20Z"
            },
            {
                "name": "2.0.16",
                "date": "2014-08-26T20:43:43Z"
            },
            {
                "name": "2.0.15",
                "date": "2014-08-23T06:01:19Z"
            },
            {
                "name": "2.0.12",
                "date": "2014-08-19T04:13:08Z"
            },
            {
                "name": "2.0.11",
                "date": "2014-08-16T01:05:28Z"
            },
            {
                "name": "2.0.10",
                "date": "2014-08-15T06:15:38Z"
            },
            {
                "name": "mapKeys",
                "date": "2014-08-12T20:18:25Z"
            }
        ]
    }
}
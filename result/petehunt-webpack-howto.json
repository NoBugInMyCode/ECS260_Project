{
    "https://api.github.com/repos/petehunt/webpack-howto": {
        "forks": 693,
        "watchers": 10096,
        "stars": 10096,
        "languages": {
            "JavaScript": 1785,
            "HTML": 67,
            "CSS": 37
        },
        "commits": [
            "2016-04-12T03:41:15Z",
            "2016-02-23T19:27:05Z",
            "2016-02-09T00:53:15Z",
            "2016-02-04T07:21:25Z",
            "2016-02-03T00:59:54Z",
            "2016-02-03T00:59:39Z",
            "2016-02-02T16:46:53Z",
            "2016-01-21T07:15:39Z",
            "2016-01-21T05:53:36Z",
            "2016-01-21T05:53:17Z",
            "2016-01-21T05:08:50Z",
            "2016-01-21T05:03:37Z",
            "2016-01-20T11:27:04Z",
            "2016-01-20T11:02:48Z",
            "2016-01-19T12:57:45Z",
            "2016-01-19T09:21:42Z",
            "2015-12-28T05:12:43Z",
            "2015-12-28T01:43:39Z",
            "2015-12-17T11:13:11Z",
            "2015-12-14T01:39:07Z",
            "2015-12-14T01:38:37Z",
            "2015-10-12T15:33:47Z",
            "2015-09-06T05:07:17Z",
            "2015-09-05T23:43:55Z",
            "2015-09-05T23:43:27Z",
            "2015-09-05T23:37:55Z",
            "2015-08-21T09:01:53Z",
            "2015-07-28T03:27:45Z",
            "2015-07-12T03:05:24Z",
            "2015-07-08T06:11:08Z"
        ],
        "creation_date": "2014-07-17T06:55:48Z",
        "contributors": 19,
        "topics": [],
        "subscribers": 263,
        "readme": "# webpack-howto\n\n## Goal of this guide\n\nThis is a cookbook of how to get things done with webpack. This includes most things we use at Instagram and nothing we don't use.\n\nMy advice: start with this as your webpack docs, then look at the official docs for clarification.\n\n## Prerequisites\n\n  * You know browserify, RequireJS or something similar\n  * You see the value in:\n    * Bundle splitting\n    * Async loading\n    * Packaging static assets like images and CSS\n\n## 1. Why webpack?\n\n\n  * **It's like browserify** but can split your app into multiple files. If you have multiple pages in a single-page app, the user only downloads code for just that page. If they go to another page, they don't redownload common code.\n\n  * **It often replaces grunt or gulp** because it can build and bundle CSS, preprocessed CSS, compile-to-JS languages and images, among other things.\n\nIt supports AMD and CommonJS, among other module systems (Angular, ES6). If you don't know what to use, use CommonJS.\n\n## 2. Webpack for Browserify people\n\nThese are equivalent:\n\n```js\nbrowserify main.js > bundle.js\n```\n\n```js\nwebpack main.js bundle.js\n```\n\nHowever, webpack is more powerful than Browserify, so you generally want to make a `webpack.config.js` to keep things organized:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'       \n  }\n};\n```\n\nThis is just JS, so feel free to put Real Code in there.\n\n## 3. How to invoke webpack\n\nSwitch to the directory containing `webpack.config.js` and run:\n\n  * `webpack` for building once for development\n  * `webpack -p` for building once for production (minification)\n  * `webpack --watch` for continuous incremental build in development (fast!)\n  * `webpack -d` to include source maps\n\n## 4. Compile-to-JS languages\n\nwebpack's equivalent of browserify transforms and RequireJS plugins is a **loader**. Here's how you can teach webpack to load CoffeeScript and Facebook JSX+ES6 support (you must `npm install babel-loader coffee-loader`):\n\nSee also the [babel-loader installation instructions](https://www.npmjs.com/package/babel-loader) for additional dependencies (tl;dr run `npm install babel-core babel-preset-es2015 babel-preset-react`).\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'       \n  },\n  module: {\n    loaders: [\n      { test: /\\.coffee$/, loader: 'coffee-loader' },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        query: {\n          presets: ['es2015', 'react']\n        }\n      }\n    ]\n  }\n};\n```\n\nTo enable requiring files without specifying the extension, you must add a `resolve.extensions` parameter specifying which files webpack searches for:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'       \n  },\n  module: {\n    loaders: [\n      { test: /\\.coffee$/, loader: 'coffee-loader' },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        query: {\n          presets: ['es2015', 'react']\n        }\n      }\n    ]\n  },\n  resolve: {\n    // you can now require('file') instead of require('file.coffee')\n    extensions: ['', '.js', '.json', '.coffee'] \n  }\n};\n```\n\n\n## 5. Stylesheets and images\n\nFirst update your code to `require()` your static assets (named as they would with node's `require()`):\n\n```js\nrequire('./bootstrap.css');\nrequire('./myapp.less');\n\nvar img = document.createElement('img');\nimg.src = require('./glyph.png');\n```\n\nWhen you require CSS (or less, etc), webpack inlines the CSS as a string inside the JS bundle and `require()` will insert a `<style>` tag into the page. When you require images, webpack inlines a URL to the image into the bundle and returns it from `require()`.\n\nBut you need to teach webpack to do this (again, with loaders):\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    path: './build', // This is where images AND js will go\n    publicPath: 'http://mycdn.com/', // This is used to generate URLs to e.g. images\n    filename: 'bundle.js'\n  },\n  module: {\n    loaders: [\n      { test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' }, // use ! to chain loaders\n      { test: /\\.css$/, loader: 'style-loader!css-loader' },\n      { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' } // inline base64 URLs for <=8k images, direct URLs for the rest\n    ]\n  }\n};\n```\n\n## 6. Feature flags\n\nWe have code we want to gate only to our dev environments (like logging) and our internal dogfooding servers (like unreleased features we're testing with employees). In your code, refer to magic globals:\n\n```js\nif (__DEV__) {\n  console.warn('Extra logging');\n}\n// ...\nif (__PRERELEASE__) {\n  showSecretFeature();\n}\n```\n\nThen teach webpack those magic globals:\n\n```js\n// webpack.config.js\n\n// definePlugin takes raw strings and inserts them, so you can put strings of JS if you want.\nvar definePlugin = new webpack.DefinePlugin({\n  __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')),\n  __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))\n});\n\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'       \n  },\n  plugins: [definePlugin]\n};\n```\n\nThen you can build with `BUILD_DEV=1 BUILD_PRERELEASE=1 webpack` from the console. Note that since `webpack -p` runs uglify dead-code elimination, anything wrapped in one of these blocks will be stripped out, so you won't leak secret features or strings.\n\n## 7. Multiple entrypoints\n\nLet's say you have a profile page and a feed page. You don't want to make the user download the code for the feed if they just want the profile. So make multiple bundles: create one \"main module\" (called an entrypoint) per page:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: {\n    Profile: './profile.js',\n    Feed: './feed.js'\n  },\n  output: {\n    path: 'build',\n    filename: '[name].js' // Template based on keys in entry above\n  }\n};\n```\n\nFor profile, insert `<script src=\"build/Profile.js\"></script>` into your page. Do a similar thing for feed.\n\n## 8. Optimizing common code\n\nFeed and Profile share a lot in common (like React and the common stylesheets and components). webpack can figure out what they have in common and make a shared bundle that can be cached between pages:\n\n```js\n// webpack.config.js\n\nvar webpack = require('webpack');\n\nvar commonsPlugin =\n  new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n  entry: {\n    Profile: './profile.js',\n    Feed: './feed.js'\n  },\n  output: {\n    path: 'build',\n    filename: '[name].js' // Template based on keys in entry above\n  },\n  plugins: [commonsPlugin]\n};\n```\n\nAdd `<script src=\"build/common.js\"></script>` before the script tag you added in the previous step and enjoy the free caching.\n\n## 9. Async loading\n\nCommonJS is synchronous but webpack provides a way to asynchronously specify dependencies. This is useful for client-side routers, where you want the router on every page, but you don't want to have to download features until you actually need them.\n\nSpecify the **split point** where you want to load asynchronously. For example:\n\n```js\nif (window.location.pathname === '/feed') {\n  showLoadingState();\n  require.ensure([], function() { // this syntax is weird but it works\n    hideLoadingState();\n    require('./feed').show(); // when this function is called, the module is guaranteed to be synchronously available.\n  });\n} else if (window.location.pathname === '/profile') {\n  showLoadingState();\n  require.ensure([], function() {\n    hideLoadingState();\n    require('./profile').show();\n  });\n}\n```\n\nwebpack will do the rest and generate extra **chunk** files and load them for you.\n\nwebpack will assume that those files are in your root directory when you load then into a html script tag for example. You can use `output.publicPath` to configure that.\n\n```js\n// webpack.config.js\noutput: {\n    path: \"/home/proj/public/assets\", //path to where webpack will build your stuff\n    publicPath: \"/assets/\" //path that will be considered when requiring your files\n}\n```\n\n## Additional resources\n\nTake a look at a real world example on how a successful team is leveraging webpack: http://youtu.be/VkTCL6Nqm6Y\nThis is Pete Hunt at OSCon talking about webpack at Instagram.com\n\n## FAQ\n\n### webpack doesn't seem modular\n\nwebpack is **extremely** modular. What makes webpack great is that it lets plugins inject themselves into more places in the build process when compared to alternatives like browserify and requirejs. Many things that may seem built into the core are just plugins that are loaded by default and can be overridden (i.e. the CommonJS require() parser).\n",
        "releases": []
    }
}
{
    "https://api.github.com/repos/spacejam/sled": {
        "forks": 389,
        "watchers": 8276,
        "stars": 8276,
        "languages": {
            "Rust": 1016144,
            "Python": 6138,
            "Shell": 5659
        },
        "commits": [
            "2023-08-05T07:17:16Z",
            "2023-08-05T07:15:14Z",
            "2023-08-05T06:51:30Z",
            "2023-07-28T22:02:44Z",
            "2023-07-20T17:01:05Z",
            "2022-11-29T02:38:34Z",
            "2022-10-02T09:12:55Z",
            "2022-10-02T09:03:41Z",
            "2022-10-02T09:01:28Z",
            "2022-10-02T08:46:40Z",
            "2022-10-02T08:42:02Z",
            "2022-10-02T08:40:15Z",
            "2022-10-02T08:36:51Z",
            "2022-10-02T07:52:20Z",
            "2022-10-01T19:19:30Z",
            "2022-10-01T19:19:01Z",
            "2022-10-01T19:16:19Z",
            "2022-10-01T19:15:53Z",
            "2022-10-01T19:15:39Z",
            "2022-10-01T19:12:02Z",
            "2022-10-01T19:03:08Z",
            "2022-10-01T19:00:50Z",
            "2022-10-01T18:41:27Z",
            "2022-10-01T16:51:39Z",
            "2022-10-01T16:49:46Z",
            "2022-10-01T09:32:49Z",
            "2022-10-01T09:32:34Z",
            "2022-09-30T07:01:39Z",
            "2022-09-11T15:22:23Z",
            "2022-05-12T10:14:14Z"
        ],
        "creation_date": "2016-01-11T04:11:30Z",
        "contributors": 30,
        "topics": [
            "b-plus-tree",
            "b-tree",
            "concurrent",
            "crash-testing",
            "database",
            "embedded-kv",
            "formal-methods",
            "fuzzing",
            "high-performance",
            "incredibly-spicy",
            "kv",
            "lock-free",
            "log-structured",
            "orm",
            "persistence",
            "rust",
            "sled",
            "tree"
        ],
        "subscribers": 130,
        "readme": "\n<table style=\"width:100%\">\n<tr>\n  <td>\n    <table style=\"width:100%\">\n      <tr>\n        <td> key </td>\n        <td> value </td>\n      </tr>\n      <tr>\n        <td><a href=\"https://github.com/sponsors/spacejam\">buy a coffee for us to convert into databases</a></td>\n        <td><a href=\"https://github.com/sponsors/spacejam\"><img src=\"https://img.shields.io/github/sponsors/spacejam\"></a></td>\n      </tr>\n      <tr>\n        <td><a href=\"https://docs.rs/sled\">documentation</a></td>\n        <td><a href=\"https://docs.rs/sled\"><img src=\"https://docs.rs/sled/badge.svg\"></a></td>\n      </tr>\n      <tr>\n        <td><a href=\"https://discord.gg/Z6VsXds\">chat about databases with us</a></td>\n        <td><a href=\"https://discord.gg/Z6VsXds\"><img src=\"https://img.shields.io/discord/509773073294295082.svg?logo=discord\"></a></td>\n      </tr>\n     </table>\n  </td>\n  <td>\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/spacejam/sled/main/art/tree_face_anti-transphobia.png\" width=\"40%\" height=\"auto\" />\n  </p>\n  </td>\n </tr>\n</table>\n\n\n# sled - ~~it's all downhill from here!!!~~\n\nAn embedded database.\n\n```rust\nlet tree = sled::open(\"/tmp/welcome-to-sled\")?;\n\n// insert and get, similar to std's BTreeMap\nlet old_value = tree.insert(\"key\", \"value\")?;\n\nassert_eq!(\n  tree.get(&\"key\")?,\n  Some(sled::IVec::from(\"value\")),\n);\n\n// range queries\nfor kv_result in tree.range(\"key_1\"..\"key_9\") {}\n\n// deletion\nlet old_value = tree.remove(&\"key\")?;\n\n// atomic compare and swap\ntree.compare_and_swap(\n  \"key\",\n  Some(\"current_value\"),\n  Some(\"new_value\"),\n)?;\n\n// block until all operations are stable on disk\n// (flush_async also available to get a Future)\ntree.flush()?;\n```\n\nIf you would like to work with structured data without paying expensive deserialization costs, check out the [structured](examples/structured.rs) example!\n\n# features\n\n* [API](https://docs.rs/sled) similar to a threadsafe `BTreeMap<[u8], [u8]>`\n* serializable (ACID) [transactions](https://docs.rs/sled/latest/sled/struct.Tree.html#method.transaction)\n  for atomically reading and writing to multiple keys in multiple keyspaces.\n* fully atomic single-key operations, including [compare and swap](https://docs.rs/sled/latest/sled/struct.Tree.html#method.compare_and_swap)\n* zero-copy reads\n* [write batches](https://docs.rs/sled/latest/sled/struct.Tree.html#method.apply_batch)\n* [subscribe to changes on key\n  prefixes](https://docs.rs/sled/latest/sled/struct.Tree.html#method.watch_prefix)\n* [multiple keyspaces](https://docs.rs/sled/latest/sled/struct.Db.html#method.open_tree)\n* [merge operators](https://docs.rs/sled/latest/sled/doc/merge_operators/index.html)\n* forward and reverse iterators over ranges of items\n* a crash-safe monotonic [ID generator](https://docs.rs/sled/latest/sled/struct.Db.html#method.generate_id)\n  capable of generating 75-125 million unique ID's per second\n* [zstd](https://github.com/facebook/zstd) compression (use the\n  `compression` build feature, disabled by default)\n* cpu-scalable lock-free implementation\n* flash-optimized log-structured storage\n* uses modern b-tree techniques such as prefix encoding and suffix\n  truncation for reducing the storage costs of long keys with shared\n  prefixes. If keys are the same length and sequential then the\n  system can avoid storing 99%+ of the key data in most cases,\n  essentially acting like a learned index\n\n# expectations, gotchas, advice\n\n* Maybe one of the first things that seems weird is the `IVec` type.\n  This is an inlinable `Arc`ed slice that makes some things more efficient.\n* Durability: **sled automatically fsyncs every 500ms by default**,\n  which can be configured with the `flush_every_ms` configurable, or you may\n  call `flush` / `flush_async` manually after operations.\n* **Transactions are optimistic** - do not interact with external state\n  or perform IO from within a transaction closure unless it is\n  [idempotent](https://en.wikipedia.org/wiki/Idempotent).\n* Internal tree node optimizations: sled performs prefix encoding\n  on long keys with similar prefixes that are grouped together in a range,\n  as well as suffix truncation to further reduce the indexing costs of\n  long keys. Nodes will skip potentially expensive length and offset pointers\n  if keys or values are all the same length (tracked separately, don't worry\n  about making keys the same length as values), so it may improve space usage\n  slightly if you use fixed-length keys or values. This also makes it easier\n  to use [structured access](examples/structured.rs) as well.\n* sled does not support multiple open instances for the time being. Please\n  keep sled open for the duration of your process's lifespan. It's totally\n  safe and often quite convenient to use a global lazy_static sled instance,\n  modulo the normal global variable trade-offs. Every operation is threadsafe,\n  and most are implemented under the hood with lock-free algorithms that avoid\n  blocking in hot paths.\n\n# performance\n\n* [LSM tree](https://en.wikipedia.org/wiki/Log-structured_merge-tree)-like write performance\n  with [traditional B+ tree](https://en.wikipedia.org/wiki/B%2B_tree)-like read performance\n* over a billion operations in under a minute at 95% read 5% writes on 16 cores on a small dataset\n* measure your own workloads rather than relying on some marketing for contrived workloads\n\n# a note on lexicographic ordering and endianness\n\nIf you want to store numerical keys in a way that will play nicely with sled's iterators and ordered operations, please remember to store your numerical items in big-endian form. Little endian (the default of many things) will often appear to be doing the right thing until you start working with more than 256 items (more than 1 byte), causing lexicographic ordering of the serialized bytes to diverge from the lexicographic ordering of their deserialized numerical form.\n\n* Rust integral types have built-in `to_be_bytes` and `from_be_bytes` [methods](https://doc.rust-lang.org/std/primitive.u64.html#method.from_be_bytes).\n* bincode [can be configured](https://docs.rs/bincode/1.2.0/bincode/struct.Config.html#method.big_endian) to store integral types in big-endian form.\n\n# interaction with async\n\nIf your dataset resides entirely in cache (achievable at startup by setting the cache\nto a large enough value and performing a full iteration) then all reads and writes are\nnon-blocking and async-friendly, without needing to use Futures or an async runtime.\n\nTo asynchronously suspend your async task on the durability of writes, we support the\n[`flush_async` method](https://docs.rs/sled/latest/sled/struct.Tree.html#method.flush_async),\nwhich returns a Future that your async tasks can await the completion of if they require\nhigh durability guarantees and you are willing to pay the latency costs of fsync.\nNote that sled automatically tries to sync all data to disk several times per second\nin the background without blocking user threads.\n\nWe support async subscription to events that happen on key prefixes, because the\n`Subscriber` struct implements `Future<Output=Option<Event>>`:\n\n```rust\nlet sled = sled::open(\"my_db\").unwrap();\n\nlet mut sub = sled.watch_prefix(\"\");\n\nsled.insert(b\"a\", b\"a\").unwrap();\n\nextreme::run(async move {\n    while let Some(event) = (&mut sub).await {\n        println!(\"got event {:?}\", event);\n    }\n});\n```\n\n# minimum supported Rust version (MSRV)\n\nWe support Rust 1.62 and up.\n\n# architecture\n\nlock-free tree on a lock-free pagecache on a lock-free log. the pagecache scatters\npartial page fragments across the log, rather than rewriting entire pages at a time\nas B+ trees for spinning disks historically have. on page reads, we concurrently\nscatter-gather reads across the log to materialize the page from its fragments.\ncheck out the [architectural outlook](https://github.com/spacejam/sled/wiki/sled-architectural-outlook)\nfor a more detailed overview of where we're at and where we see things going!\n\n# philosophy\n\n1. don't make the user think. the interface should be obvious.\n1. don't surprise users with performance traps.\n1. don't wake up operators. bring reliability techniques from academia into real-world practice.\n1. don't use so much electricity. our data structures should play to modern hardware's strengths.\n\n# known issues, warnings\n\n* if reliability is your primary constraint, use SQLite. sled is beta.\n* if storage price performance is your primary constraint, use RocksDB. sled uses too much space sometimes.\n* if you have a multi-process workload that rarely writes, use LMDB. sled is architected for use with long-running, highly-concurrent workloads such as stateful services or higher-level databases.\n* quite young, should be considered unstable for the time being.\n* the on-disk format is going to change in ways that require [manual migrations](https://docs.rs/sled/latest/sled/struct.Db.html#method.export) before the `1.0.0` release!\n\n# priorities\n\n1. A full rewrite of sled's storage subsystem is happening on a modular basis as part of the [komora project](https://github.com/komora-io), in particular the marble storage engine. This will dramatically lower both the disk space usage (space amplification) and garbage collection overhead (write amplification) of sled.\n2. The memory layout of tree nodes is being completely rewritten to reduce fragmentation and eliminate serialization costs.\n3. The merge operator feature will change into a trigger feature that resembles traditional database triggers, allowing state to be modified as part of the same atomic writebatch that triggered it for retaining serializability with reactive semantics.\n\n# fund feature development\n\nLike what we're doing? Help us out via [GitHub Sponsors](https://github.com/sponsors/spacejam)!\n",
        "releases": [
            {
                "name": "0.34.7",
                "date": "2021-09-12T09:38:28Z"
            },
            {
                "name": "0.34.6",
                "date": "2020-11-13T12:31:33Z"
            },
            {
                "name": "0.34.5",
                "date": "2020-11-09T17:20:40Z"
            },
            {
                "name": "0.34.4",
                "date": "2020-09-10T12:19:30Z"
            },
            {
                "name": "0.34.3",
                "date": "2020-09-10T12:18:44Z"
            },
            {
                "name": "0.34.2",
                "date": "2020-07-29T09:13:47Z"
            },
            {
                "name": "0.34.1",
                "date": "2020-07-28T11:16:19Z"
            },
            {
                "name": "0.34",
                "date": "2020-07-23T09:06:33Z"
            },
            {
                "name": "0.33",
                "date": "2020-07-15T09:01:01Z"
            },
            {
                "name": "0.32.1",
                "date": "2020-07-12T10:45:21Z"
            },
            {
                "name": "0.32",
                "date": "2020-06-20T17:08:40Z"
            },
            {
                "name": "varints, read and recovery optimizations",
                "date": "2020-01-31T10:16:34Z"
            },
            {
                "name": "sled::open replaces sled::Db::open",
                "date": "2019-12-27T10:58:22Z"
            },
            {
                "name": "new storage format and bugfixes",
                "date": "2019-12-13T17:23:29Z"
            },
            {
                "name": "Config, Transaction, and Opening Revamp",
                "date": "2019-10-16T15:33:26Z"
            },
            {
                "name": "async flush, bugfixes, event variant rename",
                "date": "2019-09-08T15:27:33Z"
            },
            {
                "name": "Transactions!",
                "date": "2019-08-19T19:42:31Z"
            },
            {
                "name": "Write Batches, New Storage Architecture, Fewer Dependencies",
                "date": "2019-08-15T10:53:22Z"
            },
            {
                "name": "GC improvements, more writepath optimizations",
                "date": "2019-04-01T17:54:44Z"
            },
            {
                "name": "API cleanup, writepath optimizations",
                "date": "2019-03-25T08:39:27Z"
            },
            {
                "name": "Keyspace Support",
                "date": "2019-01-07T23:40:35Z"
            },
            {
                "name": "Zero-Copy Reads",
                "date": "2018-10-28T19:35:32Z"
            }
        ]
    }
}
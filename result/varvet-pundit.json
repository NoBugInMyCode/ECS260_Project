{
    "https://api.github.com/repos/varvet/pundit": {
        "forks": 635,
        "watchers": 8329,
        "stars": 8329,
        "languages": {
            "Ruby": 83791
        },
        "commits": [
            "2024-11-25T08:28:01Z",
            "2024-11-22T10:48:21Z",
            "2024-11-22T09:21:33Z",
            "2024-11-22T09:17:57Z",
            "2024-11-22T09:06:40Z",
            "2024-11-22T09:00:08Z",
            "2024-10-22T13:53:14Z",
            "2024-10-22T13:42:19Z",
            "2024-10-22T13:42:01Z",
            "2024-10-22T13:41:45Z",
            "2024-10-08T10:19:46Z",
            "2024-10-08T10:16:24Z",
            "2024-10-08T10:15:36Z",
            "2024-09-13T14:15:55Z",
            "2024-09-13T14:15:39Z",
            "2024-09-13T14:00:34Z",
            "2024-11-21T13:02:06Z",
            "2024-10-09T14:02:41Z",
            "2024-11-21T10:46:10Z",
            "2024-10-10T09:32:57Z",
            "2024-11-21T09:01:47Z",
            "2024-10-09T09:24:24Z",
            "2024-10-24T11:34:01Z",
            "2024-10-11T08:42:41Z",
            "2024-10-09T14:07:47Z",
            "2024-10-11T08:06:33Z",
            "2024-10-10T12:20:12Z",
            "2024-10-10T09:22:51Z",
            "2024-10-09T15:08:17Z",
            "2024-10-09T09:54:06Z"
        ],
        "creation_date": "2012-11-04T09:20:19Z",
        "contributors": 30,
        "topics": [
            "ruby"
        ],
        "subscribers": 104,
        "readme": "# Pundit\n\n[![Main](https://github.com/varvet/pundit/actions/workflows/main.yml/badge.svg)](https://github.com/varvet/pundit/actions/workflows/main.yml)\n[![Code Climate](https://api.codeclimate.com/v1/badges/a940030f96c9fb43046a/maintainability)](https://codeclimate.com/github/varvet/pundit/maintainability)\n[![Inline docs](https://inch-ci.org/github/varvet/pundit.svg?branch=main)](https://inch-ci.org/github/varvet/pundit)\n[![Gem Version](https://badge.fury.io/rb/pundit.svg)](https://badge.fury.io/rb/pundit)\n\nPundit provides a set of helpers which guide you in leveraging regular Ruby\nclasses and object oriented design patterns to build a straightforward, robust, and\nscalable authorization system.\n\n## Links:\n\n- [API documentation for the most recent version](https://www.rubydoc.info/gems/pundit)\n- [Source Code](https://github.com/varvet/pundit)\n- [Contributing](https://github.com/varvet/pundit/blob/main/CONTRIBUTING.md)\n- [Code of Conduct](https://github.com/varvet/pundit/blob/main/CODE_OF_CONDUCT.md)\n\n<strong>Sponsored by:</strong> <a href=\"https://www.varvet.com\">Varvet<br><br><img src=\"https://github.com/varvet/pundit/assets/99166/aa9efa0a-6903-4037-abee-1824edc57f1a\" alt=\"Varvet logo\" height=\"120\"></div>\n\n## Installation\n\n> **Please note** that the README on GitHub is accurate with the _latest code on GitHub_. You are most likely using a released version of Pundit, so please refer to the [documentation for the latest released version of Pundit](https://www.rubydoc.info/gems/pundit).\n\n``` sh\nbundle add pundit\n```\n\nInclude `Pundit::Authorization` in your application controller:\n\n``` ruby\nclass ApplicationController < ActionController::Base\n  include Pundit::Authorization\nend\n```\n\nOptionally, you can run the generator, which will set up an application policy\nwith some useful defaults for you:\n\n``` sh\nrails g pundit:install\n```\n\nAfter generating your application policy, restart the Rails server so that Rails\ncan pick up any classes in the new `app/policies/` directory.\n\n## Policies\n\nPundit is focused around the notion of policy classes. We suggest that you put\nthese classes in `app/policies`. This is an example that allows updating a post\nif the user is an admin, or if the post is unpublished:\n\n``` ruby\nclass PostPolicy\n  attr_reader :user, :post\n\n  def initialize(user, post)\n    @user = user\n    @post = post\n  end\n\n  def update?\n    user.admin? || !post.published?\n  end\nend\n```\n\nAs you can see, this is a plain Ruby class. Pundit makes the following\nassumptions about this class:\n\n- The class has the same name as some kind of model class, only suffixed\n  with the word \"Policy\".\n- The first argument is a user. In your controller, Pundit will call the\n  `current_user` method to retrieve what to send into this argument\n- The second argument is some kind of model object, whose authorization\n  you want to check. This does not need to be an ActiveRecord or even\n  an ActiveModel object, it can be anything really.\n- The class implements some kind of query method, in this case `update?`.\n  Usually, this will map to the name of a particular controller action.\n\nThat's it really.\n\nUsually you'll want to inherit from the application policy created by the\ngenerator, or set up your own base class to inherit from:\n\n``` ruby\nclass PostPolicy < ApplicationPolicy\n  def update?\n    user.admin? or not record.published?\n  end\nend\n```\n\nIn the generated `ApplicationPolicy`, the model object is called `record`.\n\nSupposing that you have an instance of class `Post`, Pundit now lets you do\nthis in your controller:\n\n``` ruby\ndef update\n  @post = Post.find(params[:id])\n  authorize @post\n  if @post.update(post_params)\n    redirect_to @post\n  else\n    render :edit\n  end\nend\n```\n\nThe authorize method automatically infers that `Post` will have a matching\n`PostPolicy` class, and instantiates this class, handing in the current user\nand the given record. It then infers from the action name, that it should call\n`update?` on this instance of the policy. In this case, you can imagine that\n`authorize` would have done something like this:\n\n``` ruby\nunless PostPolicy.new(current_user, @post).update?\n  raise Pundit::NotAuthorizedError, \"not allowed to PostPolicy#update? this Post\"\nend\n```\n\nYou can pass a second argument to `authorize` if the name of the permission you\nwant to check doesn't match the action name. For example:\n\n``` ruby\ndef publish\n  @post = Post.find(params[:id])\n  authorize @post, :update?\n  @post.publish!\n  redirect_to @post\nend\n```\n\nYou can pass an argument to override the policy class if necessary. For example:\n\n```ruby\ndef create\n  @publication = find_publication # assume this method returns any model that behaves like a publication\n  # @publication.class => Post\n  authorize @publication, policy_class: PublicationPolicy\n  @publication.publish!\n  redirect_to @publication\nend\n```\n\nIf you don't have an instance for the first argument to `authorize`, then you can pass\nthe class. For example:\n\nPolicy:\n```ruby\nclass PostPolicy < ApplicationPolicy\n  def admin_list?\n    user.admin?\n  end\nend\n```\n\nController:\n```ruby\ndef admin_list\n  authorize Post # we don't have a particular post to authorize\n  # Rest of controller action\nend\n```\n\n`authorize` returns the instance passed to it, so you can chain it like this:\n\nController:\n```ruby\ndef show\n  @user = authorize User.find(params[:id])\nend\n\n# return the record even for namespaced policies\ndef show\n  @user = authorize [:admin, User.find(params[:id])]\nend\n```\n\nYou can easily get a hold of an instance of the policy through the `policy`\nmethod in both the view and controller. This is especially useful for\nconditionally showing links or buttons in the view:\n\n``` erb\n<% if policy(@post).update? %>\n  <%= link_to \"Edit post\", edit_post_path(@post) %>\n<% end %>\n```\n## Headless policies\n\nGiven there is a policy without a corresponding model / ruby class,\nyou can retrieve it by passing a symbol.\n\n```ruby\n# app/policies/dashboard_policy.rb\nclass DashboardPolicy\n  attr_reader :user\n\n  # `_record` in this example will be :dashboard\n  def initialize(user, _record)\n    @user = user\n  end\n\n  def show?\n    user.admin?\n  end\nend\n```\n\nNote that the headless policy still needs to accept two arguments. The\nsecond argument will be the symbol `:dashboard` in this case, which\nis what is passed as the record to `authorize` below.\n\n```ruby\n# In controllers\ndef show\n  authorize :dashboard, :show?\n  ...\nend\n```\n\n```erb\n# In views\n<% if policy(:dashboard).show? %>\n  <%= link_to 'Dashboard', dashboard_path %>\n<% end %>\n```\n\n## Scopes\n\nOften, you will want to have some kind of view listing records which a\nparticular user has access to. When using Pundit, you are expected to\ndefine a class called a policy scope. It can look something like this:\n\n``` ruby\nclass PostPolicy < ApplicationPolicy\n  class Scope\n    def initialize(user, scope)\n      @user  = user\n      @scope = scope\n    end\n\n    def resolve\n      if user.admin?\n        scope.all\n      else\n        scope.where(published: true)\n      end\n    end\n\n    private\n\n    attr_reader :user, :scope\n  end\n\n  def update?\n    user.admin? or not record.published?\n  end\nend\n```\n\nPundit makes the following assumptions about this class:\n\n- The class has the name `Scope` and is nested under the policy class.\n- The first argument is a user. In your controller, Pundit will call the\n  `current_user` method to retrieve what to send into this argument.\n- The second argument is a scope of some kind on which to perform some kind of\n  query. It will usually be an ActiveRecord class or a\n  `ActiveRecord::Relation`, but it could be something else entirely.\n- Instances of this class respond to the method `resolve`, which should return\n  some kind of result which can be iterated over. For ActiveRecord classes,\n  this would usually be an `ActiveRecord::Relation`.\n\nYou'll probably want to inherit from the application policy scope generated by the\ngenerator, or create your own base class to inherit from:\n\n``` ruby\nclass PostPolicy < ApplicationPolicy\n  class Scope < ApplicationPolicy::Scope\n    def resolve\n      if user.admin?\n        scope.all\n      else\n        scope.where(published: true)\n      end\n    end\n  end\n\n  def update?\n    user.admin? or not record.published?\n  end\nend\n```\n\nYou can now use this class from your controller via the `policy_scope` method:\n\n``` ruby\ndef index\n  @posts = policy_scope(Post)\nend\n\ndef show\n  @post = policy_scope(Post).find(params[:id])\nend\n```\n\nLike with the authorize method, you can also override the policy scope class:\n\n``` ruby\ndef index\n  # publication_class => Post\n  @publications = policy_scope(publication_class, policy_scope_class: PublicationPolicy::Scope)\nend\n```\n\nIn this case it is a shortcut for doing:\n\n``` ruby\ndef index\n  @publications = PublicationPolicy::Scope.new(current_user, Post).resolve\nend\n```\n\nYou can, and are encouraged to, use this method in views:\n\n``` erb\n<% policy_scope(@user.posts).each do |post| %>\n  <p><%= link_to post.title, post_path(post) %></p>\n<% end %>\n```\n\n## Ensuring policies and scopes are used\n\nWhen you are developing an application with Pundit it can be easy to forget to\nauthorize some action. People are forgetful after all. Since Pundit encourages\nyou to add the `authorize` call manually to each controller action, it's really\neasy to miss one.\n\nThankfully, Pundit has a handy feature which reminds you in case you forget.\nPundit tracks whether you have called `authorize` anywhere in your controller\naction. Pundit also adds a method to your controllers called\n`verify_authorized`. This method will raise an exception if `authorize` has not\nyet been called. You should run this method in an `after_action` hook to ensure\nthat you haven't forgotten to authorize the action. For example:\n\n``` ruby\nclass ApplicationController < ActionController::Base\n  include Pundit::Authorization\n  after_action :verify_authorized\nend\n```\n\nLikewise, Pundit also adds `verify_policy_scoped` to your controller. This\nwill raise an exception similar to `verify_authorized`. However, it tracks\nif `policy_scope` is used instead of `authorize`. This is mostly useful for\ncontroller actions like `index` which find collections with a scope and don't\nauthorize individual instances.\n\n``` ruby\nclass ApplicationController < ActionController::Base\n  include Pundit::Authorization\n  after_action :verify_pundit_authorization\n\n  def verify_pundit_authorization\n    if action_name == \"index\"\n      verify_policy_scoped\n    else\n      verify_authorized\n    end\n  end\nend\n```\n\n**This verification mechanism only exists to aid you while developing your\napplication, so you don't forget to call `authorize`. It is not some kind of\nfailsafe mechanism or authorization mechanism. You should be able to remove\nthese filters without affecting how your app works in any way.**\n\nSome people have found this feature confusing, while many others\nfind it extremely helpful. If you fall into the category of people who find it\nconfusing then you do not need to use it. Pundit will work fine without\nusing `verify_authorized` and `verify_policy_scoped`.\n\n### Conditional verification\n\nIf you're using `verify_authorized` in your controllers but need to\nconditionally bypass verification, you can use `skip_authorization`. For\nbypassing `verify_policy_scoped`, use `skip_policy_scope`. These are useful\nin circumstances where you don't want to disable verification for the\nentire action, but have some cases where you intend to not authorize.\n\n```ruby\ndef show\n  record = Record.find_by(attribute: \"value\")\n  if record.present?\n    authorize record\n  else\n    skip_authorization\n  end\nend\n```\n\n## Manually specifying policy classes\n\nSometimes you might want to explicitly declare which policy to use for a given\nclass, instead of letting Pundit infer it. This can be done like so:\n\n``` ruby\nclass Post\n  def self.policy_class\n    PostablePolicy\n  end\nend\n```\n\nAlternatively, you can declare an instance method:\n\n``` ruby\nclass Post\n  def policy_class\n    PostablePolicy\n  end\nend\n```\n\n## Plain old Ruby\n\nPundit is a very small library on purpose, and it doesn't do anything you can't do yourself. There's no secret sauce here. It does as little as possible, and then gets out of your way.\n\nWith the few but powerful helpers available in Pundit, you have the power to build a well structured, fully working authorization system without using any special DSLs or funky syntax.\n\nRemember that all of the policy and scope classes are plain Ruby classes, which means you can use the same mechanisms you always use to DRY things up. Encapsulate a set of permissions into a module and include them in multiple policies. Use `alias_method` to make some permissions behave the same as others. Inherit from a base set of permissions. Use metaprogramming if you really have to.\n\n## Generator\n\nUse the supplied generator to generate policies:\n\n``` sh\nrails g pundit:policy post\n```\n\n## Closed systems\n\nIn many applications, only logged in users are really able to do anything. If\nyou're building such a system, it can be kind of cumbersome to check that the\nuser in a policy isn't `nil` for every single permission. Aside from policies,\nyou can add this check to the base class for scopes.\n\nWe suggest that you define a filter that redirects unauthenticated users to the\nlogin page. As a secondary defence, if you've defined an ApplicationPolicy, it\nmight be a good idea to raise an exception if somehow an unauthenticated user\ngot through. This way you can fail more gracefully.\n\n``` ruby\nclass ApplicationPolicy\n  def initialize(user, record)\n    raise Pundit::NotAuthorizedError, \"must be logged in\" unless user\n    @user   = user\n    @record = record\n  end\n\n  class Scope\n    attr_reader :user, :scope\n\n    def initialize(user, scope)\n      raise Pundit::NotAuthorizedError, \"must be logged in\" unless user\n      @user = user\n      @scope = scope\n    end\n  end\nend\n```\n\n## NilClassPolicy\n\nTo support a [null object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern)\nyou may find that you want to implement a `NilClassPolicy`. This might be useful\nwhere you want to extend your ApplicationPolicy to allow some tolerance of, for\nexample, associations which might be `nil`.\n\n```ruby\nclass NilClassPolicy < ApplicationPolicy\n  class Scope < ApplicationPolicy::Scope\n    def resolve\n      raise Pundit::NotDefinedError, \"Cannot scope NilClass\"\n    end\n  end\n\n  def show?\n    false # Nobody can see nothing\n  end\nend\n```\n\n## Rescuing a denied Authorization in Rails\n\nPundit raises a `Pundit::NotAuthorizedError` you can\n[rescue_from](https://guides.rubyonrails.org/action_controller_overview.html#rescue-from)\nin your `ApplicationController`. You can customize the `user_not_authorized`\nmethod in every controller.\n\n```ruby\nclass ApplicationController < ActionController::Base\n  include Pundit::Authorization\n\n  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized\n\n  private\n\n  def user_not_authorized\n    flash[:alert] = \"You are not authorized to perform this action.\"\n    redirect_back_or_to(root_path)\n  end\nend\n```\n\nAlternatively, you can globally handle Pundit::NotAuthorizedError's by having rails handle them as a 403 error and serving a 403 error page. Add the following to application.rb:\n\n```config.action_dispatch.rescue_responses[\"Pundit::NotAuthorizedError\"] = :forbidden```\n\n## Creating custom error messages\n\n`NotAuthorizedError`s provide information on what query (e.g. `:create?`), what\nrecord (e.g. an instance of `Post`), and what policy (e.g. an instance of\n`PostPolicy`) caused the error to be raised.\n\nOne way to use these `query`, `record`, and `policy` properties is to connect\nthem with `I18n` to generate error messages. Here's how you might go about doing\nthat.\n\n```ruby\nclass ApplicationController < ActionController::Base\n rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized\n\n private\n\n def user_not_authorized(exception)\n   policy_name = exception.policy.class.to_s.underscore\n\n   flash[:error] = t \"#{policy_name}.#{exception.query}\", scope: \"pundit\", default: :default\n   redirect_back_or_to(root_path)\n end\nend\n```\n\n```yaml\nen:\n pundit:\n   default: 'You cannot perform this action.'\n   post_policy:\n     update?: 'You cannot edit this post!'\n     create?: 'You cannot create posts!'\n```\n\nThis is an example. Pundit is agnostic as to how you implement your error messaging.\n\n## Manually retrieving policies and scopes\n\nSometimes you want to retrieve a policy for a record outside the controller or\nview. For example when you delegate permissions from one policy to another.\n\nYou can easily retrieve policies and scopes like this:\n\n``` ruby\nPundit.policy!(user, post)\nPundit.policy(user, post)\n\nPundit.policy_scope!(user, Post)\nPundit.policy_scope(user, Post)\n```\n\nThe bang methods will raise an exception if the policy does not exist, whereas\nthose without the bang will return nil.\n\n## Customize Pundit user\n\nOn occasion, your controller may be unable to access `current_user`, or the method that should be invoked by Pundit may not be `current_user`. To address this, you can define a method in your controller named `pundit_user`.\n\n```ruby\ndef pundit_user\n  User.find_by_other_means\nend\n```\n### Handling User Switching in Pundit\n\nWhen switching users in your application, it's important to reset the Pundit user context to ensure that authorization policies are applied correctly for the new user. Pundit caches the user context, so failing to reset it could result in incorrect permissions being applied.\n\nTo handle user switching, you can use the following pattern in your controller:\n\n```ruby\nclass ApplicationController\n  include Pundit::Authorization\n\n  def switch_user_to(user)\n    terminate_session if authenticated?\n    start_new_session_for user\n    pundit_reset!\n  end\nend\n```\n\nMake sure to invoke `pundit_reset!` whenever changing the user. This ensures the cached authorization context is reset, preventing any incorrect permissions from being applied.\n\n## Policy Namespacing\nIn some cases it might be helpful to have multiple policies that serve different contexts for a\nresource. A prime example of this is the case where User policies differ from Admin policies. To\nauthorize with a namespaced policy, pass the namespace into the `authorize` helper in an array:\n\n```ruby\nauthorize(post)                   # => will look for a PostPolicy\nauthorize([:admin, post])         # => will look for an Admin::PostPolicy\nauthorize([:foo, :bar, post])     # => will look for a Foo::Bar::PostPolicy\n\npolicy_scope(Post)                # => will look for a PostPolicy::Scope\npolicy_scope([:admin, Post])      # => will look for an Admin::PostPolicy::Scope\npolicy_scope([:foo, :bar, Post])  # => will look for a Foo::Bar::PostPolicy::Scope\n```\n\nIf you are using namespaced policies for something like Admin views, it can be useful to\noverride the `policy_scope` and `authorize` helpers in your `AdminController` to automatically\napply the namespacing:\n\n```ruby\nclass AdminController < ApplicationController\n  def policy_scope(scope)\n    super([:admin, scope])\n  end\n\n  def authorize(record, query = nil)\n    super([:admin, record], query)\n  end\nend\n\nclass Admin::PostController < AdminController\n  def index\n    policy_scope(Post)\n  end\n\n  def show\n    post = authorize Post.find(params[:id])\n  end\nend\n```\n\n## Additional context\n\nPundit strongly encourages you to model your application in such a way that the\nonly context you need for authorization is a user object and a domain model that\nyou want to check authorization for. If you find yourself needing more context than\nthat, consider whether you are authorizing the right domain model, maybe another\ndomain model (or a wrapper around multiple domain models) can provide the context\nyou need.\n\nPundit does not allow you to pass additional arguments to policies for precisely\nthis reason.\n\nHowever, in very rare cases, you might need to authorize based on more context than just\nthe currently authenticated user. Suppose for example that authorization is dependent\non IP address in addition to the authenticated user. In that case, one option is to\ncreate a special class which wraps up both user and IP and passes it to the policy.\n\n``` ruby\nclass UserContext\n  attr_reader :user, :ip\n\n  def initialize(user, ip)\n    @user = user\n    @ip   = ip\n  end\nend\n\nclass ApplicationController\n  include Pundit::Authorization\n\n  def pundit_user\n    UserContext.new(current_user, request.ip)\n  end\nend\n```\n\n## Strong parameters\n\nIn Rails,\nmass-assignment protection is handled in the controller. With Pundit you can\ncontrol which attributes a user has access to update via your policies. You can\nset up a `permitted_attributes` method in your policy like this:\n\n```ruby\n# app/policies/post_policy.rb\nclass PostPolicy < ApplicationPolicy\n  def permitted_attributes\n    if user.admin? || user.owner_of?(post)\n      [:title, :body, :tag_list]\n    else\n      [:tag_list]\n    end\n  end\nend\n```\n\nYou can now retrieve these attributes from the policy:\n\n```ruby\n# app/controllers/posts_controller.rb\nclass PostsController < ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render :edit\n    end\n  end\n\n  private\n\n  def post_params\n    params.require(:post).permit(policy(@post).permitted_attributes)\n  end\nend\n```\n\nHowever, this is a bit cumbersome, so Pundit provides a convenient helper method:\n\n```ruby\n# app/controllers/posts_controller.rb\nclass PostsController < ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    if @post.update(permitted_attributes(@post))\n      redirect_to @post\n    else\n      render :edit\n    end\n  end\nend\n```\n\nIf you want to permit different attributes based on the current action, you can define a `permitted_attributes_for_#{action}` method on your policy:\n\n```ruby\n# app/policies/post_policy.rb\nclass PostPolicy < ApplicationPolicy\n  def permitted_attributes_for_create\n    [:title, :body]\n  end\n\n  def permitted_attributes_for_edit\n    [:body]\n  end\nend\n```\n\nIf you have defined an action-specific method on your policy for the current action, the `permitted_attributes` helper will call it instead of calling `permitted_attributes` on your controller.\n\nIf you need to fetch parameters based on namespaces different from the suggested one, override the below method, in your controller, and return an instance of `ActionController::Parameters`.\n\n```ruby\ndef pundit_params_for(record)\n  params.require(PolicyFinder.new(record).param_key)\nend\n```\n\nFor example:\n\n```ruby\n# If you don't want to use require\ndef pundit_params_for(record)\n  params.fetch(PolicyFinder.new(record).param_key, {})\nend\n\n# If you are using something like the JSON API spec\ndef pundit_params_for(_record)\n  params.fetch(:data, {}).fetch(:attributes, {})\nend\n```\n\n## RSpec\n\n### Policy Specs\n\n> [!TIP]\n> An alternative approach to Pundit policy specs is scoping them to a user context as outlined in this\n[excellent post](https://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/) and implemented in the third party [pundit-matchers](https://github.com/punditcommunity/pundit-matchers) gem.\n\nPundit includes a mini-DSL for writing expressive tests for your policies in RSpec.\nRequire `pundit/rspec` in your `spec_helper.rb`:\n\n``` ruby\nrequire \"pundit/rspec\"\n```\n\nThen put your policy specs in `spec/policies`, and make them look somewhat like this:\n\n``` ruby\ndescribe PostPolicy do\n  subject { described_class }\n\n  permissions :update?, :edit? do\n    it \"denies access if post is published\" do\n      expect(subject).not_to permit(User.new(admin: false), Post.new(published: true))\n    end\n\n    it \"grants access if post is published and user is an admin\" do\n      expect(subject).to permit(User.new(admin: true), Post.new(published: true))\n    end\n\n    it \"grants access if post is unpublished\" do\n      expect(subject).to permit(User.new(admin: false), Post.new(published: false))\n    end\n  end\nend\n```\n\n### Custom matcher description\n\nBy default rspec includes an inspected `user` and `record` in the matcher description, which might become overly verbose:\n\n```\nPostPolicy\n  update? and show?\n    is expected to permit #<User:0x0000000104aefd80> and #<Post:0x0000000104aef8d0 @user=#<User:0x0000000104aefd80>>\n```\n\nYou can override the default description with a static string, or a block:\n\n```ruby\n# static alternative: Pundit::RSpec::Matchers.description = \"permit the user\"\nPundit::RSpec::Matchers.description = ->(user, record) do\n  \"permit user with role #{user.role} to access record with ID #{record.id}\"\nend\n```\n\nWhich would make for a less chatty output:\n\n```\nPostPolicy\n  update? and show?\n    is expected to permit user with role admin to access record with ID 130\n```\n\n### Focus Support\n\nIf your RSpec config has `filter_run_when_matching :focus`, you may tag the `permissions` helper like so:\n\n```\npermissions :show?, :focus do\n```\n\n### Scope Specs\n\nPundit does not provide a DSL for testing scopes. Test them like you would a regular Ruby class!\n\n### Linting with RuboCop RSpec\n\nWhen you lint your RSpec spec files with `rubocop-rspec`, it will fail to properly detect RSpec constructs that Pundit defines, `permissions`.\nMake sure to use `rubocop-rspec` 2.0 or newer and add the following to your `.rubocop.yml`:\n\n```yaml\ninherit_gem:\n  pundit: config/rubocop-rspec.yml\n```\n\n# External Resources\n\n- [RailsApps Example Application: Pundit and Devise](https://github.com/RailsApps/rails-devise-pundit)\n- [Migrating to Pundit from CanCan](https://blog.carbonfive.com/2013/10/21/migrating-to-pundit-from-cancan/)\n- [Testing Pundit Policies with RSpec](https://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/)\n- [Testing Pundit with Minitest](https://github.com/varvet/pundit/issues/204#issuecomment-60166450)\n- [Using Pundit outside of a Rails controller](https://github.com/varvet/pundit/pull/136)\n- [Straightforward Rails Authorization with Pundit](https://www.sitepoint.com/straightforward-rails-authorization-with-pundit/)\n\n## Other implementations\n\n- [Flask-Pundit](https://github.com/anurag90x/flask-pundit) (Python) is a [Flask](https://flask.pocoo.org/) extension \"heavily inspired by\" Pundit\n\n# License\n\nLicensed under the MIT license, see the separate LICENSE.txt file.\n",
        "releases": []
    }
}
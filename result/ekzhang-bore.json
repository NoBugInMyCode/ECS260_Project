{
    "https://api.github.com/repos/ekzhang/bore": {
        "forks": 381,
        "watchers": 9071,
        "stars": 9071,
        "languages": {
            "Rust": 26471,
            "Shell": 1390,
            "Dockerfile": 218
        },
        "commits": [
            "2025-01-10T18:31:56Z",
            "2024-12-05T18:42:39Z",
            "2024-12-05T18:33:13Z",
            "2024-10-16T16:32:35Z",
            "2024-10-15T23:50:33Z",
            "2024-06-13T13:38:59Z",
            "2024-06-11T01:50:23Z",
            "2024-06-11T01:04:14Z",
            "2024-06-11T00:54:40Z",
            "2023-07-27T15:26:01Z",
            "2023-04-29T15:08:35Z",
            "2023-04-28T13:57:45Z",
            "2023-04-28T02:02:18Z",
            "2023-04-28T01:55:44Z",
            "2023-04-28T01:48:47Z",
            "2023-01-01T21:06:59Z",
            "2022-11-11T06:42:04Z",
            "2022-11-11T06:14:42Z",
            "2022-11-11T06:08:50Z",
            "2022-11-11T05:52:58Z",
            "2022-06-26T22:01:08Z",
            "2022-06-05T17:00:16Z",
            "2022-04-22T22:14:05Z",
            "2022-04-22T22:04:26Z",
            "2022-04-22T03:48:38Z",
            "2022-04-21T04:17:14Z",
            "2022-04-14T19:24:09Z",
            "2022-04-14T18:40:52Z",
            "2022-04-14T18:39:46Z",
            "2022-04-14T18:33:31Z"
        ],
        "creation_date": "2022-04-04T02:47:54Z",
        "contributors": 18,
        "topics": [
            "cli",
            "localhost",
            "networking",
            "proxy",
            "rust",
            "self-hosted",
            "tcp",
            "tunnel"
        ],
        "subscribers": 55,
        "readme": "# bore\n\n[![Build status](https://img.shields.io/github/actions/workflow/status/ekzhang/bore/ci.yml)](https://github.com/ekzhang/bore/actions)\n[![Crates.io](https://img.shields.io/crates/v/bore-cli.svg)](https://crates.io/crates/bore-cli)\n\nA modern, simple TCP tunnel in Rust that exposes local ports to a remote server, bypassing standard NAT connection firewalls. **That's all it does: no more, and no less.**\n\n![Video demo](https://i.imgur.com/vDeGsmx.gif)\n\n```shell\n# Installation (requires Rust, see alternatives below)\ncargo install bore-cli\n\n# On your local machine\nbore local 8000 --to bore.pub\n```\n\nThis will expose your local port at `localhost:8000` to the public internet at `bore.pub:<PORT>`, where the port number is assigned randomly.\n\nSimilar to [localtunnel](https://github.com/localtunnel/localtunnel) and [ngrok](https://ngrok.io/), except `bore` is intended to be a highly efficient, unopinionated tool for forwarding TCP traffic that is simple to install and easy to self-host, with no frills attached.\n\n(`bore` totals about 400 lines of safe, async Rust code and is trivial to set up \u2014 just run a single binary for the client and server.)\n\n## Installation\n\nIf you're on macOS, `bore` is packaged as a Homebrew core formula.\n\n```shell\nbrew install bore-cli\n```\n\nOtherwise, the easiest way to install bore is from prebuilt binaries. These are available on the [releases page](https://github.com/ekzhang/bore/releases) for macOS, Windows, and Linux. Just unzip the appropriate file for your platform and move the `bore` executable into a folder on your PATH.\n\nYou also can build `bore` from source using [Cargo](https://doc.rust-lang.org/cargo/), the Rust package manager. This command installs the `bore` binary at a user-accessible path.\n\n```shell\ncargo install bore-cli\n```\n\nWe also publish versioned Docker images for each release. The image is built for an AMD 64-bit architecture. They're tagged with the specific version and allow you to run the statically-linked `bore` binary from a minimal \"scratch\" container.\n\n```shell\ndocker run -it --init --rm --network host ekzhang/bore <ARGS>\n```\n\n## Detailed Usage\n\nThis section describes detailed usage for the `bore` CLI command.\n\n### Local Forwarding\n\nYou can forward a port on your local machine by using the `bore local` command. This takes a positional argument, the local port to forward, as well as a mandatory `--to` option, which specifies the address of the remote server.\n\n```shell\nbore local 5000 --to bore.pub\n```\n\nYou can optionally pass in a `--port` option to pick a specific port on the remote to expose, although the command will fail if this port is not available. Also, passing `--local-host` allows you to expose a different host on your local area network besides the loopback address `localhost`.\n\nThe full options are shown below.\n\n```shell\nStarts a local proxy to the remote server\n\nUsage: bore local [OPTIONS] --to <TO> <LOCAL_PORT>\n\nArguments:\n  <LOCAL_PORT>  The local port to expose\n\nOptions:\n  -l, --local-host <HOST>  The local host to expose [default: localhost]\n  -t, --to <TO>            Address of the remote server to expose local ports to [env: BORE_SERVER=]\n  -p, --port <PORT>        Optional port on the remote server to select [default: 0]\n  -s, --secret <SECRET>    Optional secret for authentication [env: BORE_SECRET]\n  -h, --help               Print help information\n```\n\n### Self-Hosting\n\nAs mentioned in the startup instructions, there is a public instance of the `bore` server running at `bore.pub`. However, if you want to self-host `bore` on your own network, you can do so with the following command:\n\n```shell\nbore server\n```\n\nThat's all it takes! After the server starts running at a given address, you can then update the `bore local` command with option `--to <ADDRESS>` to forward a local port to this remote server.\n\nThe full options for the `bore server` command are shown below.\n\n```shell\nRuns the remote proxy server\n\nUsage: bore server [OPTIONS]\n\nOptions:\n      --min-port <MIN_PORT>  Minimum accepted TCP port number [default: 1024, env: BORE_MIN_PORT]\n      --max-port <MAX_PORT>  Maximum accepted TCP port number [default: 65535, env: BORE_MAX_PORT]\n  -s, --secret <SECRET>      Optional secret for authentication [env: BORE_SECRET]\n  -h, --help                 Print help information\n```\n\n## Protocol\n\nThere is an implicit _control port_ at `7835`, used for creating new connections on demand. At initialization, the client sends a \"Hello\" message to the server on the TCP control port, asking to proxy a selected remote port. The server then responds with an acknowledgement and begins listening for external TCP connections.\n\nWhenever the server obtains a connection on the remote port, it generates a secure [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) for that connection and sends it back to the client. The client then opens a separate TCP stream to the server and sends an \"Accept\" message containing the UUID on that stream. The server then proxies the two connections between each other.\n\nFor correctness reasons and to avoid memory leaks, incoming connections are only stored by the server for up to 10 seconds before being discarded if the client does not accept them.\n\n## Authentication\n\nOn a custom deployment of `bore server`, you can optionally require a _secret_ to prevent the server from being used by others. The protocol requires clients to verify possession of the secret on each TCP connection by answering random challenges in the form of HMAC codes. (This secret is only used for the initial handshake, and no further traffic is encrypted by default.)\n\n```shell\n# on the server\nbore server --secret my_secret_string\n\n# on the client\nbore local <LOCAL_PORT> --to <TO> --secret my_secret_string\n```\n\nIf a secret is not present in the arguments, `bore` will also attempt to read from the `BORE_SECRET` environment variable.\n\n## Acknowledgements\n\nCreated by Eric Zhang ([@ekzhang1](https://twitter.com/ekzhang1)). Licensed under the [MIT license](LICENSE).\n\nThe author would like to thank the contributors and maintainers of the [Tokio](https://tokio.rs/) project for making it possible to write ergonomic and efficient network services in Rust.\n",
        "releases": [
            {
                "name": "v0.5.2",
                "date": "2024-12-05T18:44:54Z"
            },
            {
                "name": "v0.5.1",
                "date": "2024-06-11T01:51:34Z"
            },
            {
                "name": "v0.5.0",
                "date": "2023-04-28T02:05:39Z"
            },
            {
                "name": "v0.4.1",
                "date": "2022-11-11T06:17:48Z"
            },
            {
                "name": "v0.4.0",
                "date": "2022-04-22T22:25:36Z"
            },
            {
                "name": "v0.3.0",
                "date": "2022-04-14T19:29:14Z"
            },
            {
                "name": "v0.2.3",
                "date": "2022-04-11T03:58:29Z"
            },
            {
                "name": "v0.2.1",
                "date": "2022-04-09T07:07:00Z"
            },
            {
                "name": "v0.2.0",
                "date": "2022-04-08T08:20:58Z"
            }
        ]
    }
}
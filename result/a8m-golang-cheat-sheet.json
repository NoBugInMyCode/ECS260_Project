{
    "https://api.github.com/repos/a8m/golang-cheat-sheet": {
        "forks": 1100,
        "watchers": 8522,
        "stars": 8522,
        "languages": {},
        "commits": [
            "2022-08-27T06:07:02Z",
            "2021-12-11T10:13:28Z",
            "2021-04-04T12:21:06Z",
            "2021-04-04T12:13:39Z",
            "2021-04-04T12:05:33Z",
            "2021-04-03T12:33:29Z",
            "2019-02-18T08:07:09Z",
            "2019-02-18T02:56:35Z",
            "2019-02-07T15:20:24Z",
            "2019-02-07T12:30:08Z",
            "2018-11-12T16:57:42Z",
            "2018-11-12T12:25:46Z",
            "2018-10-19T00:40:26Z",
            "2018-10-18T10:50:50Z",
            "2018-10-17T11:31:26Z",
            "2018-08-20T05:36:40Z",
            "2018-08-20T05:35:12Z",
            "2018-07-28T09:54:29Z",
            "2018-07-28T09:43:45Z",
            "2018-03-15T14:28:31Z",
            "2018-03-10T23:36:54Z",
            "2018-03-10T18:42:54Z",
            "2018-03-02T12:49:49Z",
            "2018-03-02T07:38:30Z",
            "2018-01-28T12:03:12Z",
            "2018-01-28T10:15:29Z",
            "2018-01-13T14:57:22Z",
            "2018-01-13T13:21:03Z",
            "2017-09-14T08:17:44Z",
            "2017-09-14T06:16:21Z"
        ],
        "creation_date": "2014-02-13T11:24:58Z",
        "contributors": 29,
        "topics": [
            "cheat-sheets",
            "cheatsheet",
            "go",
            "golang"
        ],
        "subscribers": 206,
        "readme": "# Go Cheat Sheet\n\n# Index\n1. [Basic Syntax](#basic-syntax)\n2. [Operators](#operators)\n    * [Arithmetic](#arithmetic)\n    * [Comparison](#comparison)\n    * [Logical](#logical)\n    * [Other](#other)\n3. [Declarations](#declarations)\n4. [Functions](#functions)\n    * [Functions as values and closures](#functions-as-values-and-closures)\n    * [Variadic Functions](#variadic-functions)\n5. [Built-in Types](#built-in-types)\n6. [Type Conversions](#type-conversions)\n7. [Packages](#packages)\n8. [Control structures](#control-structures)\n    * [If](#if)\n    * [Loops](#loops)\n    * [Switch](#switch)\n9. [Arrays, Slices, Ranges](#arrays-slices-ranges)\n    * [Arrays](#arrays)\n    * [Slices](#slices)\n    * [Operations on Arrays and Slices](#operations-on-arrays-and-slices)\n10. [Maps](#maps)\n11. [Structs](#structs)\n12. [Pointers](#pointers)\n13. [Interfaces](#interfaces)\n14. [Embedding](#embedding)\n15. [Errors](#errors)\n16. [Concurrency](#concurrency)\n    * [Goroutines](#goroutines)\n    * [Channels](#channels)\n    * [Channel Axioms](#channel-axioms)\n17. [Printing](#printing)\n18. [Reflection](#reflection)\n    * [Type Switch](#type-switch)\n    * [Examples](https://github.com/a8m/reflect-examples)\n19. [Snippets](#snippets)\n    * [Files Embedding](#files-embedding)\n    * [HTTP Server](#http-server)\n\n## Credits\n\nMost example code taken from [A Tour of Go](http://tour.golang.org/), which is an excellent introduction to Go.\nIf you're new to Go, do that tour. Seriously.\n\n## Go in a Nutshell\n\n* Imperative language\n* Statically typed\n* Syntax tokens similar to C (but less parentheses and no semicolons) and the structure to Oberon-2\n* Compiles to native code (no JVM)\n* No classes, but structs with methods\n* Interfaces\n* No implementation inheritance. There's [type embedding](http://golang.org/doc/effective%5Fgo.html#embedding), though.\n* Functions are first class citizens\n* Functions can return multiple values\n* Has closures\n* Pointers, but not pointer arithmetic\n* Built-in concurrency primitives: Goroutines and Channels\n\n# Basic Syntax\n\n## Hello World\nFile `hello.go`:\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello Go\")\n}\n```\n`$ go run hello.go`\n\n## Operators\n### Arithmetic\n|Operator|Description|\n|--------|-----------|\n|`+`|addition|\n|`-`|subtraction|\n|`*`|multiplication|\n|`/`|quotient|\n|`%`|remainder|\n|`&`|bitwise and|\n|`\\|`|bitwise or|\n|`^`|bitwise xor|\n|`&^`|bit clear (and not)|\n|`<<`|left shift|\n|`>>`|right shift|\n\n### Comparison\n|Operator|Description|\n|--------|-----------|\n|`==`|equal|\n|`!=`|not equal|\n|`<`|less than|\n|`<=`|less than or equal|\n|`>`|greater than|\n|`>=`|greater than or equal|\n\n### Logical\n|Operator|Description|\n|--------|-----------|\n|`&&`|logical and|\n|`\\|\\|`|logical or|\n|`!`|logical not|\n\n### Other\n|Operator|Description|\n|--------|-----------|\n|`&`|address of / create pointer|\n|`*`|dereference pointer|\n|`<-`|send / receive operator (see 'Channels' below)|\n\n## Declarations\nType goes after identifier!\n```go\nvar foo int // declaration without initialization\nvar foo int = 42 // declaration with initialization\nvar foo, bar int = 42, 1302 // declare and init multiple vars at once\nvar foo = 42 // type omitted, will be inferred\nfoo := 42 // shorthand, only in func bodies, omit var keyword, type is always implicit\nconst constant = \"This is a constant\"\n\n// iota can be used for incrementing numbers, starting from 0\nconst (\n    _ = iota\n    a\n    b\n    c = 1 << iota\n    d\n)\n    fmt.Println(a, b) // 1 2 (0 is skipped)\n    fmt.Println(c, d) // 8 16 (2^3, 2^4)\n```\n\n## Functions\n```go\n// a simple function\nfunc functionName() {}\n\n// function with parameters (again, types go after identifiers)\nfunc functionName(param1 string, param2 int) {}\n\n// multiple parameters of the same type\nfunc functionName(param1, param2 int) {}\n\n// return type declaration\nfunc functionName() int {\n    return 42\n}\n\n// Can return multiple values at once\nfunc returnMulti() (int, string) {\n    return 42, \"foobar\"\n}\nvar x, str = returnMulti()\n\n// Return multiple named results simply by return\nfunc returnMulti2() (n int, s string) {\n    n = 42\n    s = \"foobar\"\n    // n and s will be returned\n    return\n}\nvar x, str = returnMulti2()\n\n```\n\n### Functions As Values And Closures\n```go\nfunc main() {\n    // assign a function to a name\n    add := func(a, b int) int {\n        return a + b\n    }\n    // use the name to call the function\n    fmt.Println(add(3, 4))\n}\n\n// Closures, lexically scoped: Functions can access values that were\n// in scope when defining the function\nfunc scope() func() int{\n    outer_var := 2\n    foo := func() int { return outer_var}\n    return foo\n}\n\nfunc another_scope() func() int{\n    // won't compile because outer_var and foo not defined in this scope\n    outer_var = 444\n    return foo\n}\n\n\n// Closures\nfunc outer() (func() int, int) {\n    outer_var := 2\n    inner := func() int {\n        outer_var += 99 // outer_var from outer scope is mutated.\n        return outer_var\n    }\n    inner()\n    return inner, outer_var // return inner func and mutated outer_var 101\n}\n```\n\n### Variadic Functions\n```go\nfunc main() {\n\tfmt.Println(adder(1, 2, 3)) \t// 6\n\tfmt.Println(adder(9, 9))\t// 18\n\n\tnums := []int{10, 20, 30}\n\tfmt.Println(adder(nums...))\t// 60\n}\n\n// By using ... before the type name of the last parameter you can indicate that it takes zero or more of those parameters.\n// The function is invoked like any other function except we can pass as many arguments as we want.\nfunc adder(args ...int) int {\n\ttotal := 0\n\tfor _, v := range args { // Iterates over the arguments whatever the number.\n\t\ttotal += v\n\t}\n\treturn total\n}\n```\n\n## Built-in Types\n```go\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // alias for uint8\n\nrune // alias for int32 ~= a character (Unicode code point) - very Viking\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\nAll Go's predeclared identifiers are defined in the [builtin](https://golang.org/pkg/builtin/) package.  \n\n## Type Conversions\n```go\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\n// alternative syntax\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n## Packages\n* Package declaration at top of every source file\n* Executables are in package `main`\n* Convention: package name == last name of import path (import path `math/rand` => package `rand`)\n* Upper case identifier: exported (visible from other packages)\n* Lower case identifier: private (not visible from other packages)\n\n## Control structures\n\n### If\n```go\nfunc main() {\n\t// Basic one\n\tif x > 10 {\n\t\treturn x\n\t} else if x == 10 {\n\t\treturn 10\n\t} else {\n\t\treturn -x\n\t}\n\n\t// You can put one statement before the condition\n\tif a := b + c; a < 42 {\n\t\treturn a\n\t} else {\n\t\treturn a - 42\n\t}\n\n\t// Type assertion inside if\n\tvar val interface{} = \"foo\"\n\tif str, ok := val.(string); ok {\n\t\tfmt.Println(str)\n\t}\n}\n```\n\n### Loops\n```go\n    // There's only `for`, no `while`, no `until`\n    for i := 1; i < 10; i++ {\n    }\n    for ; i < 10;  { // while - loop\n    }\n    for i < 10  { // you can omit semicolons if there is only a condition\n    }\n    for { // you can omit the condition ~ while (true)\n    }\n    \n    // use break/continue on current loop\n    // use break/continue with label on outer loop\nhere:\n    for i := 0; i < 2; i++ {\n        for j := i + 1; j < 3; j++ {\n            if i == 0 {\n                continue here\n            }\n            fmt.Println(j)\n            if j == 2 {\n                break\n            }\n        }\n    }\n\nthere:\n    for i := 0; i < 2; i++ {\n        for j := i + 1; j < 3; j++ {\n            if j == 1 {\n                continue\n            }\n            fmt.Println(j)\n            if j == 2 {\n                break there\n            }\n        }\n    }\n```\n\n### Switch\n```go\n    // switch statement\n    switch operatingSystem {\n    case \"darwin\":\n        fmt.Println(\"Mac OS Hipster\")\n        // cases break automatically, no fallthrough by default\n    case \"linux\":\n        fmt.Println(\"Linux Geek\")\n    default:\n        // Windows, BSD, ...\n        fmt.Println(\"Other\")\n    }\n\n    // as with for and if, you can have an assignment statement before the switch value\n    switch os := runtime.GOOS; os {\n    case \"darwin\": ...\n    }\n\n    // you can also make comparisons in switch cases\n    number := 42\n    switch {\n        case number < 42:\n            fmt.Println(\"Smaller\")\n        case number == 42:\n            fmt.Println(\"Equal\")\n        case number > 42:\n            fmt.Println(\"Greater\")\n    }\n\n    // cases can be presented in comma-separated lists\n    var char byte = '?'\n    switch char {\n        case ' ', '?', '&', '=', '#', '+', '%':\n            fmt.Println(\"Should escape\")\n    }\n```\n\n## Arrays, Slices, Ranges\n\n### Arrays\n```go\nvar a [10]int // declare an int array with length 10. Array length is part of the type!\na[3] = 42     // set elements\ni := a[3]     // read elements\n\n// declare and initialize\nvar a = [2]int{1, 2}\na := [2]int{1, 2} //shorthand\na := [...]int{1, 2} // elipsis -> Compiler figures out array length\n```\n\n### Slices\n```go\nvar a []int                              // declare a slice - similar to an array, but length is unspecified\nvar a = []int {1, 2, 3, 4}               // declare and initialize a slice (backed by the array given implicitly)\na := []int{1, 2, 3, 4}                   // shorthand\nchars := []string{0:\"a\", 2:\"c\", 1: \"b\"}  // [\"a\", \"b\", \"c\"]\n\nvar b = a[lo:hi]\t// creates a slice (view of the array) from index lo to hi-1\nvar b = a[1:4]\t\t// slice from index 1 to 3\nvar b = a[:3]\t\t// missing low index implies 0\nvar b = a[3:]\t\t// missing high index implies len(a)\na =  append(a,17,3)\t// append items to slice a\nc := append(a,b...)\t// concatenate slices a and b\n\n// create a slice with make\na = make([]byte, 5, 5)\t// first arg length, second capacity\na = make([]byte, 5)\t// capacity is optional\n\n// create a slice from an array\nx := [3]string{\"\u041b\u0430\u0439\u043a\u0430\", \"\u0411\u0435\u043b\u043a\u0430\", \"\u0421\u0442\u0440\u0435\u043b\u043a\u0430\"}\ns := x[:] // a slice referencing the storage of x\n```\n\n### Operations on Arrays and Slices\n`len(a)` gives you the length of an array/a slice. It's a built-in function, not a attribute/method on the array.\n\n```go\n// loop over an array/a slice\nfor i, e := range a {\n    // i is the index, e the element\n}\n\n// if you only need e:\nfor _, e := range a {\n    // e is the element\n}\n\n// ...and if you only need the index\nfor i := range a {\n}\n\n// In Go pre-1.4, you'll get a compiler error if you're not using i and e.\n// Go 1.4 introduced a variable-free form, so that you can do this\nfor range time.Tick(time.Second) {\n    // do it once a sec\n}\n\n```\n\n## Maps\n\n```go\nm := make(map[string]int)\nm[\"key\"] = 42\nfmt.Println(m[\"key\"])\n\ndelete(m, \"key\")\n\nelem, ok := m[\"key\"] // test if key \"key\" is present and retrieve it, if so\n\n// map literal\nvar m = map[string]Vertex{\n    \"Bell Labs\": {40.68433, -74.39967},\n    \"Google\":    {37.42202, -122.08408},\n}\n\n// iterate over map content\nfor key, value := range m {\n}\n\n```\n\n## Structs\n\nThere are no classes, only structs. Structs can have methods.\n```go\n// A struct is a type. It's also a collection of fields\n\n// Declaration\ntype Vertex struct {\n    X, Y float64\n}\n\n// Creating\nvar v = Vertex{1, 2}\nvar v = Vertex{X: 1, Y: 2} // Creates a struct by defining values with keys\nvar v = []Vertex{{1,2},{5,2},{5,5}} // Initialize a slice of structs\n\n// Accessing members\nv.X = 4\n\n// You can declare methods on structs. The struct you want to declare the\n// method on (the receiving type) comes between the the func keyword and\n// the method name. The struct is copied on each method call(!)\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n// Call method\nv.Abs()\n\n// For mutating methods, you need to use a pointer (see below) to the Struct\n// as the type. With this, the struct value is not copied for the method call.\nfunc (v *Vertex) add(n float64) {\n    v.X += n\n    v.Y += n\n}\n\n```\n**Anonymous structs:**\nCheaper and safer than using `map[string]interface{}`.\n```go\npoint := struct {\n\tX, Y int\n}{1, 2}\n```\n\n## Pointers\n```go\np := Vertex{1, 2}  // p is a Vertex\nq := &p            // q is a pointer to a Vertex\nr := &Vertex{1, 2} // r is also a pointer to a Vertex\n\n// The type of a pointer to a Vertex is *Vertex\n\nvar s *Vertex = new(Vertex) // new creates a pointer to a new struct instance\n```\n\n## Interfaces\n```go\n// interface declaration\ntype Awesomizer interface {\n    Awesomize() string\n}\n\n// types do *not* declare to implement interfaces\ntype Foo struct {}\n\n// instead, types implicitly satisfy an interface if they implement all required methods\nfunc (foo Foo) Awesomize() string {\n    return \"Awesome!\"\n}\n```\n\n## Embedding\n\nThere is no subclassing in Go. Instead, there is interface and struct embedding.\n\n```go\n// ReadWriter implementations must satisfy both Reader and Writer\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Server exposes all the methods that Logger has\ntype Server struct {\n    Host string\n    Port int\n    *log.Logger\n}\n\n// initialize the embedded type the usual way\nserver := &Server{\"localhost\", 80, log.New(...)}\n\n// methods implemented on the embedded struct are passed through\nserver.Log(...) // calls server.Logger.Log(...)\n\n// the field name of the embedded type is its type name (in this case Logger)\nvar logger *log.Logger = server.Logger\n```\n\n## Errors\n\nThere is no exception handling. Instead, functions that might produce an error just declare an additional return value of type [`error`](https://golang.org/pkg/builtin/#error). This is the `error` interface:\n\n```go\n// The error built-in interface type is the conventional interface for representing an error condition,\n// with the nil value representing no error.\ntype error interface {\n    Error() string\n}\n```\n\nHere's an example:\n```go\nfunc sqrt(x float64) (float64, error) {\n\tif x < 0 {\n\t\treturn 0, errors.New(\"negative value\")\n\t}\n\treturn math.Sqrt(x), nil\n}\n\nfunc main() {\n\tval, err := sqrt(-1)\n\tif err != nil {\n\t\t// handle error\n\t\tfmt.Println(err) // negative value\n\t\treturn\n\t}\n\t// All is good, use `val`.\n\tfmt.Println(val)\n}\n```\n\n# Concurrency\n\n## Goroutines\nGoroutines are lightweight threads (managed by Go, not OS threads). `go f(a, b)` starts a new goroutine which runs `f` (given `f` is a function).\n\n```go\n// just a function (which can be later started as a goroutine)\nfunc doStuff(s string) {\n}\n\nfunc main() {\n    // using a named function in a goroutine\n    go doStuff(\"foobar\")\n\n    // using an anonymous inner function in a goroutine\n    go func (x int) {\n        // function body goes here\n    }(42)\n}\n```\n\n## Channels\n```go\nch := make(chan int) // create a channel of type int\nch <- 42             // Send a value to the channel ch.\nv := <-ch            // Receive a value from ch\n\n// Non-buffered channels block. Read blocks when no value is available, write blocks until there is a read.\n\n// Create a buffered channel. Writing to a buffered channels does not block if less than <buffer size> unread values have been written.\nch := make(chan int, 100)\n\nclose(ch) // closes the channel (only sender should close)\n\n// read from channel and test if it has been closed\nv, ok := <-ch\n\n// if ok is false, channel has been closed\n\n// Read from channel until it is closed\nfor i := range ch {\n    fmt.Println(i)\n}\n\n// select blocks on multiple channel operations, if one unblocks, the corresponding case is executed\nfunc doStuff(channelOut, channelIn chan int) {\n    select {\n    case channelOut <- 42:\n        fmt.Println(\"We could write to channelOut!\")\n    case x := <- channelIn:\n        fmt.Println(\"We could read from channelIn\")\n    case <-time.After(time.Second * 1):\n        fmt.Println(\"timeout\")\n    }\n}\n```\n\n### Channel Axioms\n- A send to a nil channel blocks forever\n\n  ```go\n  var c chan string\n  c <- \"Hello, World!\"\n  // fatal error: all goroutines are asleep - deadlock!\n  ```\n- A receive from a nil channel blocks forever\n\n  ```go\n  var c chan string\n  fmt.Println(<-c)\n  // fatal error: all goroutines are asleep - deadlock!\n  ```\n- A send to a closed channel panics\n\n  ```go\n  var c = make(chan string, 1)\n  c <- \"Hello, World!\"\n  close(c)\n  c <- \"Hello, Panic!\"\n  // panic: send on closed channel\n  ```\n- A receive from a closed channel returns the zero value immediately\n\n  ```go\n  var c = make(chan int, 2)\n  c <- 1\n  c <- 2\n  close(c)\n  for i := 0; i < 3; i++ {\n      fmt.Printf(\"%d \", <-c)\n  }\n  // 1 2 0\n  ```\n\n## Printing\n\n```go\nfmt.Println(\"Hello, \u4f60\u597d, \u0928\u092e\u0938\u094d\u0924\u0947, \u041f\u0440\u0438\u0432\u0435\u0442, \u13a3\u13cf\u13f2\") // basic print, plus newline\np := struct { X, Y int }{ 17, 2 }\nfmt.Println( \"My point:\", p, \"x coord=\", p.X ) // print structs, ints, etc\ns := fmt.Sprintln( \"My point:\", p, \"x coord=\", p.X ) // print to string variable\n\nfmt.Printf(\"%d hex:%x bin:%b fp:%f sci:%e\",17,17,17,17.0,17.0) // c-ish format\ns2 := fmt.Sprintf( \"%d %f\", 17, 17.0 ) // formatted print to string variable\n\nhellomsg := `\n \"Hello\" in Chinese is \u4f60\u597d ('Ni Hao')\n \"Hello\" in Hindi is \u0928\u092e\u0938\u094d\u0924\u0947 ('Namaste')\n` // multi-line string literal, using back-tick at beginning and end\n```\n\n## Reflection\n### Type Switch\nA type switch is like a regular switch statement, but the cases in a type switch specify types (not values) which are compared against the type of the value held by the given interface value.\n```go\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}\n```\n\n# Snippets\n\n## Files Embedding\n\nGo programs can embed static files using the `\"embed\"` package as follows:\n\n```go\npackage main\n\nimport (\n\t\"embed\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// content holds the static content (2 files) for the web server.\n//go:embed a.txt b.txt\nvar content embed.FS\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.FS(content)))\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n[Full Playground Example](https://play.golang.org/p/pwWxdrQSrYv)\n\n## HTTP Server\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\n// define a type for the response\ntype Hello struct{}\n\n// let that type implement the ServeHTTP method (defined in interface http.Handler)\nfunc (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprint(w, \"Hello!\")\n}\n\nfunc main() {\n    var h Hello\n    http.ListenAndServe(\"localhost:4000\", h)\n}\n\n// Here's the method signature of http.ServeHTTP:\n// type Handler interface {\n//     ServeHTTP(w http.ResponseWriter, r *http.Request)\n// }\n```\n\n\n",
        "releases": []
    }
}